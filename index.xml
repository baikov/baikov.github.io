<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>baikov.dev</title><link>https://baikov.dev/</link><description>baikov.dev</description><generator>Hugo -- gohugo.io</generator><language>ru</language><managingEditor>alex@baikov.dev (Baikov)</managingEditor><webMaster>alex@baikov.dev (Baikov)</webMaster><lastBuildDate>Wed, 08 Dec 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://baikov.dev/index.xml" rel="self" type="application/rss+xml"/><item><title>Установка и настройка Neovim</title><link>https://baikov.dev/neovim-settings/</link><pubDate>Mon, 21 Dec 2020 00:00:00 +0000</pubDate><author><name>Baikov</name></author><guid>https://baikov.dev/neovim-settings/</guid><description><![CDATA[Установка Neovim Сверхрасширяемый текстовый редактор на основе Vim1
 1  brew install neovim   Установка vim-plugМинималистичный менеджер плагинов Vim.2
1  curl -fLo ~/.config/nvim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim   Файл конфигурации Neovim для MacСоздаем файл ~/.comfig/nvim/init.vim со следующим содержимым:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274  &#34; Baseset mouse=aset encoding=utf-8set numberset noswapfileset scrolloff=7set tabstop=4set softtabstop=4set shiftwidth=4set expandtabset autoindentset fileformat=unixset t_Co=256set guifont=Monaco:h18set colorcolumn=120&#34; load filetype-specific indent filesfiletype indent on&#34; Pluginscall plug#begin(&#39;~/.]]></description></item><item><title>Тестовое задание на вакансию Код-ревьюера в Яндекс.Практикум</title><link>https://baikov.dev/yandex-praktikum-reviewer-test-task/</link><pubDate>Sat, 04 Jun 2022 00:00:00 +0000</pubDate><author><name>Baikov</name></author><guid>https://baikov.dev/yandex-praktikum-reviewer-test-task/</guid><description>HR прислал на почту ссылку на Яндекс-форму с вопросами. На выполнение тестового задания дается 3 дня, но если времени мало - просят предупредить об этом заранее.
Подробнее о вакансии.
Вопрос №1: DjangoРасскажите, чем отличается select_related от prefetch_related.
Мой ответ select_related:
используется, когда мы собираемся получить один связанный объект (OneToOne, ForeignKey); делает SQL join в том же запросе и возвращает результат как часть таблицы. prefetch_related:
используется, когда мы собираемся получить набор объектов (ManyToMany, или обратная связь ForeignKey); выполняет дополнительный запрос к базе с набором id (SELECT &amp;lt;something&amp;gt; WHERE pk IN (.</description></item><item><title>Декораторы в Python: определение, особенности, примеры декораторов</title><link>https://baikov.dev/decorators-in-python/</link><pubDate>Tue, 05 Apr 2022 00:00:00 +0000</pubDate><author><name>Baikov</name></author><guid>https://baikov.dev/decorators-in-python/</guid><description>Список вопросов к Python собеседованию
Схема для понимания итераторов и генераторов" Схема для понимания итераторов и генераторов -- -- Паттерн проектирования &amp;ldquo;Декоратор&amp;rdquo; Декоратор (Decorator) — структурный шаблон проектирования, предназначенный для динамического подключения дополнительного поведения к объекту. Шаблон Декоратор предоставляет гибкую альтернативу практике создания подклассов с целью расширения функциональности.1
Декораторы в PythonДекоратор — это функция, которая позволяет обернуть другую функцию для расширения её функциональности без непосредственного изменения её кода.</description></item><item><title>Сопрограммы (corutines) в Python</title><link>https://baikov.dev/coroutines-in-python/</link><pubDate>Sat, 12 Mar 2022 00:00:00 +0000</pubDate><author><name>Baikov</name></author><guid>https://baikov.dev/coroutines-in-python/</guid><description>Список вопросов к Python собеседованию
Сопрограммы – это особый тип функций, которые сознательно передают управление вызывающему объекту, но они не заканчивают свой контекст в процессе, поддерживая его в состоянии ожидания.
Сопрограмма сама решает, когда перенаправить flow в другое место (например, в другую сопрограмму). И это позволяет строить красивые разветвленные деревья обработки потоков данных, реализовывать MapReduce, возможно прокидывать текущие байты через сокет на другую ноду. Более того, сопрограммы могут быть фактически реализованы абсолютно на любом языке.</description></item><item><title>Итераторы, генераторы и итерируемые объекты в Python</title><link>https://baikov.dev/iterators-and-generators-python/</link><pubDate>Wed, 02 Mar 2022 00:00:00 +0000</pubDate><author><name>Baikov</name></author><guid>https://baikov.dev/iterators-and-generators-python/</guid><description>Список вопросов к Python собеседованию
Схема для понимания итераторов и генераторов" Схема для понимания итераторов и генераторов ИтераторИтератор — это:
интерфейс, предоставляющий доступ к элементам коллекции (массива или контейнера). Коллекции не должны обязательно существовать в памяти и быть конечными. объект, в котором есть два метода: __iter__ (возвращает сам объект итератора) и __next__ (возвращает следующее значение из итератора) Особенности итератора:
при запросе каждого следующего значения, итератор знает, как его вычислить хранит информацию о текущем состоянии итерируемого объекта, над которым он работает почти всегда возвращает себя из метода __iter__, так как выступает итераторами для самого себя (есть исключения) итератор не должен иметь и часто не имеет определённой длины.</description></item><item><title>Важные разделы PEP</title><link>https://baikov.dev/important-peps/</link><pubDate>Fri, 18 Feb 2022 00:00:00 +0000</pubDate><author><name>Baikov</name></author><guid>https://baikov.dev/important-peps/</guid><description>Список вопросов к Python собеседованию
PEP 8 – Style Guide for Python Code рус PEP 20 – The Zen of Python PEP 257 – Docstring Conventions PEP 343 – The “with” Statement PEP 404 – Python 2.8 Un-release Schedule PEP 435 – Adding an Enum type to the Python standard library PEP 457 – Notation For Positional-Only Parameters PEP 484 – Type Hints PEP 557 – Data Classes PEP 572 – Assignment Expressions PEP 3107 – Function Annotations PEP 3156 – Asynchronous IO Support Rebooted: the “asyncio” Module Источники123</description></item><item><title>Контекстные менеджеры в Python</title><link>https://baikov.dev/context-managers-python/</link><pubDate>Fri, 18 Feb 2022 00:00:00 +0000</pubDate><author><name>Baikov</name></author><guid>https://baikov.dev/context-managers-python/</guid><description><![CDATA[Список вопросов к Python собеседованию
Схема для понимания итераторов и генераторов" Схема для понимания итераторов и генераторов  --    -- Краткое резюме по контекстным менеджерам  Контекстные менеджеры нужны там, где есть &ldquo;настройка&rdquo; -&gt; блок кода -&gt; &ldquo;уборка&rdquo;, при этом &ldquo;настройку&rdquo; и &ldquo;уборку&rdquo; нужно выполнить в паре. У контекстного менеджера обязательно присутствуют атрибуты __enter__ и __exit__. Их добавление обеспечивает реализацию протокола контекстного менеджера. Не обязательно писать целый класс для нового контекстного менеджера, достаточно обернуть генератор в декоратор contextmanager из модуля contextlib.]]></description></item><item><title>15 принципов разработки ПО - аббревиатуры и расшифровка</title><link>https://baikov.dev/coding-principles/</link><pubDate>Tue, 14 Dec 2021 00:00:00 +0000</pubDate><author><name>Baikov</name></author><guid>https://baikov.dev/coding-principles/</guid><description>YAGNI«You Ain’t Gonna Need It» — «Вам это не понадобится»
Процесс и принцип проектирования ПО, при котором в качестве основной цели и/или ценности декларируется отказ от избыточной функциональности, — то есть отказ добавления функциональности, в которой нет непосредственной надобности.
DRYDon’t repeat yourself - не повторяйте себя
Это принцип разработки программного обеспечения, нацеленный на снижение повторения информации различного рода, особенно в системах со множеством слоёв абстрагирования. Принцип DRY формулируется как: «Каждая часть знания должна иметь единственное, непротиворечивое и авторитетное представление в рамках системы».</description></item><item><title>Вопросы с ответами к собеседованию по Python</title><link>https://baikov.dev/python-interview-questions/</link><pubDate>Sat, 11 Dec 2021 00:00:00 +0000</pubDate><author><name>Baikov</name></author><guid>https://baikov.dev/python-interview-questions/</guid><description>Общие вопросы Принципы программирования? Отличия процедурной и объектно-ориентированной парадигмы программирования? Основные принципы ООП? Что такое множественное наследование? Что такое @property? Что такое инженерия и процесс разработки в целом? Основные методологии разработки (жизненный цикл продукта)? Методология Agile. Различия Kanban и Scrum подходов. Методы HTTP-запросов и какая между ними разница? Как выглядят HTTP-request/response? Что такое авторизация и как она работает? Что такое cookies? Что такое веб уязвимость? Какие знаете классические базы данных? Как читать спецификацию в конкретном языке (например, PEP8 в Python)?</description></item><item><title>Область видимости переменных в Python</title><link>https://baikov.dev/python-scope-of-variables/</link><pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate><author><name>Baikov</name></author><guid>https://baikov.dev/python-scope-of-variables/</guid><description>Список вопросов к Python собеседованию
Область видимости (scope) определяет контекст переменной, в рамках которого ее можно использовать. В Python существует три области видимости:
локальная глобальная нелокальная Основные моменты:
Изнутри функции видны переменные, которые были определены и внутри нее и снаружи. Переменные, определенные внутри функции – локальные, снаружи – глобальные. Снаружи функций не видны никакие переменные, определенные внутри них. Изнутри функции можно изменять значение переменных, которые определены в глобальной области видимости с помощью спецификатора global.</description></item></channel></rss>