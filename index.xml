<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>baikov.dev</title><link>https://baikov.dev/</link><description>baikov.dev</description><generator>Hugo -- gohugo.io</generator><language>ru</language><managingEditor>alex@baikov.dev (Baikov)</managingEditor><webMaster>alex@baikov.dev (Baikov)</webMaster><lastBuildDate>Wed, 08 Dec 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://baikov.dev/index.xml" rel="self" type="application/rss+xml"/><item><title>Установка и настройка Neovim</title><link>https://baikov.dev/neovim-settings/</link><pubDate>Mon, 21 Dec 2020 00:00:00 +0000</pubDate><author><name>Baikov</name></author><guid>https://baikov.dev/neovim-settings/</guid><description><![CDATA[Установка Neovim Сверхрасширяемый текстовый редактор на основе Vim1
 1  brew install neovim   Установка vim-plugМинималистичный менеджер плагинов Vim.2
1  curl -fLo ~/.config/nvim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim   Файл конфигурации Neovim для MacСоздаем файл ~/.comfig/nvim/init.vim со следующим содержимым:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274  &#34; Baseset mouse=aset encoding=utf-8set numberset noswapfileset scrolloff=7set tabstop=4set softtabstop=4set shiftwidth=4set expandtabset autoindentset fileformat=unixset t_Co=256set guifont=Monaco:h18set colorcolumn=120&#34; load filetype-specific indent filesfiletype indent on&#34; Pluginscall plug#begin(&#39;~/.]]></description></item><item><title>Написание unit-тестов в Django и DRF</title><link>https://baikov.dev/django-drf-tests/</link><pubDate>Sun, 11 Sep 2022 11:00:00 +0000</pubDate><author><name>Baikov</name></author><guid>https://baikov.dev/django-drf-tests/</guid><description>SimpleTestCase и APISimpleTestCaseSimpleTestCase - подкласс unittest.TestCase, с расширенной функциональностью. Есть Client. Нет работы с БД.
APISimpleTestCase - подкласс SimpleTestCase для тестирования DRF. Дополнительно использует APIClient.
TestCase и APITestCaseTestCase - наиболее часто используемый класс для написания тестов в Django. Он наследуется от TransactionTestCase (и, соответственно, от SimpleTestCase).
Обертывает тесты в два вложенных блока atomic(): один для всего класса и один для каждого теста. Проверяет отложенные ограничения базы данных в конце каждого теста.</description></item><item><title>Настройка pre-commit hooks для Django проекта</title><link>https://baikov.dev/precommit-config-djando/</link><pubDate>Tue, 16 Aug 2022 08:11:11 +0000</pubDate><author><name>Baikov</name></author><guid>https://baikov.dev/precommit-config-djando/</guid><description>Git имеет в своем составе инструмент, который умеет запускать кастомные скрипты при наступлении какого-либо события (к примеру commit, push и т.п.).
.pre-commit является надстройкой над стандартным git pre-commit hook, которая позволяет запускать скрипты описанные в .pre-commit-config.yaml перед созданием коммита. Это, например, позволяет поддерживать код проекта на Django в соответствии с принятыми стандартами PEP при минимальном личном участии.
Установка pre-commitСтандартные шаги расписывать не буду (перейти в папку проекта, активировать виртуальное окружение).</description></item><item><title>Ошибка установки устаревших версий Python - BUILD FAILED (OS X 12.x using python-build 20180424)</title><link>https://baikov.dev/build-failed-osx-using-python-build-20180424/</link><pubDate>Tue, 05 Jul 2022 12:31:52 +0000</pubDate><author><name>Baikov</name></author><guid>https://baikov.dev/build-failed-osx-using-python-build-20180424/</guid><description>UPD Наиболее логичный вариант - использовать последнюю версию нужной ветки. Например, вместо python 3.7.3 поставить python 3.7.13. Причина ошибкиПокопавшись в том, что приводит к ошибке выяснилось, что старым версиям python не нравится компилятор С/С++, который идет в комплекте с CommandLine Tools. Из чего следует, что нужно поставить другую версию этого компилятора и подсунуть ее при установке. В новых версиях MacOS (видимо, свежее Catalina) Apple перестал поддерживать старые версии python из-за наличия обнаруженных в них уязвимостей.</description></item><item><title>Разница между PUT и POST запросами</title><link>https://baikov.dev/difference-between-put-and-post/</link><pubDate>Sat, 25 Jun 2022 00:00:00 +0000</pubDate><author><name>Baikov</name></author><guid>https://baikov.dev/difference-between-put-and-post/</guid><description>Список вопросов к Python собеседованию
Разница между PUT и POST
Разница между PUT и POST - stack
Методы HTTP запроса</description></item><item><title>Тестовое задание на вакансию Код-ревьюера в Яндекс.Практикум</title><link>https://baikov.dev/yandex-praktikum-reviewer-test-task/</link><pubDate>Sat, 04 Jun 2022 00:00:00 +0000</pubDate><author><name>Baikov</name></author><guid>https://baikov.dev/yandex-praktikum-reviewer-test-task/</guid><description>HR прислал на почту ссылку на Яндекс-форму с вопросами. На выполнение тестового задания дается 3 дня, но если времени мало - просят предупредить об этом заранее.
Подробнее о вакансии.
Вопрос №1: DjangoРасскажите, чем отличается select_related от prefetch_related.
Мой ответ select_related:
используется, когда мы собираемся получить один связанный объект (OneToOne, ForeignKey); делает SQL join в том же запросе и возвращает результат как часть таблицы. prefetch_related:
используется, когда мы собираемся получить набор объектов (ManyToMany, или обратная связь ForeignKey); выполняет дополнительный запрос к базе с набором id (SELECT &amp;lt;something&amp;gt; WHERE pk IN (.</description></item><item><title>Декораторы в Python: определение, особенности, примеры декораторов</title><link>https://baikov.dev/decorators-in-python/</link><pubDate>Tue, 05 Apr 2022 00:00:00 +0000</pubDate><author><name>Baikov</name></author><guid>https://baikov.dev/decorators-in-python/</guid><description>Список вопросов к Python собеседованию
Схема для понимания итераторов и генераторов" Схема для понимания итераторов и генераторов -- -- Паттерн проектирования &amp;ldquo;Декоратор&amp;rdquo; Декоратор (Decorator) — структурный шаблон проектирования, предназначенный для динамического подключения дополнительного поведения к объекту. Шаблон Декоратор предоставляет гибкую альтернативу практике создания подклассов с целью расширения функциональности.1
Декораторы в PythonДекоратор — это функция, которая позволяет обернуть другую функцию для расширения её функциональности без непосредственного изменения её кода.</description></item><item><title>Сопрограммы (corutines) в Python</title><link>https://baikov.dev/coroutines-in-python/</link><pubDate>Sat, 12 Mar 2022 00:00:00 +0000</pubDate><author><name>Baikov</name></author><guid>https://baikov.dev/coroutines-in-python/</guid><description>Список вопросов к Python собеседованию
Сопрограммы – это особый тип функций, которые сознательно передают управление вызывающему объекту, но они не заканчивают свой контекст в процессе, поддерживая его в состоянии ожидания.
Сопрограмма сама решает, когда перенаправить flow в другое место (например, в другую сопрограмму). И это позволяет строить красивые разветвленные деревья обработки потоков данных, реализовывать MapReduce, возможно прокидывать текущие байты через сокет на другую ноду. Более того, сопрограммы могут быть фактически реализованы абсолютно на любом языке.</description></item><item><title>Итераторы, генераторы и итерируемые объекты в Python</title><link>https://baikov.dev/iterators-and-generators-python/</link><pubDate>Wed, 02 Mar 2022 00:00:00 +0000</pubDate><author><name>Baikov</name></author><guid>https://baikov.dev/iterators-and-generators-python/</guid><description>Список вопросов к Python собеседованию
Схема для понимания итераторов и генераторов" Схема для понимания итераторов и генераторов ИтераторИтератор — это:
интерфейс, предоставляющий доступ к элементам коллекции (массива или контейнера). Коллекции не должны обязательно существовать в памяти и быть конечными. объект, в котором есть два метода: __iter__ (возвращает сам объект итератора) и __next__ (возвращает следующее значение из итератора) Особенности итератора:
при запросе каждого следующего значения, итератор знает, как его вычислить хранит информацию о текущем состоянии итерируемого объекта, над которым он работает почти всегда возвращает себя из метода __iter__, так как выступает итераторами для самого себя (есть исключения) итератор не должен иметь и часто не имеет определённой длины.</description></item><item><title>Важные разделы PEP</title><link>https://baikov.dev/important-peps/</link><pubDate>Fri, 18 Feb 2022 00:00:00 +0000</pubDate><author><name>Baikov</name></author><guid>https://baikov.dev/important-peps/</guid><description>Список вопросов к Python собеседованию
PEP 8 – Style Guide for Python Code рус PEP 20 – The Zen of Python PEP 257 – Docstring Conventions PEP 343 – The “with” Statement PEP 404 – Python 2.8 Un-release Schedule PEP 435 – Adding an Enum type to the Python standard library PEP 457 – Notation For Positional-Only Parameters PEP 484 – Type Hints PEP 557 – Data Classes PEP 572 – Assignment Expressions PEP 3107 – Function Annotations PEP 3156 – Asynchronous IO Support Rebooted: the “asyncio” Module Источники123</description></item></channel></rss>