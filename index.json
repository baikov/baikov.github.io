[{"categories":["notes"],"content":"Устанавливаем и настраиваем редактор Neovim для комфортной работы с Python. Все необходимые плагины: от автодополнения до подсветки ошибок.","date":"21.12.2020","objectID":"/neovim-settings/","series":null,"tags":["vim","neovim"],"title":"Установка и настройка Neovim","uri":"/neovim-settings/"},{"categories":["notes"],"content":"Установка Neovim Сверхрасширяемый текстовый редактор на основе Vim1 brew install neovim ","date":"21.12.2020","objectID":"/neovim-settings/:1:0","series":null,"tags":["vim","neovim"],"title":"Установка и настройка Neovim","uri":"/neovim-settings/#установка-neovim"},{"categories":["notes"],"content":"Установка vim-plug Минималистичный менеджер плагинов Vim.2 curl -fLo ~/.config/nvim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim ","date":"21.12.2020","objectID":"/neovim-settings/:2:0","series":null,"tags":["vim","neovim"],"title":"Установка и настройка Neovim","uri":"/neovim-settings/#установка-vim-plug"},{"categories":["notes"],"content":"Файл конфигурации Neovim для Mac Создаем файл ~/.comfig/nvim/init.vim со следующим содержимым: \" Baseset mouse=aset encoding=utf-8set numberset noswapfileset scrolloff=7set tabstop=4set softtabstop=4set shiftwidth=4set expandtabset autoindentset fileformat=unixset t_Co=256set guifont=Monaco:h18set colorcolumn=120\" load filetype-specific indent filesfiletype indent on\" Pluginscall plug#begin('~/.config/nvim/plugged')Plug 'neovim/nvim-lspconfig'Plug 'hrsh7th/nvim-cmp'Plug 'hrsh7th/cmp-nvim-lsp'Plug 'saadparwaiz1/cmp_luasnip'Plug 'L3MON4D3/LuaSnip'\" color schemas\"Plug 'morhetz/gruvbox' \" colorscheme gruvboxPlug 'mhartington/oceanic-next' \" colorscheme OceanicNext\"Plug 'kaicataldo/material.vim', { 'branch': 'main' }\"Plug 'ayu-theme/ayu-vim'\" For JS/JSXPlug 'yuezk/vim-js'Plug 'maxmellon/vim-jsx-pretty'Plug 'scrooloose/nerdtree'Plug 'tpope/vim-surround'Plug 'tpope/vim-fugitive'Plug 'tpope/vim-commentary'Plug 'mattn/emmet-vim'\"Plug 'davidhalter/jedi-vim'Plug 'klen/python-mode'\"Plug 'ambv/black'\"Plug 'nvie/vim-flake8'Plug 'mitsuhiko/vim-jinja'Plug 'git://git.wincent.com/command-t.git'\"Plugin 'flazz/vim-colorschemes'Plug 'alvan/vim-closetag'call plug#end()\"colorscheme gruvboxcolorscheme OceanicNext\"let g:material_terminal_italics = 1\" variants: default, palenight, ocean, lighter, darker, default-community,\" palenight-community, ocean-community, lighter-community,\" darker-community\"let g:material_theme_style = 'darker'\"colorscheme materialif (has('termguicolors')) set termguicolorsendif\" variants: mirage, dark, dark\"let ayucolor=\"mirage\"\"colorscheme ayulua \u003c\u003c EOF-- Set completeopt to have a better completion experiencevim.o.completeopt = 'menuone,noselect'-- luasnip setuplocal luasnip = require 'luasnip'-- nvim-cmp setuplocal cmp = require 'cmp'cmp.setup { completion = { autocomplete = false }, snippet = { expand = function(args) require('luasnip').lsp_expand(args.body) end, }, mapping = { ['\u003cC-p\u003e'] = cmp.mapping.select_prev_item(), ['\u003cC-n\u003e'] = cmp.mapping.select_next_item(), ['\u003cC-d\u003e'] = cmp.mapping.scroll_docs(-4), ['\u003cC-f\u003e'] = cmp.mapping.scroll_docs(4), ['\u003cC-Space\u003e'] = cmp.mapping.complete(), ['\u003cC-e\u003e'] = cmp.mapping.close(), ['\u003cCR\u003e'] = cmp.mapping.confirm { behavior = cmp.ConfirmBehavior.Replace, select = true, }, ['\u003cTab\u003e'] = function(fallback) if vim.fn.pumvisible() == 1 then vim.fn.feedkeys(vim.api.nvim_replace_termcodes('\u003cC-n\u003e', true, true, true), 'n') elseif luasnip.expand_or_jumpable() then vim.fn.feedkeys(vim.api.nvim_replace_termcodes('\u003cPlug\u003eluasnip-expand-or-jump', true, true, true), '') else fallback() end end, ['\u003cS-Tab\u003e'] = function(fallback) if vim.fn.pumvisible() == 1 then vim.fn.feedkeys(vim.api.nvim_replace_termcodes('\u003cC-p\u003e', true, true, true), 'n') elseif luasnip.jumpable(-1) then vim.fn.feedkeys(vim.api.nvim_replace_termcodes('\u003cPlug\u003eluasnip-jump-prev', true, true, true), '') else fallback() end end, }, sources = { { name = 'nvim_lsp' }, { name = 'luasnip' }, },}EOFlua \u003c\u003c EOFlocal nvim_lsp = require('lspconfig')-- Use an on_attach function to only map the following keys-- after the language server attaches to the current bufferlocal on_attach = function(client, bufnr) local function buf_set_keymap(...) vim.api.nvim_buf_set_keymap(bufnr, ...) end local function buf_set_option(...) vim.api.nvim_buf_set_option(bufnr, ...) end -- Enable completion triggered by \u003cc-x\u003e\u003cc-o\u003e buf_set_option('omnifunc', 'v:lua.vim.lsp.omnifunc') -- Mappings. local opts = { noremap=true, silent=true } -- See `:help vim.lsp.*` for documentation on any of the below functions buf_set_keymap('n', 'gD', '\u003ccmd\u003elua vim.lsp.buf.declaration()\u003cCR\u003e', opts) buf_set_keymap('n', 'gd', '\u003ccmd\u003elua vim.lsp.buf.definition()\u003cCR\u003e', opts) buf_set_keymap('n', 'K', '\u003ccmd\u003elua vim.lsp.buf.hover()\u003cCR\u003e', opts) buf_set_keymap('n', 'gi', '\u003ccmd\u003elua vim.lsp.buf.implementation()\u003cCR\u003e', opts) buf_set_keymap('n', '\u003cC-k\u003e', '\u003ccmd\u003elua vim.lsp.buf.signature_help()\u003cCR\u003e', opts) buf_set_keymap('n', '\u003cspace\u003ewa', '\u003ccmd\u003elua vim.lsp.buf.add_workspace_folder()\u003cCR\u003e', opts) buf_set_keymap('n', '\u003c","date":"21.12.2020","objectID":"/neovim-settings/:3:0","series":null,"tags":["vim","neovim"],"title":"Установка и настройка Neovim","uri":"/neovim-settings/#файл-конфигурации-neovim-для-mac"},{"categories":["notes"],"content":"Установка плагинов Заходим в nvim и запускаем установку плагинов :PlugInstall И еще один полезный gist Neovim ↩︎ vim-plug ↩︎ alexey-goloburdin/nvim-config ↩︎ БОЖЕСТВЕННЫЙ nvim как IDE для Python, Rust и всех-всех-всех — встречаем LSP! ↩︎ ","date":"21.12.2020","objectID":"/neovim-settings/:4:0","series":null,"tags":["vim","neovim"],"title":"Установка и настройка Neovim","uri":"/neovim-settings/#установка-плагинов"},{"categories":null,"content":"Описание","date":"08.12.2021","objectID":"/skills/","series":null,"tags":null,"title":"Навыки","uri":"/skills/"},{"categories":null,"content":"Актуальные навыки Языки: Python, JavaScript Backend: Django, Flask, Celery, Flower API: Django REST Framework, JSON APIs Тестирование: Unit тестирование Frontend: HTML (flex, grid), CSS3 (BEM), SASS (SCSS), Bootstrap (2, 3, 4), Vue.js, Webpack, Gulp, npm, DevTools, SSG (Hugo) БД: PostgreSQL, Redis, SQLite Cloud platform: Reg.ru, AWS, Yandex.Cloud Web servers: Nginx, Traefik Web security: HTTPS, SSL/TLS, CORS Мониторинг: Prometheus, Grafana Другое: Docker, Docker Compose, Git, GitHub, git-flow, github-flow, Follow the \"Twelve factor app\", Sphinx CI/CD: GitHub Actions Tools: VSCode, iTerm2 + zsh + oh-my-zsh, Vim Neovim, Homebrew OS: MacOS, Linux (Debian, Ubuntu) Навыки в смежных сферах SEO: Link building, аудит, техническая оптимизация Web analytics: GTM, Google Analytics, Yandex Metrica, PowerBI Web security: pentesting, XSS, CSRF, SQL-Injection OS: Kali Linux Планирую изучить Языки: Go Backend: aiohttp, sqlalchemy, RabbitMQ, RPC, asyncio API: FastAPI, GraphQL, gRPC Тестирование: Integration Тестирование, Functional Тестирование, Selenium Мониторинг: Datadog Frontend: VueX, SSR (Nuxt.js), Pre-rendering, Bootstrap 5 БД: MongoDB CI/CD: Circle CI, Travis CI, Jenkins Другое: Elasticsearch, Kubernetes, Ansible, Agile Development \u0026 Scrum С чем работал раньше Языки: PHP, Java, C++, Perl Frontend: jQuery, LESS, SSG (Jekyll) Design: Axure, Photoshop БД: MySQL CMS: 1C-Bitrix, Wordpress, OpenCart, Joomla, InstantCMS Tools: MS Visual Studio, SublimeText, Atom, bash OS: Linux (Mint, Ubuntu), Windows (98, 2000, XP, 7, 8, 10) Hosting and cloud platforms: Heroku, DigitalOcean, HostSailor, nic.ru Web servers: Apache ","date":"08.12.2021","objectID":"/skills/:0:0","series":null,"tags":null,"title":"Навыки","uri":"/skills/#"},{"categories":["python-interview"],"content":"Декораторы позволяют менять поведение функции не изменяя ее кода. Это становится возможным благодаря тому, что функции в Python могут принимать и возвращать функции. Декоратор в Python - это реализация структурного шаблона проектирования «Декоратор».","date":"05.04.2022","objectID":"/decorators-in-python/","series":null,"tags":["python"],"title":"Декораторы в Python: определение, особенности, примеры декораторов","uri":"/decorators-in-python/"},{"categories":["python-interview"],"content":"Список вопросов к Python собеседованию Схема для понимания итераторов и генераторов\" Схема для понимания итераторов и генераторов -- -- ","date":"05.04.2022","objectID":"/decorators-in-python/:0:0","series":null,"tags":["python"],"title":"Декораторы в Python: определение, особенности, примеры декораторов","uri":"/decorators-in-python/#"},{"categories":["python-interview"],"content":"Паттерн проектирования “Декоратор” Декоратор (Decorator) — структурный шаблон проектирования, предназначенный для динамического подключения дополнительного поведения к объекту. Шаблон Декоратор предоставляет гибкую альтернативу практике создания подклассов с целью расширения функциональности.1 ","date":"05.04.2022","objectID":"/decorators-in-python/:1:0","series":null,"tags":["python"],"title":"Декораторы в Python: определение, особенности, примеры декораторов","uri":"/decorators-in-python/#паттерн-проектирования-декоратор"},{"categories":["python-interview"],"content":"Декораторы в Python Декоратор — это функция, которая позволяет обернуть другую функцию для расширения её функциональности без непосредственного изменения её кода. Чтобы лучше пониманять работу декораторов нужно помнить тот факт, что: в Python всё является объектами; Функции — это объекты первого класса; следовательно, язык поддерживает функции высших порядков. Объектами первого класса в контексте конкретного языка программирования называются элементы, с которыми можно делать всё то же, что и с любым другим объектом: передавать как параметр, возвращать из функции и присваивать переменной. Функции высших порядков — это такие функции, которые могут принимать в качестве аргументов и возвращать другие функции. Это означает, что мы можем: сохранять функции в переменные; передавать их в качестве аргументов; возвращать из других функций; определить одну функцию внутри другой (вложенные функции). По сути, это и позволяет реализовать декоратор: def decorator(func): print(\"Inside decorator\") def wrapper(): # вложенная функция (обертка) print(\"Inside wrapper - Befor func exec\") res = func() print(\"Inside wrapper - After func exec\") return res print(\"Inside decorator 2\") return wrapper # возвращаем функцию (не вызывая) def outer_func(): print(\"Inside outer_func\") # Передаем функцию как параметр, результат присваиваем переменной wrapped_func = decorator(outer_func) # вызываем обернутую функцию первый раз wrapped_func() # вызываем обернутую функцию второй раз wrapped_func() Результат запуска: # первый вызов функции wrapped_func() Inside decorator - Befor wrapper def Inside decorator - After wrapper def Inside wrapper - Befor func exec Inside outer_func Inside wrapper - After func exec # Второй вызов функции wrapped_func() Inside wrapper - Befor func exec Inside outer_func Inside wrapper - After func exec Выражение @decorator - это синтаксический сахар, короткая запись для outer_func = decorator(outer_func). def decorator(func): def wrapper(): func() return wrapper @decorator def outer_func(): pass outer_func() Еще немного о декораторах: декораторы можно вкладывать друг в друга (при этом порядок декорирования важен); декораторы можно использовать с другими методами (например, «магическими»); декораторы могут принимать в качестве аргументов не только функции. Условные недостатки декораторов: несколько замедляют вызов функции если функция декорирована — это не отменить (существуют трюки, позволяющие создать декоратор, который можно отсоединить от функции, но это плохая практика) оборачивают функции, что может затруднить отладку (лечится использованием functools.wraps). Области применения декораторов: когда нужно избежать повторений при использовании похожих методов; могут быть использованы для расширения возможностей функций из сторонних библиотек (код которых мы не можем изменять); в Django декораторы используются для управления кешированием, контроля за правами доступа и определения обработчиков адресов; в Twisted — для создания поддельных асинхронных inline-вызовов. ","date":"05.04.2022","objectID":"/decorators-in-python/:2:0","series":null,"tags":["python"],"title":"Декораторы в Python: определение, особенности, примеры декораторов","uri":"/decorators-in-python/#декораторы-в-python"},{"categories":["python-interview"],"content":"Функция с аргументами Допустим, теперь декорируемая функция outer_func() может принимать произвольное количество аргументов. Чтобы наш декоратор работал корректно необходимо использовать *args и **kwargs (распаковка аргументов) во внутренней функции wrapper(), а так же передавать произвольное число позиционных и ключевых аргументов функции func(), которую декоратор получает в качестве аргумента: def decorator(func): def wrapper(*args, **kwargs): res = func(*args, **kwargs) return res return wrapper @decorator def outer_func(a, b, name: str): pass outer_func(7, 8, name=\"Tom\") Теперь декоратор @decorator будет работать как для функций, которые вообще не принимают аргументы, так и для функций которые принимают произвольное количество аргументов. ","date":"05.04.2022","objectID":"/decorators-in-python/:3:0","series":null,"tags":["python"],"title":"Декораторы в Python: определение, особенности, примеры декораторов","uri":"/decorators-in-python/#функция-с-аргументами"},{"categories":["python-interview"],"content":"functools.wraps Из-за того, что декоратор возвращает не первоначальную функцию, а функцию обертку wrapper - теряется строка документации (docstring) основной функции, доступ к которой можно получить с помощью метода __doc__. functools.wraps — декоратор Функция wraps из модуля functools копирует всю информацию об оборачиваемой функции (имя, модуля, docstrings и т.п.) в функцию-обёртку. from functools import wraps def decorator(func): '''Декоратор''' @wraps(func) def wrapper(): '''Функция wrapper''' func() return wrapper @decorator def outer_func(): '''Оборачиваемая функция''' print('функция wrapped') print(outer_func.__name__) print(outer_func.__doc__) ","date":"05.04.2022","objectID":"/decorators-in-python/:4:0","series":null,"tags":["python"],"title":"Декораторы в Python: определение, особенности, примеры декораторов","uri":"/decorators-in-python/#functoolswraps"},{"categories":["python-interview"],"content":"Декораторы с аргументами Чтобы передать параметр в сам декоратор нужно добавить еще один слой абстракции, то есть — еще одну функцию-обертку. from functools import wraps def benchmark(type: str = \"sec\", iters: int = 1): # новый уровень абстракции import time def decorator(func): # сам декоратор @wraps(func) def wrapper(*args, **kwargs): # функция обертка start_time = time.time() for _ in range(iters): result = func(*args, **kwargs) end_time = time.time() exec_time = end_time - start_time if type == \"ms\": print(f\"Exec time of {func.__name__}x{iters}is {exec_time*1000}ms\") else: print(f\"Exec time of {func.__name__}x{iters}is {exec_time}s\") return result return wrapper return decorator @benchmark(type=\"ms\", iters=100) def outer_func(a, b, name: str): \"\"\"Outer_func docstring\"\"\" print('функция wrapped') Функция benchmark() не является декоратором. Это обычная функция, которая принимает аргументы type и iters, а затем возвращает декоратор. В свою очередь, он декорирует функцию outer_func(). Поэтому мы использовали не выражение @benchmark, а @benchmark(type=\"ms\", iters=100) — круглые скобки означают, что функция вызывается, после чего возвращает сам декоратор. ","date":"05.04.2022","objectID":"/decorators-in-python/:5:0","series":null,"tags":["python"],"title":"Декораторы в Python: определение, особенности, примеры декораторов","uri":"/decorators-in-python/#декораторы-с-аргументами"},{"categories":["python-interview"],"content":"Объекты-декораторы Декоратором могут быть не только функции, но и любые вызываемые объекты. Экземпляры класса с методом __call__ тоже можно вызывать, поэтому классы можно использовать в качестве декораторов. Для функций с параметрами *args и **kwargs нужно передать в метод __call__. class Decorator: def __init__(self, func): print('Класс Decorator метод __init__') self.func = func def __call__(self, *args, **kwargs): print('перед вызовом класса...', self.func.__name__) self.func(*args, **kwargs) print('после вызова класса') @Decorator def outer_func(a, b, name: str): print('функция wrapped') outer_func(7, 8, \"Bob\") Для передачи аргументов в класс-декоратор эти аргументы получает инициализатор __init__. Метод __call__ будет получать декорируемую функцию и возвращать функцию-обертку, которая, по сути, будет выполнять эту декорируемую функцию. Функция-обертка wrapper получает *args и **kwargs: from functools import wraps class Decorator: def __init__(self, output: str = \"log\"): print('Класс Decorator метод __init__') self.output = output def __call__(self, func): print('Класс Decorator метод __call__') @wraps(func) def wrapper(*args, **kwargs): print('перед вызовом func...', func.__name__) result = func(*args, **kwargs) if self.output == \"file\": print(\"Save to file\") else: print(\"Console output\") print('после вызова func') return result return wrapper @Decorator(output=\"file\") def outer_func(a, b, name: str): \"\"\"Outer_func docstring\"\"\" print('функция wrapped', a, b, name) outer_func(7, 8, \"Bob\") ","date":"05.04.2022","objectID":"/decorators-in-python/:6:0","series":null,"tags":["python"],"title":"Декораторы в Python: определение, особенности, примеры декораторов","uri":"/decorators-in-python/#объекты-декораторы"},{"categories":["python-interview"],"content":"Декоратор метода Функции и методы в Python — это практически одно и то же. Отличие в том, что методы всегда принимают первым параметром self (ссылку на объект). Следовательно, мы легко можем написать декоратор для метода: def method_decorator(method): def wrapper(self): result = method(self) return result.upper() if self.power \u003e 150 else result return wrapper class Car: def __init__(self, power): self.power = power @method_decorator def wroom_wroom(self) return \"wroom-wroom...\" lada = Car(87) bmw = Car(300) print(lada.wroom_wroom()) # wroom-wroom... print(bmw.wroom_wroom()) # WROOM-WROOM... ","date":"05.04.2022","objectID":"/decorators-in-python/:7:0","series":null,"tags":["python"],"title":"Декораторы в Python: определение, особенности, примеры декораторов","uri":"/decorators-in-python/#декоратор-метода"},{"categories":["python-interview"],"content":"Декоратор класса на примере Singleton Декоратор можно использовать для декорирования класса. Отличие лишь в том, что декоратор получает класс, а не функцию. Singleton — это класс с одним экземпляром. Его можно сохранить как атрибут функции-обертки и вернуть при запросе. def singleton(cls): '''Класс Singleton (один экземпляр)''' def wrapper(*args, **kwargs): if not wrapper.instance: wrapper.instance = cls(*args, **kwargs) return wrapper.instance wrapper.instance = None return wrapper @singleton class SomeClass: pass ","date":"05.04.2022","objectID":"/decorators-in-python/:8:0","series":null,"tags":["python"],"title":"Декораторы в Python: определение, особенности, примеры декораторов","uri":"/decorators-in-python/#декоратор-класса-на-примере-singleton"},{"categories":["python-interview"],"content":"Встроенные декораторы @classmethod @staticmethod @property Подробнее в статье ООП в Python. @contextlib.contextmanager @functools.lru_cache @abc.abstractmethod Подробнее тут.2 ","date":"05.04.2022","objectID":"/decorators-in-python/:9:0","series":null,"tags":["python"],"title":"Декораторы в Python: определение, особенности, примеры декораторов","uri":"/decorators-in-python/#встроенные-декораторы"},{"categories":["python-interview"],"content":"Примеры декораторов (код) ","date":"05.04.2022","objectID":"/decorators-in-python/:10:0","series":null,"tags":["python"],"title":"Декораторы в Python: определение, особенности, примеры декораторов","uri":"/decorators-in-python/#примеры-декораторов-код"},{"categories":["python-interview"],"content":"Конвертер import functools def convert(func=None, convert_to=None): \"\"\"Этот код конвертирует единицы измерения из одного типа в другой.\"\"\" if func is None: return functools.partial(convert, convert_to=convert_to) @functools.wraps(func) def wrapper(*args, **kwargs): print(f\"Conversion unit: {convert_to}\") val = func(*args, **kwargs) # Добавим правила для преобразования if convert_to is None: return val elif convert_to == \"km\": return val / 1000 elif convert_to == \"mile\": return val * 0.000621371 elif convert_to == \"cm\": return val * 100 elif convert_to == \"mm\": return val * 1000 else: raise ValueError(\"Conversion unit is not supported.\") # этот тип единиц не поддерживается return wrapper ","date":"05.04.2022","objectID":"/decorators-in-python/:10:1","series":null,"tags":["python"],"title":"Декораторы в Python: определение, особенности, примеры декораторов","uri":"/decorators-in-python/#конвертер"},{"categories":["python-interview"],"content":"Таймер import time def exec_time(type: str = \"sec\", iters: int = 1): def exec_time_decorator(func): @wraps(func) def wrapper(*args, **kwargs): \"\"\"Docstring wrapper\"\"\" start_time = time.time() for _ in range(iters): result = func(*args, **kwargs) end_time = time.time() if type == \"ms\": print(f\"Execution time of {func.__name__}x{iters}is {(end_time - start_time)*1000}ms\") else: print(f\"Execution time of {func.__name__}x{iters}is {end_time - start_time}s\") return result return wrapper return exec_time_decorator ","date":"05.04.2022","objectID":"/decorators-in-python/:10:2","series":null,"tags":["python"],"title":"Декораторы в Python: определение, особенности, примеры декораторов","uri":"/decorators-in-python/#таймер"},{"categories":["python-interview"],"content":"Счетчик вызовов def counter(func): count = 0 @wraps(func) def wrapper(*args, **kwargs): \"\"\"Docstring wrapper\"\"\" nonlocal count count += 1 res = func(*args, **kwargs) print(f\"{func.__name__}была вызвана: {count}x\") return res return wrapper Источники3456 Wikipedia - Шаблон проектирования Декоратор ↩︎ Awesome Python Decorator ↩︎ Декораторы в Python: понять и полюбить ↩︎ Понимаем декораторы в Python’e, шаг за шагом. Шаг 2 ↩︎ Руководство по декораторам Python ↩︎ Разбираемся с декораторами в Python ↩︎ ","date":"05.04.2022","objectID":"/decorators-in-python/:10:3","series":null,"tags":["python"],"title":"Декораторы в Python: определение, особенности, примеры декораторов","uri":"/decorators-in-python/#счетчик-вызовов"},{"categories":["python-interview"],"content":"Сопрограммы (corutines) в Python","date":"12.03.2022","objectID":"/coroutines-in-python/","series":null,"tags":["python"],"title":"Сопрограммы (corutines) в Python","uri":"/coroutines-in-python/"},{"categories":["python-interview"],"content":"Список вопросов к Python собеседованию Сопрограммы – это особый тип функций, которые сознательно передают управление вызывающему объекту, но они не заканчивают свой контекст в процессе, поддерживая его в состоянии ожидания. Сопрограмма сама решает, когда перенаправить flow в другое место (например, в другую сопрограмму). И это позволяет строить красивые разветвленные деревья обработки потоков данных, реализовывать MapReduce, возможно прокидывать текущие байты через сокет на другую ноду. Более того, сопрограммы могут быть фактически реализованы абсолютно на любом языке. Сопрограммы в Python Корутины в Python Хабр - Сопрограммы в Python What is a Coroutine Anyway? (перевод) Использование send(), throw() и close() в генераторах Python О стандарте можно почитать тут - PEP342 ","date":"12.03.2022","objectID":"/coroutines-in-python/:0:0","series":null,"tags":["python"],"title":"Сопрограммы (corutines) в Python","uri":"/coroutines-in-python/#"},{"categories":["python-interview"],"content":"Разбираемся в различиях между понятиями итератора (iterator), итерируемого объекта (iterable) и генератора. Реализация итераторов на языке Python и преимущества их использования.","date":"02.03.2022","objectID":"/iterators-and-generators-python/","series":null,"tags":["python"],"title":"Итераторы, генераторы и итерируемые объекты в Python","uri":"/iterators-and-generators-python/"},{"categories":["python-interview"],"content":"Список вопросов к Python собеседованию Схема для понимания итераторов и генераторов\" Схема для понимания итераторов и генераторов ","date":"02.03.2022","objectID":"/iterators-and-generators-python/:0:0","series":null,"tags":["python"],"title":"Итераторы, генераторы и итерируемые объекты в Python","uri":"/iterators-and-generators-python/#"},{"categories":["python-interview"],"content":"Итератор Итератор — это: интерфейс, предоставляющий доступ к элементам коллекции (массива или контейнера). Коллекции не должны обязательно существовать в памяти и быть конечными. объект, в котором есть два метода: __iter__ (возвращает сам объект итератора) и __next__ (возвращает следующее значение из итератора) Особенности итератора: при запросе каждого следующего значения, итератор знает, как его вычислить хранит информацию о текущем состоянии итерируемого объекта, над которым он работает почти всегда возвращает себя из метода __iter__, так как выступает итераторами для самого себя (есть исключения) итератор не должен иметь и часто не имеет определённой длины. Поэтому зачастую не имеет имплементации __len__ чтобы подсчитать количество элементов в итераторе, приходится делать это вручную или использовать sum когда итератор завершает работу, интерпретатор Python ожидает возбуждения исключения StopIteration (в случаях работы с бесконечными множествами программист должен позаботиться о выходе из цикла самостоятельно)1 любой итератор является итерируемым объектом2 В Python за получение итератора отвечает функция iter(). Она отработает на любом объекте, у которого есть метод __iter__ или метод __getitem__ (позволяет получать элементы по индексу). iter() можно вызывать с двумя аргументами. Первый аргумент должен быть вызываемым объектом, а второй — неким ограничителем. Итерирование завершается, когда возбуждается исключение StopIteration (IndexError для метода __getitem__) или возвращается значение ограничителя. class SimpleList: def __init__(self, *items): self.items = items def __getitem__(self, i): return self.items[i] Метод __getitem__ вместо __iter__ -- Итераторы помогают создавать более чистый код, потому что позволяют работать с бесконечными последовательностями без необходимости перераспределения ресурсов для каждой возможной последовательности, что также экономит ресурсы.3 О реализации итератора в книге «банды четырех» Минимальный интерфейс класса Iterator состоит из операций First, Next, IsDone и CurrentItem. Этот интерфейс можно упростить, объединив операции Next, IsDone и CurrentItem в одну, которая будет переходить к следующему объекту и возвращать его. Если обход завершен, то эта операция вернет специальное значение (например, 0), обозначающее конец итерации. Именно так и реализовано в Python, но вместо специального значения, о конце итерации говорит исключение StopIteration. ","date":"02.03.2022","objectID":"/iterators-and-generators-python/:1:0","series":null,"tags":["python"],"title":"Итераторы, генераторы и итерируемые объекты в Python","uri":"/iterators-and-generators-python/#итератор"},{"categories":["python-interview"],"content":"Итерируемый объект это контейнер, который может служить источником данных для итератора это любой объект (не обязательно структура данных), способный возвращать итератор4 объект, в котором есть метод __iter__ итерируемые объекты могут представлять как конечный, так и бесконечный источник данных некоторые итерируемые объекты не являются итераторами, но используют другие объекты как итераторы. Итерируемый объект, но не итератор Например, объект list относится к итерируемым, но не является итератором. В нём реализован метод __iter__, но отсутствует метод __next__. Итераторы объектов list относятся к типу listiterator. У объектов list есть определённая длина, а у listiterator нету. Примеры итерируемых объектов: контейнеры (списки, множества, словари, кортежи и строки) открытые файлы открытые сокеты ","date":"02.03.2022","objectID":"/iterators-and-generators-python/:2:0","series":null,"tags":["python"],"title":"Итераторы, генераторы и итерируемые объекты в Python","uri":"/iterators-and-generators-python/#итерируемый-объект"},{"categories":["python-interview"],"content":"Генератор Генератор (функция-генератор) - это итератор, определение которого выглядит как определение функции. генераторы — функции (специальный класс функций), которые внутри используют выражение yield использование yield превращает обычную функцию в генератор5 yield служит разделителем блоков кода, которые исполняет генератор на каждом обращении к нему, то есть на каждой итерации (цикл вовсе не обязателен) в результате вызова функции-генератора или вычисления генераторного выражения, получаем объект-генератор типа types.GeneratorType генераторы не могут возвращать значения, вместо этого они возвращают итератор, который отдает элементы по одному Python автоматизирует запоминание контекста генератора (текущий поток управления, значение локальных переменных и т.д.) каждый вызов метода __next__ у объекта генератора возвращает следующее значение вызов метода __next__ может быть произведен напрямую при помощи функции next(), или косвенно (например через цикл for) метод __iter__ реализуется автоматически Преимущества генераторов: генераторы можно использовать везде, где требуются итераторы с помощью генераторов удобно реализовывать дискретные динамические системы более эффективно используют память и центральный процессор позволяют писать код с меньшим количеством промежуточных переменных и структур данных обычно для них требуется меньше строк кода их использование облегчает чтение и понимание кода def count_generator(): n = 0 while True: yield n n += 1 ","date":"02.03.2022","objectID":"/iterators-and-generators-python/:3:0","series":null,"tags":["python"],"title":"Итераторы, генераторы и итерируемые объекты в Python","uri":"/iterators-and-generators-python/#генератор"},{"categories":["python-interview"],"content":"Генераторные выражения Генераторное выражение - это еще один синтаксический сахар в Python, простейший способ создать объект с интерфейсом итератора, при этом не загружая всех элементов в память. результатами генераторных выражений являются объекты с типом generator генераторное выражение использует такой же синтаксис, как list comprehensions, но возвращает итератор, а не список выглядит точно так же, как list comprehensions, но используются круглые скобки оно полезно в том случае, когда надо работать с большим итерируемым объектом или бесконечным итератором genexpr = (x**2 for x in range(10000)) ","date":"02.03.2022","objectID":"/iterators-and-generators-python/:3:1","series":null,"tags":["python"],"title":"Итераторы, генераторы и итерируемые объекты в Python","uri":"/iterators-and-generators-python/#генераторные-выражения"},{"categories":["python-interview"],"content":"Выражение yield from Традиционным подходом для обхода ограниченно-вложенных структур являются вложенные циклы. Тот же подход можно использовать когда генераторная функция должна отдавать значения, порождаемые другим генератором. def chain(*iterables): for it in iterables: for i in it: yield i g = chain([1, 2, 3], {'A', 'B', 'C'}, '...') print(list(g)) # [1, 2, 3, 'A', 'B', 'C', '.', '.', '.'] Но вложенные циклы можно убрать, добавив конструкцию yield from: def chain(*iterables): for it in iterables: yield from it g = chain([1, 2, 3], {'A', 'B', 'C'}, '...') print(list(g)) # [1, 2, 3, 'A', 'B', 'C', '.', '.', '.'] По сути, выражение yield from \u003citerable\u003e - это просто сокращенная форма for item in iterable: yield item. Основная польза yield from в создании прямого канала между внутренним генератором и клиентом внешнего генератора. Но это уже больше тема про сопрограммы (coroutines). ","date":"02.03.2022","objectID":"/iterators-and-generators-python/:3:2","series":null,"tags":["python"],"title":"Итераторы, генераторы и итерируемые объекты в Python","uri":"/iterators-and-generators-python/#выражение-yield-from"},{"categories":["python-interview"],"content":"Расширенные методы генератора С версии Python 2.5 у объекта генератора появилось еще несколько методов: send() - позволяет отправить данные в генератор перед вызовом следующего блока кода throw() - можно извне заставить его бросить исключение close() - можно извне заставить генератор остановиться на следующем обращении к нему Эти методы в совокупности с выражением yield from превратили генераторы в сопрограммы (coroutine). ","date":"02.03.2022","objectID":"/iterators-and-generators-python/:4:0","series":null,"tags":["python"],"title":"Итераторы, генераторы и итерируемые объекты в Python","uri":"/iterators-and-generators-python/#расширенные-методы-генератора"},{"categories":["python-interview"],"content":"Модуль itertools Itertools — это встроенный модуль в Python, который содержит функции для создания итераторов для эффективных циклов. В модуле itertools есть набор итераторов, которые упрощают работу с перестановками, комбинациями, декартовыми произведениями и другими комбинаторными структурами.6 ","date":"02.03.2022","objectID":"/iterators-and-generators-python/:5:0","series":null,"tags":["python"],"title":"Итераторы, генераторы и итерируемые объекты в Python","uri":"/iterators-and-generators-python/#модуль-itertools"},{"categories":["python-interview"],"content":"Рекурсивные генераторы Как и любая другая функция, генераторы могут быть рекурсивными. Пример: генератор перестановок элементов в списке def permutations(items): if len(items) == 0: yield [] else: pi = items[:] for i in range(len(pi)): pi[0], pi[i] = pi[i], pi[0] for p in permutations(pi[1:]): yield [pi[0]] + p ","date":"02.03.2022","objectID":"/iterators-and-generators-python/:6:0","series":null,"tags":["python"],"title":"Итераторы, генераторы и итерируемые объекты в Python","uri":"/iterators-and-generators-python/#рекурсивные-генераторы"},{"categories":["python-interview"],"content":"Разница между yield и return return yield Оператор return возвращает только одно значение. Оператор yield может возвращать серию результатов в виде объекта-генератора. return выходит из функции, а в случае цикла он закрывает цикл. Это последний оператор, который нужно разместить внутри функции. Не уничтожает локальные переменные функции. Выполнение программы приостанавливается, значение отправляется вызывающей стороне, после чего выполнение программы продолжается с последнего оператора yield. Логически, функция должна иметь только один return. Внутри функции может быть более одного оператора yield. Оператор return может выполняться только один раз. Оператор yield может выполняться несколько раз. return помещается внутри обычной функции Python. Оператор yield преобразует обычную функцию в функцию-генератор. ","date":"02.03.2022","objectID":"/iterators-and-generators-python/:7:0","series":null,"tags":["python"],"title":"Итераторы, генераторы и итерируемые объекты в Python","uri":"/iterators-and-generators-python/#разница-между-yield-и-return"},{"categories":["python-interview"],"content":"Ппоточные алгоритмы Подробнее Python: итераторы, генераторы, itertools ↩︎ Python для сетевых инженеров ↩︎ Итераторы и генераторы в Python ↩︎ Iterables vs. Iterators vs. Generators ↩︎ xakep.ru - генераторы и итераторы ↩︎ docs.python.org - itertools ↩︎ ","date":"02.03.2022","objectID":"/iterators-and-generators-python/:8:0","series":null,"tags":["python"],"title":"Итераторы, генераторы и итерируемые объекты в Python","uri":"/iterators-and-generators-python/#ппоточные-алгоритмы"},{"categories":["python-interview"],"content":"ИМХО","date":"18.02.2022","objectID":"/important-peps/","series":null,"tags":["python"],"title":"Важные разделы PEP","uri":"/important-peps/"},{"categories":["python-interview"],"content":"Список вопросов к Python собеседованию PEP 8 – Style Guide for Python Code рус PEP 20 – The Zen of Python PEP 257 – Docstring Conventions PEP 343 – The “with” Statement PEP 404 – Python 2.8 Un-release Schedule PEP 435 – Adding an Enum type to the Python standard library PEP 457 – Notation For Positional-Only Parameters PEP 484 – Type Hints PEP 557 – Data Classes PEP 572 – Assignment Expressions PEP 3107 – Function Annotations PEP 3156 – Asynchronous IO Support Rebooted: the “asyncio” Module Источники12 PEP 0 ↩︎ Python Tips - Context Managers ↩︎ ","date":"18.02.2022","objectID":"/important-peps/:0:0","series":null,"tags":["python"],"title":"Важные разделы PEP","uri":"/important-peps/#"},{"categories":["python-interview"],"content":"Разберем как создать контекстный менеджер из класса или генератора (декоратор @contextmanager), что такое вложенные и асинхронные менеджеры контекста. Код примеров контекстных менеджеров на языке Python.","date":"18.02.2022","objectID":"/context-managers-python/","series":null,"tags":["python"],"title":"Контекстные менеджеры в Python","uri":"/context-managers-python/"},{"categories":["python-interview"],"content":"Список вопросов к Python собеседованию Схема для понимания итераторов и генераторов\" Схема для понимания итераторов и генераторов -- -- Краткое резюме по контекстным менеджерам Контекстные менеджеры нужны там, где есть “настройка” -\u003e блок кода -\u003e “уборка”, при этом “настройку” и “уборку” нужно выполнить в паре. У контекстного менеджера обязательно присутствуют атрибуты __enter__ и __exit__. Их добавление обеспечивает реализацию протокола контекстного менеджера. Не обязательно писать целый класс для нового контекстного менеджера, достаточно обернуть генератор в декоратор contextmanager из модуля contextlib. yield стоит оборачивать в блок try...finally. Контекстный менеджер определен в PEP 343. Контекстные менеджеры предназначены для использования в качестве более сжатого механизма управления ресурсами, чем try...finally Контекстные менеджеры дают нам надежный метод очистки ресурсов (т.к. вызов метода деструктора Python del не всегда гарантируется). ","date":"18.02.2022","objectID":"/context-managers-python/:0:0","series":null,"tags":["python"],"title":"Контекстные менеджеры в Python","uri":"/context-managers-python/#"},{"categories":["python-interview"],"content":"Контекстные менеджеры Контекстные менеджеры позволяют выделять и освобождать ресурсы именно тогда, когда нам это нужно. Наиболее широко используемым примером контекстных менеджеров является оператор with. Допустим, у нас есть две связанные операции, которые необходимо выполнить в паре + блок кода между ними. Инструкция with создает контекст выполнения, который позволяет запускать группу операторов под управлением контекстного менеджера. По сравнению с традиционными конструкциями try ... finally, инструкция with делает код более понятным, безопасным и многоразовым. Многие классы в стандартной библиотеке поддерживают оператор with. Классическим примером этого является open(), который позволяет работать с файловыми объектами используя with: with open('some_file', 'w') as opened_file: opened_file.write('Hello!') В общем случае синтаксис использования with выглядит следующим образом: with expression as target_var: do_something(target_var) expression, идущее после with должно возвращать объект, реализующий протокол управления контекстом. Этот протокол состоит из двух специальных методов: __enter__ вызывается оператором with для входа в контекст выполнения; __exit__ вызывается, когда выполнение покидает блок кода with. Спецификатор as необязателен. Если мы используем target_var с as, то значение возвращенное методом __enter__ для объекта контекстного менеджера привязывается к этой переменной. Возврат None Некоторые контекстные менеджеры возвращают None из __enter__, потому что у них нет объекта, который можно было бы вернуть вызывяющей стороне. В этих случаях использование target_var не имеет смысла. Последовательность работы: Вызов expression для получения контекстного менеджера. Сохранение методов контекстного менеджера __enter__ и __exit__ для последующего использования. Вызов метода __enter__ и сохранение возвращаемого значения в target_var (если target_var используется). Выполнение блока кода внутри with. Вызов метода __exit__ в контекстном менеджере после завершения блока кода внутри with. Наиболее частые сценарии использования: Open–Close - например, файла, или сокета Lock–Release - работа с данными в многопоточном приложении Start–Stop - например, для запуска таймера и его автоматической остановки. Change–Reset - например, приложение должно подключиться к нескольким источникам данных и у него есть соединение по умолчанию. Create-Delete Enter-Exit Setup-Teardown ","date":"18.02.2022","objectID":"/context-managers-python/:1:0","series":null,"tags":["python"],"title":"Контекстные менеджеры в Python","uri":"/context-managers-python/#контекстные-менеджеры"},{"categories":["python-interview"],"content":"Контекстный менеджер из класса Необходимый минимум функциональности контекстного менеджера требует методов __enter__ и __exit__. Метод __enter__(self) выполняется до входа в блок. Методу можно возвратить текущий экземпляр класса, что бы к нему можно было обращаться через инструкцию as. Метод __exit__(self, ex_type, ex_val, ex_trace) выполняется после выхода из блока with, и содержит три параметра — ex_type, ex_value и ex_tr. Переменная ex_type содержит в себе класс исключения, которое было возбуждено, ex_value — сообщение исключения. Чтобы превратить класс в контекстный менеджер нужно определить в нем два этих метода: class FileOpener: def __init__(self, f_name, op_type) -\u003e None: print(\"Inside __init__\") self.file = open(f_name, op_type) def __enter__(self): print(\"Inside __enter__\") return self.file def __exit__(self, ex_type, ex_val, ex_trace): print(\"Inside __exit__ %s, %s, %s\", ex_type, ex_val, ex_trace) self.file.close() return True with FileOpener(\"test.txt\", \"w\") as file: file.write(\"Test string\") raise RuntimeError() Шаги, которые выполняет with при возникновении исключения: Тип, значение и обратная трассировка ошибки передается в метод __exit__. Обработка исключения передается методу __exit__ Если __exit__ возвращает True, то исключение было корректно обработано. При возврате любого другого значения with вызывает исключение. ","date":"18.02.2022","objectID":"/context-managers-python/:2:0","series":null,"tags":["python"],"title":"Контекстные менеджеры в Python","uri":"/context-managers-python/#контекстный-менеджер-из-класса"},{"categories":["python-interview"],"content":"Контекстный менеджер из генератора Мы также можем реализовать менеджер контекста через декораторы и генераторы. В Python присутствует модуль contextlib специально для этой цели. Вместо написания класса, мы можем реализовать менеджер контекста из функции-генератора. from contextlib import contextmanager # Общий вид контекстного менеджера @contextmanager def some_generator(\u003carguments\u003e): \u003csetup\u003e try: yield \u003cvalue\u003e finally: \u003ccleanup\u003e # Конкретная реализация @contextmanager def open_file(name): f = open(name, 'w') try: yield f finally: f.close() with open_file('some_file') as f: f.write('Hello!') Пошаговый разбор данного подхода: Python встречает ключевое слово yield. Благодаря этому он создает генератор, а не простую функцию. Благодаря декоратору, contextmanager вызывается с функцией open_file в качестве аргумента. Функция contextmanager возвращает генератор, обёрнутый в объект GeneratorContextManager. GeneratorContextManager присваивается функции open_file. Таким образом, когда мы вызовем функцию open_file в следующий раз, то фактически обратимся к объекту GeneratorContextManager. ","date":"18.02.2022","objectID":"/context-managers-python/:3:0","series":null,"tags":["python"],"title":"Контекстные менеджеры в Python","uri":"/context-managers-python/#контекстный-менеджер-из-генератора"},{"categories":["python-interview"],"content":"Контекстный менеджер как декоратор Можно использовать контекстные менеджеры в качестве декораторов. Для этого при определении класса необходимо наследоваться от класса contextlib.ContextDecorator. from contextlib import ContextDecorator from time import time class RunTime(ContextDecorator): \"\"\"Timing decorator.\"\"\" def __init__(self, description): self.description = description def __enter__(self): print(self.description) self.start_time = time() def __exit__(self, *args): self.end_time = time() run_time = self.end_time - self.start_time print(f\"The function took {run_time}seconds to run.\") @RunTime(\"This function opens a file\") def custom_file_write(filename, mode, content): with open(filename, mode) as f: f.write(content) print(custom_file_write(\"file.txt\", \"wt\", \"Hello\")) Результат: This function opens a file The function took 0.0005390644073486328 seconds to run. None ","date":"18.02.2022","objectID":"/context-managers-python/:4:0","series":null,"tags":["python"],"title":"Контекстные менеджеры в Python","uri":"/context-managers-python/#контекстный-менеджер-как-декоратор"},{"categories":["python-interview"],"content":"Вложенные контекстные менеджеры Инструкция with поддерживает несколько вложенных контекстных менеджеров. Можно использовать любое количество контекстных менеджеров, разделенных запятыми: with A() as a, B() as b: pass ","date":"18.02.2022","objectID":"/context-managers-python/:5:0","series":null,"tags":["python"],"title":"Контекстные менеджеры в Python","uri":"/context-managers-python/#вложенные-контекстные-менеджеры"},{"categories":["python-interview"],"content":"Асинхронные контекстные менеджеры Распространенной практикой при написании асинхронных контекстных менеджеров является внедрение четырех специальных методов: __aenter__ __aexit__ __enter__ __exit__ # site_checker_v1.py import aiohttp import asyncio class AsyncSession: def __init__(self, url): self._url = url async def __aenter__(self): self.session = aiohttp.ClientSession() response = await self.session.get(self._url) return response async def __aexit__(self, exc_type, exc_value, exc_tb): await self.session.close() async def check(url): async with AsyncSession(url) as response: print(f\"{url}: status -\u003e {response.status}\") html = await response.text() print(f\"{url}: type -\u003e {html[:17].strip()}\") async def main(): await asyncio.gather( check(\"https://realpython.com\"), check(\"https://pycoders.com\"), ) asyncio.run(main()) ","date":"18.02.2022","objectID":"/context-managers-python/:6:0","series":null,"tags":["python"],"title":"Контекстные менеджеры в Python","uri":"/context-managers-python/#асинхронные-контекстные-менеджеры"},{"categories":["python-interview"],"content":"Примеры менеджеров контекста ","date":"18.02.2022","objectID":"/context-managers-python/:7:0","series":null,"tags":["python"],"title":"Контекстные менеджеры в Python","uri":"/context-managers-python/#примеры-менеджеров-контекста"},{"categories":["python-interview"],"content":"Создание сессии в SQLAlchemy from sqlalchemy import create_engine from sqlalchemy.orm import sessionmaker from contextlib import contextmanager # an Engine, which the Session will use for connection resources some_engine = create_engine(\"sqlite://\") # create a configured \"Session\" class Session = sessionmaker(bind=some_engine) @contextmanager def session_scope(): \"\"\"Provide a transactional scope around a series of operations.\"\"\" session = Session() try: yield session session.commit() except: session.rollback() raise finally: session.close() ","date":"18.02.2022","objectID":"/context-managers-python/:7:1","series":null,"tags":["python"],"title":"Контекстные менеджеры в Python","uri":"/context-managers-python/#создание-сессии-в-sqlalchemy"},{"categories":["python-interview"],"content":"Тайминг выполнения кода import time class Timer: def __init__(self, name): self.name = name def __enter__(self): self.start = time.time() def __exit__(self, *args): self.end = time.time() self.interval = self.end - self.start print(\"%stook: %0.3fseconds\" % (self.name, self.interval)) return False Источники12345 Python Tips - Context Managers ↩︎ Python Context Managers ↩︎ Context Managers and Python’s with Statement ↩︎ The Curious Case of Python’s Context Manager ↩︎ Часть доклада Рэймонда Хэттингера ↩︎ ","date":"18.02.2022","objectID":"/context-managers-python/:7:2","series":null,"tags":["python"],"title":"Контекстные менеджеры в Python","uri":"/context-managers-python/#тайминг-выполнения-кода"},{"categories":["python-interview"],"content":"Давайте создавать надежные и хорошо реализованные системы, а не каких-то быстрорастущих монстров. Этому поможет следование указанным здесь принципам проектирования и разработки программного обеспечения.","date":"14.12.2021","objectID":"/coding-principles/","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/"},{"categories":["python-interview"],"content":"YAGNI «You Ain’t Gonna Need It» — «Вам это не понадобится» Процесс и принцип проектирования ПО, при котором в качестве основной цели и/или ценности декларируется отказ от избыточной функциональности, — то есть отказ добавления функциональности, в которой нет непосредственной надобности. ","date":"14.12.2021","objectID":"/coding-principles/:1:0","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#yagni"},{"categories":["python-interview"],"content":"DRY Don’t repeat yourself - не повторяйте себя Это принцип разработки программного обеспечения, нацеленный на снижение повторения информации различного рода, особенно в системах со множеством слоёв абстрагирования. Принцип DRY формулируется как: «Каждая часть знания должна иметь единственное, непротиворечивое и авторитетное представление в рамках системы». Он был сформулирован Энди Хантом и Дэйвом Томасом в их книге The Pragmatic Programmer. ","date":"14.12.2021","objectID":"/coding-principles/:2:0","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#dry"},{"categories":["python-interview"],"content":"KISS Keep It Stupid Simple (Keep it short and simple / Keep it simple, stupid) - Придерживайся простоты Принцип KISS утверждает, что большинство систем работают лучше всего, если они остаются простыми, а не усложняются. Поэтому в области проектирования простота должна быть одной из ключевых целей, и следует избегать ненужной сложности. ","date":"14.12.2021","objectID":"/coding-principles/:3:0","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#kiss"},{"categories":["python-interview"],"content":"SLAP Single Level of Abstraction Principle - «Принцип единого уровня абстракций» Диктует нам, как мы должны организовывать свой код (в частности, функции), чтобы он оставался поддерживаемым. ","date":"14.12.2021","objectID":"/coding-principles/:4:0","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#slap"},{"categories":["python-interview"],"content":"SOLID SOLID это аббревиатура пяти основных принципов проектирования в объектно-ориентированном программировании, предложенных Робертом Мартином: Single responsibility — принцип единственной ответственности Open-closed — принцип открытости / закрытости Liskov substitution — принцип подстановки Барбары Лисков Interface segregation — принцип разделения интерфейса Dependency inversion — принцип инверсии зависимостей ","date":"14.12.2021","objectID":"/coding-principles/:5:0","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#solid"},{"categories":["python-interview"],"content":"SRP Single Responsibility Principle - «Принцип единой ответственности», SRP В чем-то похож на SLAP, но направлен на объектно-ориентированное программирование. Этот принцип гласит, что объекты и классы (а также функции и методы) нужно организовывать так, чтобы каждый из них имел только одну зону ответственности. ","date":"14.12.2021","objectID":"/coding-principles/:5:1","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#srp"},{"categories":["python-interview"],"content":"OCP Open-Closed Principle - «Принцип открытости-закрытости» Требует, чтобы код был открыт для новых, будущих дополнений, и чтобы при их добавлении не приходилось изменять уже написанный код. Этот принцип в большей степени затрагивает вопросы архитектуры, чем кода как такового. ","date":"14.12.2021","objectID":"/coding-principles/:5:2","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#ocp"},{"categories":["python-interview"],"content":"LSP Liskov Substitution Principle - «Принцип подстановки Барбары Лисков» Назван в честь его автора, Барбары Лисков. Суть его в том, что каждый подтип должен дополнять, а не заменять базовый тип. ","date":"14.12.2021","objectID":"/coding-principles/:5:3","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#lsp"},{"categories":["python-interview"],"content":"ISP Interface Segregation Principle - «Принцип разделения интерфейса» Это еще один принцип, затрагивающий тему организации кода. ","date":"14.12.2021","objectID":"/coding-principles/:5:4","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#isp"},{"categories":["python-interview"],"content":"DIP Dependency Inversion Principle - «Принцип инверсии зависимостей» Как и OCP, DIP, в большей степени касается общей архитектуры кода. Фактически, это один из самых важных принципов проектирования архитектуры кода. код должен быть написан так, чтобы детали реализации (например, пользовательский интерфейс или база данных) зависели от основной логики (правил бизнеса), а не наоборот. все эти зависимости не должны быть прямыми. Их нужно абстрагировать при помощи интерфейсов, чтобы основная логика работала со всем, что бы ей ни передали, требуя для этого только какой-нибудь простой «мост». ","date":"14.12.2021","objectID":"/coding-principles/:5:5","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#dip"},{"categories":["python-interview"],"content":"CQS Command-Query Separation - разделения команд и запросов Все функции некоторого интерфейса должны быть или некоторыми запросами, возвращающими ответ, или командами, изменяющими состояние системы, но не одновременно. Никогда функция не должна возвращать ответ и изменять состояние системы одновременно. ","date":"14.12.2021","objectID":"/coding-principles/:6:0","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#cqs"},{"categories":["python-interview"],"content":"LoD Law of Demeter - закон Деметры Говорит нам примерно следующее: «не разговаривай с незнакомцами и не создавайте ненужных зависимостей». Закон Деметры — это, скорее, рекомендация, о которой стоит помнить. ","date":"14.12.2021","objectID":"/coding-principles/:7:0","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#lod"},{"categories":["python-interview"],"content":"IoC Inversion of Control - Инверсия управления Важный принцип объектно-ориентированного программирования, используемый для уменьшения зацепления (связанности) в компьютерных программах. Он подразумевает что ходом программы управляет внешний, по отношению к ней, фреймворк. Dependency Injection (DI) является частью IoC. ","date":"14.12.2021","objectID":"/coding-principles/:8:0","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#ioc"},{"categories":["python-interview"],"content":"DI Dependency Injection - Внедрение зависимости Стиль разработки программного кода, когда в зависимости класса не создаются им напрямую, а внедряются из вне. При этом уменьшается связанность кода, но теряется контроль над созданием и временем жизни объектов, от которых зависит класс. ","date":"14.12.2021","objectID":"/coding-principles/:8:1","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#di"},{"categories":["python-interview"],"content":"DAMP Descriptive And Meaningful Phrases - Описательные и значимые фразы Принцип написания модульных тестов таким образом, чтобы происходящее в них можно было понять без дополнительных комментариев и документации. Достигается использованием описательных имен и допускает небольшие нарушения принципа DRY при необходимости. ","date":"14.12.2021","objectID":"/coding-principles/:9:0","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#damp"},{"categories":["python-interview"],"content":"AAA (3A) Arrange Act Assert - Условие, Действие, Проверка Это шаблон для форматирования Unit тестов. Обозначающий разделения теста на 3 части Arrange - все необходимые подготовки и входные данные Act - собственно, вызов того метода который вы тестируете Assert - проверка, что метод делает то что надо ","date":"14.12.2021","objectID":"/coding-principles/:10:0","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#aaa-3a"},{"categories":["python-interview"],"content":"GRASP General Responsibility Assignment Software Patterns - общие шаблоны распределения ответственностей Это набор шаблонов, используемых в объектно-ориентированном проектировании для решения общих задач по назначению ответственностей классам и объектам. ","date":"14.12.2021","objectID":"/coding-principles/:11:0","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#grasp"},{"categories":["python-interview"],"content":"Information Expert Информационный эксперт – класс, сосредотачивающий информацию о конкретной предметной области. Операции над ней также передаются в его ответственность. Например, Aсcount хранит информацию о счете и может предоставить выписку с него. ","date":"14.12.2021","objectID":"/coding-principles/:11:1","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#information-expert"},{"categories":["python-interview"],"content":"Creator (Создатель) Классы, создающие другие классы. Это может быть фабрика, пул и т.д. ","date":"14.12.2021","objectID":"/coding-principles/:11:2","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#creator-создатель"},{"categories":["python-interview"],"content":"Controller (Контроллер) Объект, который несет в себе управляющие функции (не путать с бизнес-логикой приложения). Яркий пример - Контроллер в шаблоне MVC. ","date":"14.12.2021","objectID":"/coding-principles/:11:3","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#controller-контроллер"},{"categories":["python-interview"],"content":"Low Coupling (Низкая связанность) Данный принцип декларирует программирование на основе интерфейсов и абстракций, а не конкретных реализаций. Это способствует упрощению повторного использования кода, его поддержки, модификации, тестированию. ","date":"14.12.2021","objectID":"/coding-principles/:11:4","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#low-coupling-низкая-связанность"},{"categories":["python-interview"],"content":"High Cohesion (Высокое сцепление) Методы внутри классы должны быть тесно связаны между собой. Это еще одна гарантия, того что класс обеспечивается реализацию четко определенной единственной ответственности. Классы с низким сцеплением легко можно разделить на несколько. ","date":"14.12.2021","objectID":"/coding-principles/:11:5","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#high-cohesion-высокое-сцепление"},{"categories":["python-interview"],"content":"Pure Fabrication (Чистая выдумка) Представляет собой классы, которые не отображают реальных объектов из предметной области приложения. Например, репозиторий, используемый для сохранения и загрузки объектов из хранилища. ","date":"14.12.2021","objectID":"/coding-principles/:11:6","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#pure-fabrication-чистая-выдумка"},{"categories":["python-interview"],"content":"Indirection (Посредник) Необходим для устранения сильной связанности нескольких классов. На него ложится ответственность организации взаимодействия между ними. К слову, Контроллер в MVC является также посредником между Моделью и Представлением. ","date":"14.12.2021","objectID":"/coding-principles/:11:7","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#indirection-посредник"},{"categories":["python-interview"],"content":"Protected Variations (Защищенные изменения) Данный принцип предполагает определение объектов, которые наиболее вероятно будут подвержены изменениям, и применение мер, по минимизации влияний этих изменений на остальные части приложения. ","date":"14.12.2021","objectID":"/coding-principles/:11:8","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#protected-variations-защищенные-изменения"},{"categories":["python-interview"],"content":"Polymorphism (Полиморфизм) Возможность объектов с одинаковой спецификацией иметь различную реализацию. ","date":"14.12.2021","objectID":"/coding-principles/:11:9","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#polymorphism-полиморфизм"},{"categories":["python-interview"],"content":"OR Occam’s Razor - Бритва Оккама Суть в том, что не нужно создавать лишние методы, классы и переменные, если в них нет нужды. ","date":"14.12.2021","objectID":"/coding-principles/:12:0","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#or"},{"categories":["python-interview"],"content":"BDUF Big Design Up Front - Глобальное проектирование прежде всего Этот подход к разработке программного обеспечения очень важен, и его часто игнорируют. Прежде чем переходить к реализации, убедитесь, что все хорошо продумано. ","date":"14.12.2021","objectID":"/coding-principles/:13:0","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#bduf"},{"categories":["python-interview"],"content":"APO Avoid Premature Optimization - Избегайте преждевременной оптимизации Преждевременная оптимизация может привести к задержкам в коде и, следовательно, увеличит затраты времени на вывод функций на рынок. Многие считают преждевременную оптимизацию корнем всех зол. ","date":"14.12.2021","objectID":"/coding-principles/:14:0","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#apo"},{"categories":["python-interview"],"content":"POLA Principle Of Least Astonishment - Принцип наименьшего удивления Не заставляйте удивляться других программистов вашему коду. Нужно программировать просто, понятно и очевидно, чтобы любой другой специалист мог прочитать ваше творение. Имена и названия методов и классов должны нести информативность и быть лаконичными. Вызываемый метод должен соответствовать тому, для чего он вызывается и как он называется. Источники: 10 Coding principles and acronyms demystified! ","date":"14.12.2021","objectID":"/coding-principles/:15:0","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#pola"},{"categories":["python-interview"],"content":"Вопросы на собеседование по Python","date":"11.12.2021","objectID":"/python-interview-questions/","series":null,"tags":["python"],"title":"Вопросы с ответами к собеседованию по Python","uri":"/python-interview-questions/"},{"categories":["python-interview"],"content":"Общие вопросы Принципы программирования? Отличия процедурной и объектно-ориентированной парадигмы программирования? Основные принципы ООП? Что такое множественное наследование? Что такое @property? Что такое инженерия и процесс разработки в целом? Основные методологии разработки (жизненный цикл продукта)? Методология Agile. Различия Kanban и Scrum подходов. Методы HTTP-запросов и какая между ними разница? Как выглядят HTTP-request/response? Что такое авторизация и как она работает? Что такое cookies? Что такое веб уязвимость? Какие знаете классические базы данных? Как читать спецификацию в конкретном языке (например, PEP8 в Python)? Как происходит взаимодействие клиента и сервера? Какие есть подходы к проектированию API? Как масштабировать API? Паттерны проектирования и как они используются? Что такое Acceptance Testing и зачем его используют? Что такое модульные и интеграционные тесты, API-тесты? Как писать unit-тесты? Какие есть best practices в написании автотестов? Какие базовые команды системы контроля версий? Как использовать Git? В чем разница между хешированием и шифрованием? Ориентируетесь ли в *nix, можете ли написать скрипты/автоматизацию для себя и коллег? Что такое многопоточность? Что такое архитектура веб сервисов? Как работает современное нагруженное веб приложение (нарисовать и обсудить примерную архитектуру, например, Twitter или Instagram)? Что нужно для сайта/сервиса среднего размера (redis, celery, кэш, логирование, метрики)? Как написать, задеплоить и поддерживать (микро) сервис? Как проводить Code review? Что такое абстрактная фабрика, как ее реализовать и зачем ее применяют? Что такое цикломатическая сложность? Каким образом можно запустить код на Python параллельно? Как работать с stdlib? Какие задачи решали с помощью метаклассов? Что такое дескрипторы? ","date":"11.12.2021","objectID":"/python-interview-questions/:1:0","series":null,"tags":["python"],"title":"Вопросы с ответами к собеседованию по Python","uri":"/python-interview-questions/#общие-вопросы"},{"categories":["python-interview"],"content":"Python Какие есть изменяемые и постоянные типы данных? Какие есть типы данных и какая разница между list и tuple, зачем они? Как использовать встроенные коллекции (list, set, dict)? В чем заключается сложность доступа к элементам dict? Что такое область видимости переменных? Что такое introspection? В чем заключается разница между операторами is и ==? Как создается объект в Python. Разница между __init__ и __new__? В чем разница между потоками и процессами? Какие есть виды импорта? Что такое итератор и генератор. В чем между ними разница? Что такое сопрограммы (corutines) и как они реализованы в Python? Что такое метакласс, переменная цикла? В чем разница между staticmethod и classmethod? Как работают контекстные менеджеры? Как работают декораторы? Можно ли использовать несколько декораторов для одной функции? Можно ли создать декоратор из класса? Как работают dict comprehension, list comprehension и set comprehension? Какие есть основные популярные пакеты (requests, pytest, etc)? Что такое lambda-функции? Что означает *args, **kwargs и как они используются? Как передаются аргументы функций в Python (by value or reference)? Что такое exceptions, \u003ctry-except\u003e? Что такое PEP (Python Enhancement Proposal), какие из них знаете (PEP8, PEP484)? Что знаете из модуля collections, какими еще built-in модулями пользовались? Как Python работает с HTTP-сервером? Что происходит, когда создается виртуальная среда? Async Python: как работает, зачем, что под капотом? Что такое модель памяти Python? Принципы работы и механизм Garbage collection, reference counting? Как работает thread locals? Что такое __slots__? Что такое type annotation? Какие преимущества дает Variable Annotations? Для чего используют нижние подчеркивания в именах объектов? Статические анализаторы: Flake8, Pylint, Radon. ","date":"11.12.2021","objectID":"/python-interview-questions/:2:0","series":null,"tags":["python"],"title":"Вопросы с ответами к собеседованию по Python","uri":"/python-interview-questions/#python"},{"categories":["python-interview"],"content":"Django N+1 проблема и как решить? Что такое SQLAlchemy (Core и ORM частей) и какие есть альтернативы? Что такое шаблонизатор и как в нем выполнять базовые операции (объединять участки шаблона, выводить дату, выводить данные с серверной стороны)? Что такое миксины? Как провалидировать данные в сериализаторе? Методы create, update в серилизаторе. Как передать в запросе лист id так, чтобы создался объект сразу с m2m связими? Что такое lt, gt, gte, lte в ORM? or в Django ORM. Напишите hello-world сервис, используя один из фреймворков. Сравнить асинхронные web-фреймворки. ","date":"11.12.2021","objectID":"/python-interview-questions/:3:0","series":null,"tags":["python"],"title":"Вопросы с ответами к собеседованию по Python","uri":"/python-interview-questions/#django"},{"categories":["python-interview"],"content":"Базы данных Какие есть базовые методы работы с SQL-базой данных в Python? Что такое SQL-транзакция? Как сделать выборку из SQL-базы с простой агрегацией? Как выглядит запрос, который выполняет JOIN между таблицами и к самим себе? Как отправлять запросы в SQL-базу данных без ORM? Индексация в базе данных sql Разница между SQL и NoSQL? Как оптимизировать SQL-запросы? Какие есть уровни изоляции транзакций? Какие есть виды индексов? ","date":"11.12.2021","objectID":"/python-interview-questions/:4:0","series":null,"tags":["python"],"title":"Вопросы с ответами к собеседованию по Python","uri":"/python-interview-questions/#базы-данных"},{"categories":["python-interview"],"content":"DevOps Рассказать про Docker, Docker Compose и Docker Swarm Объяснить основные термины K8s (кластер, pod, node, deployment, service), что такое Kibana? Как зайти на внешний сервер, работать с пакетами, настроить среду и выполнять операции? ","date":"11.12.2021","objectID":"/python-interview-questions/:5:0","series":null,"tags":["python"],"title":"Вопросы с ответами к собеседованию по Python","uri":"/python-interview-questions/#devops"},{"categories":["python-interview"],"content":"Data Science Как работать с пакетами для обработки и визуализации данных (NumPy, Pandas и другие)? ","date":"11.12.2021","objectID":"/python-interview-questions/:6:0","series":null,"tags":["python"],"title":"Вопросы с ответами к собеседованию по Python","uri":"/python-interview-questions/#data-science"},{"categories":["python-interview"],"content":"Алгоритмы Что такое временная сложность алгоритма (time complexity)? Что такое Big-O notation? Какие есть базовые алгоритмы сортировки? Что такое Bubble Sort и как это работает? Что такое линейная сложность сортировки? ","date":"11.12.2021","objectID":"/python-interview-questions/:7:0","series":null,"tags":["python"],"title":"Вопросы с ответами к собеседованию по Python","uri":"/python-interview-questions/#алгоритмы"},{"categories":null,"content":"Описание","date":"08.12.2021","objectID":"/about/","series":null,"tags":null,"title":"Обо мне","uri":"/about/"},{"categories":null,"content":" 🖖 Привет! Меня зовут Алексей, мне 35 лет и я Веб-мастер Backend разработчик. -- Мой путь -- Первую HTML страничку я сделал примерно в 2001 году, и это во многом определило мою дальнейшую жизнь. В 2004 поступил в ННГУ Лобачевского на факультет ВМК (прикладная математика и информатика). В 2009 получил диплом специалиста по специальности \"математик, системный программист\". Будучи студентом, а затем стажером - изучал и применял на практике С++ и Java. -- По своей инициативе ковырялся в PHP, Perl и JS. Наверное, с тех пор я и отдал предпочтение интерпретируемым языкам. -- Более 10 лет я занимался разработкой и продвижением сайтов. За это время успел поработать с CMS Joomla, InstantCMS, Opencart, Wordpress, 1C-Bitrix. Разрабатывал с нуля сайты-визитки, одностраничники, интернет-магазины, корпоративные сайты, статейники и агрегаторы. Работая как частный специалист проходил все этапы разработки: Как менеджер проекта: выявление потребностей клиента, разработка и согласование ТЗ, анализ ниши, согласование этапов разработки; Как frontend-разработчик: прототипирование, верстка, интеграция; Как backend-разработчик: развертывание сайта на хостинге, установка и настройка CMS, доработка функционала; Как SEO-специалист: анализ конкурентов, сбор и кластеризация семантического ядра, рекомендации по созданию структуры и подготовке контента, оптимизация сайта, технический аудит, настройка аналитики; Как контент-менеджер: создание структуры сайта, наполнение сайта; Ценность полученного мной опыта в том, что я могу глубже погружаться в поставленную задачу на основе существующих знаний. Считаю, что разработчик, понимающий весь стек технологий, способен: писать более качественные приложения; более эффективно взаимодействовать с коллегами; обладая обширным арсеналом идей и концепций, лучше справляться со своими основными задачами; лучше понимать, что происходит при использовании клиентом программного обеспечения; лучше понимать бизнес клиента. Что я использую в работе MacOS VS Code (GitLens, Beautify, htmltagwrap, Thunder Client) iTerm (zsh, oh-my-zsh, powerlevel10k, brew, pyenv, vim) Docker SnippetsLab CotEditor Safari PasteBot Trello, Things, Notion GoodNotes, Notability Parallels Desktop Affinity Photo, Affinity Designer, Affinity Publisher Postman SimpleMind Pro Навыки Python Django DRF JSON APIs PostgreSQL Celery Flower Nginx Traefik Redis Prometheus Grafana Docker Docker Compose Git GitHub GitHub Actions Unit testing HTML CSS Таймлайн февраль 2021 — по настоящее время Погружаюсь в бэкенд (Python, Django) октябрь 2015 — февраль 2022 Web-разработчик, SEO-специалист в ПКФ Луидор, Нижний Новгород (автомобильный завод, спецавтомобили) апрель 2012 — октябрь 2015 Full-stack разработчик, SEO специалист на фрилансе сентябрь 2011 — апрель 2012 Заместитель руководителя филиала в Редокс, Москва (оптовая торговля, товары для здоровья) сентябрь 2008 — апрель 2011 Менеджер по продажам в Редокс, Нижний Новгород (розничная торговля, товары для здоровья) ноябрь 2006 — май 2008 Инженер-стажер в Тэлма Софт, Нижний Новгород (разработка ПО) сентябрь 2004 — май 2009 ННГУ им. Лобачевского, ВМК Нижний Новгород сентябрь 1994 — май 2004 Средняя школа №4, Городец -- -- ","date":"08.12.2021","objectID":"/about/:0:0","series":null,"tags":null,"title":"Обо мне","uri":"/about/#"},{"categories":null,"content":"Образование: ННГУ Лобачевского (ВМК). Стек: Python 3.6+, Django 2.2+, DRF, PostgreSQL, Redis, Celery, Docker, git, pytest, HTML, CSS, JS. Более 10 лет опыта в разработке и продвижении сайтов.","date":"08.12.2021","objectID":"/cv/","series":null,"tags":null,"title":"Резюме: Junior python backend developer | Байков Алексей","uri":"/cv/"},{"categories":null,"content":"Резюме на вакансию в компанию -- Скачать (.pdf) Байков Алексей 02.01.1987 (35 лет) Python backend разработчик Уровень: Junior, Junior+ Уровень: Middle-- Занятость: полная Формат работы: удаленная, в офисе Зарплатные ожидания: 100.000 руб Контакты +7 (929) 053-73-35 https://t.me/alexbaikov alex@baikov.dev Нижний Новгород, Россия -- Python Django DRF JSON APIs PostgreSQL Celery Flower Nginx Traefik Redis Prometheus Grafana Docker Docker Compose Git GitHub GitHub Actions Unit testing HTML CSS Все навыки... -- Образование ННГУ им. Лобачевского Нижегородский государственный университет им. Н.И. Лобачевского 2004-2009 (5 лет), дневное отделение, очно Факультет вычислительной математики и кибернетики Специальность: Прикладная математика и информатика Специализация: Системы поддержки принятия решений -- Квалификация: математик, системный программист Цели Начать карьеру backend-разработчика в современной продуктовой компании. Профессиональный рост до уровня Middle в течение года и, как следствие, повышение своей рентабельности. Стек: Python 3.6+, Django 2.2+, PostgreSQL, DRF, FastAPI, Docker. -- Опыт работы февраль 2021 — по настоящее время (1 год) Изучение нового стека Все изучаемые технологии применял на практике (проект allflags.ru) Краткий список практических навыков: Администрирование VPS, работа с Heroku, AWS, Yandex.Cloud; Настройка Nginx, Traefik, Prometheus, Grafana; Работа с Docker и Docker Compose, основы CI/CD; Codestyle (flake8, black), тестирование (pytest, coverage), документирование (Sphinx); Контроль версий и процесс ветвления (git, github, git-flow, github-flow); Работа с Django, DRF, PostgreSQL, Redis, Celery, Flower. Python Django Git Docker Celery PostgreSQL DRF Redis CI/CD Traefik Linux Prometheus Grafana -- октябрь 2015 — по настоящее время (6 лет 4 мес) ПКФ Луидор, Нижний Новгород (автомобильный завод, спецавтомобили) Web-разработчик, SEO-специалист Разработал сервис поиска запчастей по VIN (backend: Django и DRF, frontend: Vue.js); Разработка, доработка и продвижение сайтов компании на 1C-Bitrix; Более 3 лет опыта удаленной работы. HTML CSS Vue.js SCSS 1С-Bitrix PHP SEO JavaScript Gulp -- апрель 2012 — октябрь 2015 (3 года 7 мес) Фриланс, собственные проекты Full-stack разработчик, SEO специалист создание и продвижение сайтов (1C-Bitrix, WordPress, OpenCart). сентябрь 2011 — апрель 2012 (1 год 1 мес) Редокс, Москва (оптовая торговля, товары для здоровья) Заместитель руководителя филиала сентябрь 2008 — апрель 2011 (2 года 7 мес) Редокс, Нижний Новгород (розничная торговля, товары для здоровья) Менеджер по продажам ноябрь 2006 — май 2008 (1 год 7 мес) Тэлма Софт, Нижний Новгород (разработка ПО) Инженер-стажер в отделе разработки и тестирования ПО Стажировка во время обучения в университете. Обо мне Я люблю веб-разработку и занимаюсь ей более 10 лет. За это время приобрел как менеджерский опыт, так и опыт во frontend, backend и DevOps. Надеюсь, что новый стек и углубление в бэкенд позволят мне участвовать в разработке более крупных и интересных проектов. Моя цель на текущий год: начать карьеру backend-разработчика в современной компании и дорасти до уровня Middle. Навыки Python Django DRF JSON APIs PostgreSQL Celery Flower Nginx Traefik Redis Prometheus Grafana Docker Docker Compose Git GitHub GitHub Actions Unit testing HTML CSS -- Образование ННГУ им. Лобачевского Нижегородский государственный университет им. Н.И. Лобачевского 2004-2009 (5 лет), дневное отделение, очно Факультет вычислительной математики и кибернетики Специальность: Прикладная математика и информатика Специализация: Системы поддержки принятия решений -- Квалификация: математик, системный программист Навыки Python Django DRF JSON APIs PostgreSQL Celery Flower Nginx Traefik Redis Prometheus Grafana Docker Docker Compose Git GitHub GitHub Actions Unit testing HTML CSS Языки Русский родной Английский Intermediate Курсы Docker 2021, slurm.io-- Docker | 2021, slurm.io Build a Backend REST API with Python \u0026 Django 2021, Udemi-- Build a Backend REST AP","date":"08.12.2021","objectID":"/cv/:0:0","series":null,"tags":null,"title":"Резюме: Junior python backend developer | Байков Алексей","uri":"/cv/#"},{"categories":["python-interview"],"content":"Область видимости или scope определяет контекст переменной, в рамках которого ее можно использовать. В Python есть три типа контекста: глобальный, локальный и нелокальный.","date":"21.10.2021","objectID":"/python-scope-of-variables/","series":null,"tags":["python"],"title":"Область видимости переменных в Python","uri":"/python-scope-of-variables/"},{"categories":["python-interview"],"content":"Список вопросов к Python собеседованию Область видимости (scope) определяет контекст переменной, в рамках которого ее можно использовать. В Python существует три области видимости: локальная глобальная нелокальная Основные моменты: Изнутри функции видны переменные, которые были определены и внутри нее и снаружи. Переменные, определенные внутри функции – локальные, снаружи – глобальные. Снаружи функций не видны никакие переменные, определенные внутри них. Изнутри функции можно изменять значение переменных, которые определены в глобальной области видимости с помощью спецификатора global. Изнутри вложенной функции с помощью спецификатора nonlocal можно изменять значения переменных, которые были определены во внешней функции, но не находятся в глобальной области видимости. Источники: Хабр статья Документация Python ","date":"21.10.2021","objectID":"/python-scope-of-variables/:0:0","series":null,"tags":["python"],"title":"Область видимости переменных в Python","uri":"/python-scope-of-variables/#"},{"categories":["python-interview"],"content":"Все четыре основных аспекта общей структуры ООП поддерживаются системой объектно-ориентированного программирования Python: инкапсуляция, абстракция, наследование и полиморфизм.","date":"17.10.2021","objectID":"/python-oop/","series":["oop"],"tags":["python","oop-tag"],"title":"Объектно-ориентированное программирование (ООП) в Python","uri":"/python-oop/"},{"categories":["python-interview"],"content":"Список вопросов к Python собеседованию ","date":"17.10.2021","objectID":"/python-oop/:0:0","series":["oop"],"tags":["python","oop-tag"],"title":"Объектно-ориентированное программирование (ООП) в Python","uri":"/python-oop/#"},{"categories":["python-interview"],"content":"Отличия процедурного подхода и ООП Существуют два главных подхода к написанию программ: Процедурное программирование Объектно-ориентированное программирование (ООП) Цель у этих подходов одна - сделать процесс программирования максимально эффективным. Но в ООП, в отличии от процедурного подхода, данные первичны, а код для обработки этих данных - вторичен. В процедурном подходе основой программы является функция. Функции вызывают друг друга и при необходимости передают данные. В программе функции живут отдельно, данные — отдельно. Основной недостаток процедурного подхода - сложность создания и поддержки больших программ. Наличие сотен функций в таких проектах очень часто приводит к ошибкам и спагетти-коду. В основе объектно-ориентированного программирования лежит понятие объекта. Объект совмещает в себе и функции и данные. Основное преимущество ООП перед процедурным программированием - изоляция кода на уровне классов, что позволяет писать более простой и лаконичный код.1 ","date":"17.10.2021","objectID":"/python-oop/:1:0","series":["oop"],"tags":["python","oop-tag"],"title":"Объектно-ориентированное программирование (ООП) в Python","uri":"/python-oop/#отличия-процедурного-подхода-и-ооп"},{"categories":["python-interview"],"content":"Классы и объекты в ООП Объектно-ориентированное программирование (ООП) — методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определённого класса, а классы образуют иерархию наследования.2 Класс описывает множество объектов, имеющих общую структуру и обладающих одинаковым поведением это шаблон кода, по которому создаются объекты. Т. е. сам по себе класс ничего не делает, но с его помощью можно создать объект и уже его использовать в работе Классы в Python – это тоже объекты Допустимо динамическое изменение и добавление атрибутов классов Для скрытия внутренних данных используются синтаксические соглашения Поддерживается наследование Полиморфизм обеспечивается виртуальностью всех методов Доступно метапрограммирование Объект (экземпляр класса) это конкретный представитель класса Жизненным циклом объекта можно управлять Многие операторы могут быть перезагружены Многие методы встроенных объектов можно эмулировать # класс с минимально-возможным функционалом class A: pass # объект класса a = A() ","date":"17.10.2021","objectID":"/python-oop/:2:0","series":["oop"],"tags":["python","oop-tag"],"title":"Объектно-ориентированное программирование (ООП) в Python","uri":"/python-oop/#классы-и-объекты-в-ооп"},{"categories":["python-interview"],"content":"Атрибуты класса (Attributes) Атрибут класса (объекта) - любой элемент (свойство, метод, подкласс), на который можно сослаться через символ точки (MyClass.\u003cатрибут\u003e или my_object.\u003cатрибут\u003e). Атрибуты делятся на встроенные и пользовательские: Встроенные (служебные) атрибуты - методы и свойства унаследованные от общего для всех классов в Python родительского класса object. Многие из этих атрибутов можно переопределить внутри своего класса. Пользовательские атрибуты - поля и методы, которые описываются программистом в теле класса. Добавляются в общий список атрибутов наряду со встроенными.3 Поля класса - это характеристики объекта класса. Методы класса - это функции, с помощью которых можно оперировать данными класса. Любой метод является атрибутом, но не любой атрибут - методом. Атрибуты-поля можно условно разделить на две группы: Статические - поля класса, которые объявляются внутри тела класса и создаются тогда, когда создается класс. Динамические - поля экземпляра. Для создания динамического поля необходимо обратиться к self внутри метода. class Phone: # Статические атрибуты (поля) default_color = 'Grey' default_model = 'C385' def __init__(self, color, model): # Динамические атрибуты (поля) self.color = color self.model = model Служебное слово self - это ссылка на текущий экземпляр класса. self не является зарезервированным. Является аналогом этого this (Java, C++). ","date":"17.10.2021","objectID":"/python-oop/:3:0","series":["oop"],"tags":["python","oop-tag"],"title":"Объектно-ориентированное программирование (ООП) в Python","uri":"/python-oop/#атрибуты-класса-attributes"},{"categories":["python-interview"],"content":"Встроенные (специальные) атрибуты Атрибуты (поля и методы), имена которых обрамляются __, Python трактует как специальные. Специальные атрибуты, как правило, идут первыми при объявлении класса. Использование: операторы перегрузки - если необходимо добавить возможность выполнения стандартных операций над классами дополнить… Основные встроенные методы и поля: __new__(cls, ...) - Конструктор. Создает экземпляр класса. Сам класс передается в качестве аргумента. Редко переопределяется, чаще используется реализация от базового класса object __init__(self, ...) - Инициализатор. Принимает свежесозданный объект класса из конструктора. Является очень удобным способом задать параметры объекта при его создании. __del__(self) - Деструктор. Вызывается при удалении объекта сборщиком мусора __str__(self) - Возвращает строковое представление объекта. __repr__ __hash__(self) - Возвращает хэш-сумму объекта. __doc__ - Тип: str. Документация класса. __dict__ - Тип: dict. Словарь, в котором хранится пространство имен класса ","date":"17.10.2021","objectID":"/python-oop/:3:1","series":["oop"],"tags":["python","oop-tag"],"title":"Объектно-ориентированное программирование (ООП) в Python","uri":"/python-oop/#встроенные-специальные-атрибуты"},{"categories":["python-interview"],"content":"Свойства класса (@property) Организация доступа к членам класса в Python построена на принципе универсального доступа, гласящем, что «все услуги, предлагаемые модулем должны быть доступны через единую нотацию, которая не раскрывает, реализованы ли они посредством хранения либо вычисления». В частности, это предполагает предоставлять доступ к переменным напрямую, например, foo.x = 0, а не foo.set_x(0); в случае необходимости проверки устанавливаемого значения использовать свойства, которые сохраняют единый синтаксис доступа, установка значения foo.x = 0 приводит к вызову foo.set_x(0). Преимуществом данного подхода является возможность использование синтаксиса foo.x += 1, хотя на самом деле внутри происходит вызов foo.set_x(foo.get_x() + 1). Свойства (Property) — это особый вид атрибутов имитирующий поле (но который при чтении вызывает какой-либо метод). У них есть методы получения, установки и удаления, такие как __get__, __set__ и __delete__ Мы можем определить геттеры, сеттеры и деструкторы с помощью функции property() Свойство может определяться при помощи декораторов: @property - определяет метод получения значения, @field.setter - определяет метод установки значения свойства field. Имя свойства field определяется в наименовании обоих методов и декораторе @field.setter Если необходимо реализовать свойство «только для чтения», второй метод может быть опущен вместе с декоратором @field.setter Примером применения свойства является получение информации, которая может потребовать затратного первоначального поиска и простого повторного class Cash: def __init__(self, value): self.value = value @property def formatted(self): return '${:.2f}'.format(self.value) @formatted.setter def formatted(self, new): self.value = float(new[1:]) По сути, когда Python встречает следующий код: spam = SomeObject() print(spam.eggs) он ищет eggs в spam, а затем проверяет eggs на наличие у него методов __get__, __set__ или __delete__ и если они есть, то это свойство. Если это свойство, то вместо того, чтобы просто вернуть объект eggs (как это было бы для любого другого атрибута), он вызовет метод __get__ и возвращает все, что возвращает этот метод.4 ","date":"17.10.2021","objectID":"/python-oop/:3:2","series":["oop"],"tags":["python","oop-tag"],"title":"Объектно-ориентированное программирование (ООП) в Python","uri":"/python-oop/#свойства-класса-property"},{"categories":["python-interview"],"content":"Методы экземпляра (обычные методы) Методы экземпляра - это обычные функции, которые становятся доступны только после создания экземпляра класса. Первым параметром такого метода является слово self. ","date":"17.10.2021","objectID":"/python-oop/:3:3","series":["oop"],"tags":["python","oop-tag"],"title":"Объектно-ориентированное программирование (ООП) в Python","uri":"/python-oop/#методы-экземпляра-обычные-методы"},{"categories":["python-interview"],"content":"Статические методы (Static methods) Статические методы - это обычные функции, которые помещены в класс для удобства и тем самым располагаются в области видимости этого класса. Чаще всего это какой-то вспомогательный код. Обозначаются специальным декоратором @staticmethod. ничего не знают о классе или об объекте, на котором они вызываются не принимают специальных аргументов типа self или cls поэтому не используют сам объект или класс при выполнении могут быть вызваны, как через сам класс, так и через его экземпляр ","date":"17.10.2021","objectID":"/python-oop/:3:4","series":["oop"],"tags":["python","oop-tag"],"title":"Объектно-ориентированное программирование (ООП) в Python","uri":"/python-oop/#статические-методы-static-methods"},{"categories":["python-interview"],"content":"Методы класса (Class methods) Методы класса принимают в качестве первого параметра cls (вместо self в обычных методах). cls - это ссылка на класс, на котором был вызван метод. Обозначаются специальным декоратором @classmethod. могут менять состояние самого класса, что в свою очередь отражается на ВСЕХ экземплярах данного класса не могут менять конкретный объект класса используются, когда не требуется привязка к экземпляру объекта привязаны только к области видимости Методы класса часто используются, когда: Необходимо создать специфичный объект текущего класса Нужно реализовать фабричный паттерн (создаём объекты различных унаследованных классов прямо внутри метода) Реализовать дополнительные методы инициализации ","date":"17.10.2021","objectID":"/python-oop/:3:5","series":["oop"],"tags":["python","oop-tag"],"title":"Объектно-ориентированное программирование (ООП) в Python","uri":"/python-oop/#методы-класса-class-methods"},{"categories":["python-interview"],"content":"Перегрузка методов (Method Overloading) Перегрузка методов (Множественная диспетчеризация, Мультиметоды) - это использование множества методов с одним и тем же именем, которые позволяют выбирать нужную функциональность в зависимости от количества, типов или значений аргументов в пределах одного класса. Python по умолчанию не поддерживает перегрузку методов, поскольку запоминает только самое последнее определение метода. Для их реализации необходимо подключать сторонние Python библиотеки, например, multimethods.py. ","date":"17.10.2021","objectID":"/python-oop/:3:6","series":["oop"],"tags":["python","oop-tag"],"title":"Объектно-ориентированное программирование (ООП) в Python","uri":"/python-oop/#перегрузка-методов-method-overloading"},{"categories":["python-interview"],"content":"Переопределение методов (Method Overriding) Когда метод с тем же именем и аргументами используется как в производном классе, так и в базовом или суперклассе, мы говорим, что метод производного класса переопределяет метод, представленный в базовом классе. ","date":"17.10.2021","objectID":"/python-oop/:3:7","series":["oop"],"tags":["python","oop-tag"],"title":"Объектно-ориентированное программирование (ООП) в Python","uri":"/python-oop/#переопределение-методов-method-overriding"},{"categories":["python-interview"],"content":"Последовательность поиска атрибутов У одного объекта может быть несколько родительских классов, а также специальные методы вроде __getattribute__, которые перехватывают запросы к атрибутам. Каким же образом интерпретатор разрешает сложные запросы к свойствам и методам? Рассмотрим последовательность поиска на примере запроса obj.field: Вызов obj.__getattribute__('field'), если он определен. При установке или удалении атрибута проверяется соответственно наличие __setattr__ или __delattr__. Поиск в obj.__dict__ (пользовательские атрибуты). Поиск в object.__class__.__slots__. Рекурсивный поиск в поле __dict__ всех родительских классов. Если класс имеет несколько предков, порядок проверки соответствует порядку их перечисления в определении. Если определен метод __getattr__, то происходит вызов obj.__getattr__('field') Выбрасывается исключение несуществующего атрибута – AttributeError. Наконец, когда атрибут нашелся, проверяется наличие метода __get__ (при установке – __set__, при удалении – __delete__). Все эти проверки совершаются только для пользовательских атрибутов.5 ","date":"17.10.2021","objectID":"/python-oop/:3:8","series":["oop"],"tags":["python","oop-tag"],"title":"Объектно-ориентированное программирование (ООП) в Python","uri":"/python-oop/#последовательность-поиска-атрибутов"},{"categories":["python-interview"],"content":"Класс как структура данных В ряде случаев бывает полезным иметь структуру, похожую на структуру из языка Си (или запись из Паскаля), позволяющую логически сгруппировать данные. Для этого можно использовать словарь или класс с пустой реализацией. ","date":"17.10.2021","objectID":"/python-oop/:3:9","series":["oop"],"tags":["python","oop-tag"],"title":"Объектно-ориентированное программирование (ООП) в Python","uri":"/python-oop/#класс-как-структура-данных"},{"categories":["python-interview"],"content":"Основные принципы ООП На текущий момент ООП является самой востребованной и распространенной парадигмой программирования. Концепция ООП строится на основе 4 принципов: абстракция, инкапсуляция, наследование и полиморфизм. ","date":"17.10.2021","objectID":"/python-oop/:4:0","series":["oop"],"tags":["python","oop-tag"],"title":"Объектно-ориентированное программирование (ООП) в Python","uri":"/python-oop/#основные-принципы-ооп"},{"categories":["python-interview"],"content":"Абстракция Абстракция - принцип ООП, согласно которому объект характеризуется свойствами, которые отличают его от всех остальных объектов и при этом четко определяют его концептуальные границы. Абстракция позволяет представить сложную концепцию в более простой форме: Выделить главные и наиболее значимые свойства предмета. Отбросить второстепенные характеристики. Абстракция не поддерживается в Python напрямую. ","date":"17.10.2021","objectID":"/python-oop/:4:1","series":["oop"],"tags":["python","oop-tag"],"title":"Объектно-ориентированное программирование (ООП) в Python","uri":"/python-oop/#абстракция"},{"categories":["python-interview"],"content":"Инкапсуляция Инкапсуляция - принцип ООП, согласно которому сложность реализации программного компонента должна быть спрятана за его интерфейсом. Инкапсуляция не дает взглянуть на внутреннюю реализацию сложной концепции: Отсутствует доступ к внутреннему устройству программного компонента. Взаимодействие компонента с внешним миром осуществляется посредством интерфейса, который включает публичные методы и поля. В ряде языков, например, С++, существует четкое разделение членов класса на закрытые (private), защищенные (protected) и публичные (public). В Python все члены класса являются общедоступными, но существует возможность эмуляции private и protected на уровне договоренностей. Концепция отсутствия закрытых атрибутов в Python описывается фразой одного из разработчиков языка: «Мы все взрослые люди. Если программист хочет выстрелить себе в ногу - нужно предоставить ему возможность это сделать». В Python принята следующая договоренность: Protected (Non-Public) - обозначается при помощи одинарного нижнего подчеркивания _. Данный синтаксис указывает на то, что атрибут: используется для внутренней реализации класса и не предназначен для использования извне; должен быть использован/изменен только если разработчик-пользователь класса абсолютно уверен в этом. При этом атрибут с _ доступен извне, как и обычный public-атрибут класса. Private - обозначается при помощи двойного нижнего подчеркивания __. Данный синтаксис указывает на то, что атрибут: используется для внутренней реализации класса и не предназначен для использования извне; не должен быть использован/изменен разработчиком-пользователем класса. При этом атрибут с __ оказывается недоступным извне, используя технику сокрытия имен (Name Mangling). Несмотря на это, в отличие от ряда языков (например, Java) такие «закрытые» члены класса также можно изменять, но более сложным способом - их можно увидеть, используя функцию dir(). We don’t use the term “private” here, since no attribute is really private in Python (without a generally unnecessary amount of work).6 class SomeClass: def __init__(self, public_var: str, protected_var: str, private_var: str): self.public_var = public_var # public self._protected_var = protected_var # protected self.__private_var = private_var # private def _private(self): # Это внутренний метод объекта print(\"Private method\") obj = SomeClass(\"I'm Public\", \"I'm Protected\", \"I'm Private\") obj.public_var # \u003e\u003eI'm Public obj._protected_var # \u003e\u003eI'm Protected obj.__private_var # AttributeError: 'SomeClass' object has no attribute '__private_var' obj._SomeClass__private_var # \u003e\u003eI'm Private obj._private() # \u003e\u003ePrivate method Геттеры, сеттеры и деструкторы Кроме прямого доступа к атрибутам (obj.attrName), могут быть использованы специальные методы доступа: геттеры, сеттеры и деструкторы: class SomeClass: def __init__(self, value): self._value = value def getvalue(self): # получение значения атрибута - геттер return self._value def setvalue(self, value): # установка значения атрибута - сеттер self._value = value def delvalue(self): # удаление атрибута - деструктор del self._value value = property(getvalue, setvalue, delvalue, \"Свойство value\") Такой подход очень удобен, если получение или установка значения атрибута требует сложной логики. Вместо того чтобы вручную создавать геттеры и сеттеры для каждого атрибута, можно перегрузить встроенные методы __getattr__, __setattr__ и __delattr__. Например, так можно перехватить обращение к свойствам и методам, которых в объекте не существует: class SomeClass(): attr1 = 42 def __getattr__(self, attr): return attr.upper() obj = SomeClass() obj.attr1 # 42 obj.attr2 # ATTR2 __getattribute__ перехватывает все обращения (в том числе и к существующим атрибутам). Для чего нужна инкапсуляция? Инкапсуляция упрощает процесс разработки, т. к. позволяет нам не вникать в тонкости реализации того или иного объекта. Повышается надежность программ за счет того, что при внесении изменений в один из компонентов, остальные части программы остаются","date":"17.10.2021","objectID":"/python-oop/:4:2","series":["oop"],"tags":["python","oop-tag"],"title":"Объектно-ориентированное программирование (ООП) в Python","uri":"/python-oop/#инкапсуляция"},{"categories":["python-interview"],"content":"Инкапсуляция Инкапсуляция - принцип ООП, согласно которому сложность реализации программного компонента должна быть спрятана за его интерфейсом. Инкапсуляция не дает взглянуть на внутреннюю реализацию сложной концепции: Отсутствует доступ к внутреннему устройству программного компонента. Взаимодействие компонента с внешним миром осуществляется посредством интерфейса, который включает публичные методы и поля. В ряде языков, например, С++, существует четкое разделение членов класса на закрытые (private), защищенные (protected) и публичные (public). В Python все члены класса являются общедоступными, но существует возможность эмуляции private и protected на уровне договоренностей. Концепция отсутствия закрытых атрибутов в Python описывается фразой одного из разработчиков языка: «Мы все взрослые люди. Если программист хочет выстрелить себе в ногу - нужно предоставить ему возможность это сделать». В Python принята следующая договоренность: Protected (Non-Public) - обозначается при помощи одинарного нижнего подчеркивания _. Данный синтаксис указывает на то, что атрибут: используется для внутренней реализации класса и не предназначен для использования извне; должен быть использован/изменен только если разработчик-пользователь класса абсолютно уверен в этом. При этом атрибут с _ доступен извне, как и обычный public-атрибут класса. Private - обозначается при помощи двойного нижнего подчеркивания __. Данный синтаксис указывает на то, что атрибут: используется для внутренней реализации класса и не предназначен для использования извне; не должен быть использован/изменен разработчиком-пользователем класса. При этом атрибут с __ оказывается недоступным извне, используя технику сокрытия имен (Name Mangling). Несмотря на это, в отличие от ряда языков (например, Java) такие «закрытые» члены класса также можно изменять, но более сложным способом - их можно увидеть, используя функцию dir(). We don’t use the term “private” here, since no attribute is really private in Python (without a generally unnecessary amount of work).6 class SomeClass: def __init__(self, public_var: str, protected_var: str, private_var: str): self.public_var = public_var # public self._protected_var = protected_var # protected self.__private_var = private_var # private def _private(self): # Это внутренний метод объекта print(\"Private method\") obj = SomeClass(\"I'm Public\", \"I'm Protected\", \"I'm Private\") obj.public_var # I'm Public obj._protected_var # I'm Protected obj.__private_var # AttributeError: 'SomeClass' object has no attribute '__private_var' obj._SomeClass__private_var # I'm Private obj._private() # Private method Геттеры, сеттеры и деструкторы Кроме прямого доступа к атрибутам (obj.attrName), могут быть использованы специальные методы доступа: геттеры, сеттеры и деструкторы: class SomeClass: def __init__(self, value): self._value = value def getvalue(self): # получение значения атрибута - геттер return self._value def setvalue(self, value): # установка значения атрибута - сеттер self._value = value def delvalue(self): # удаление атрибута - деструктор del self._value value = property(getvalue, setvalue, delvalue, \"Свойство value\") Такой подход очень удобен, если получение или установка значения атрибута требует сложной логики. Вместо того чтобы вручную создавать геттеры и сеттеры для каждого атрибута, можно перегрузить встроенные методы __getattr__, __setattr__ и __delattr__. Например, так можно перехватить обращение к свойствам и методам, которых в объекте не существует: class SomeClass(): attr1 = 42 def __getattr__(self, attr): return attr.upper() obj = SomeClass() obj.attr1 # 42 obj.attr2 # ATTR2 __getattribute__ перехватывает все обращения (в том числе и к существующим атрибутам). Для чего нужна инкапсуляция? Инкапсуляция упрощает процесс разработки, т. к. позволяет нам не вникать в тонкости реализации того или иного объекта. Повышается надежность программ за счет того, что при внесении изменений в один из компонентов, остальные части программы остаются","date":"17.10.2021","objectID":"/python-oop/:4:2","series":["oop"],"tags":["python","oop-tag"],"title":"Объектно-ориентированное программирование (ООП) в Python","uri":"/python-oop/#геттеры-сеттеры-и-деструкторы"},{"categories":["python-interview"],"content":"Наследование Наследование - способ создания нового класса на основе уже существующего, при котором класс-потомок заимствует свойства и методы родительского класса, а также добавляет собственные. Класс потомок может переопределять родительские методы. При этом, обычно, дочерний класс дополняет родительский метод, добавив свой код после кода родителя (используя функцию super(), предоставляющую ссылку на родительский класс). Каждый класс также может получить информацию о своих «родителях» через метод __bases__() или isinstance(). Наследование описывается словом «является» (легковой автомобиль является автомобилем). Существуют и другой вид взаимосвязи (модель включения/делегации), когда один класс включает в себя другой класс в качестве одного из полей - ассоциация, композиция и агрегация. Ассоциация описывается словом «имеет» (автомобиль имеет двигатель). class Parent: def __init__(self, var1): self.var1 = var1 class Child(Parent): def __init__(self, var1, var2): super().__init__(self, var1) self.var2 = var2 Метод super() дает возможность наследнику обратиться к родительскому классу. Для чего нужно наследование? Принцип DRY (повторное использование кода); Классы-потомки берут общий функционал у родительского класса. Ускорение разработки нового ПО на основе переиспользования существующих открытых классов. Наследование упрощает процесс написания кода. Python реализует как стандартное одиночное наследование так и множественное. Множественное наследование Используя множественное наследования можно создавать классы-миксины (примеси), представляющие собой определенную особенность поведения. Множественное наследование часто критикуется 10 и зачастую считается признаком неверного анализа и проектирования, поэтому его использование рекомендуется в случае крайней необходимости и оправданности такого решения.7 ","date":"17.10.2021","objectID":"/python-oop/:4:3","series":["oop"],"tags":["python","oop-tag"],"title":"Объектно-ориентированное программирование (ООП) в Python","uri":"/python-oop/#наследование"},{"categories":["python-interview"],"content":"Наследование Наследование - способ создания нового класса на основе уже существующего, при котором класс-потомок заимствует свойства и методы родительского класса, а также добавляет собственные. Класс потомок может переопределять родительские методы. При этом, обычно, дочерний класс дополняет родительский метод, добавив свой код после кода родителя (используя функцию super(), предоставляющую ссылку на родительский класс). Каждый класс также может получить информацию о своих «родителях» через метод __bases__() или isinstance(). Наследование описывается словом «является» (легковой автомобиль является автомобилем). Существуют и другой вид взаимосвязи (модель включения/делегации), когда один класс включает в себя другой класс в качестве одного из полей - ассоциация, композиция и агрегация. Ассоциация описывается словом «имеет» (автомобиль имеет двигатель). class Parent: def __init__(self, var1): self.var1 = var1 class Child(Parent): def __init__(self, var1, var2): super().__init__(self, var1) self.var2 = var2 Метод super() дает возможность наследнику обратиться к родительскому классу. Для чего нужно наследование? Принцип DRY (повторное использование кода); Классы-потомки берут общий функционал у родительского класса. Ускорение разработки нового ПО на основе переиспользования существующих открытых классов. Наследование упрощает процесс написания кода. Python реализует как стандартное одиночное наследование так и множественное. Множественное наследование Используя множественное наследования можно создавать классы-миксины (примеси), представляющие собой определенную особенность поведения. Множественное наследование часто критикуется 10 и зачастую считается признаком неверного анализа и проектирования, поэтому его использование рекомендуется в случае крайней необходимости и оправданности такого решения.7 ","date":"17.10.2021","objectID":"/python-oop/:4:3","series":["oop"],"tags":["python","oop-tag"],"title":"Объектно-ориентированное программирование (ООП) в Python","uri":"/python-oop/#множественное-наследование"},{"categories":["python-interview"],"content":"Полиморфизм Термин «полиморфизм» происходит из греческого языка и означает «нечто, что принимает несколько форм». Полиморфизм - это поддержка нескольких реализаций на основе общего интерфейса. Абстрактный метод (виртуальный метод) - это метод класса, реализация для которого отсутствует. Полиморфизм в компилируемых языках В компилируемых языках программирования полиморфизм достигается за счет создания виртуальных методов, которые в отличие от невиртуальных можно перегрузить в классе-потомке. Все методы в языке изначально виртуальные. Это значит, что дочерние классы могут их переопределять и решать одну и ту же задачу разными путями. Название метода остается прежним, а реализация изменяется и будет выбрана только во время исполнения программы. Такие классы называют полиморфными. Другая формулировка Полиморфизм позволяет одинаково обращаться с объектами, имеющими однотипный интерфейс, независимо от внутренней реализации объекта. class Bird: def move(self): print('Летает') class Penguin(Bird): def move(self): print('Ходит') crow = Bird() crow.move() # Летает emperor_penguin = Penguin() emperor_penguin.move() # Ходит Можно получить и доступ к методам класса-предка либо по прямому обращению, либо с помощью функции super(): class Parent: def __init__(self): print('Parent init') def method(self): print('Parent method') class Child(Parent): def __init__(self): Parent.__init__(self) # Прямое обращение def method(self): super(Child, self).method() # Через метод super() child = Child() # Parent init child.method() # Parent method Одинаковый интерфейс с разной реализацией могут иметь и классы, которые не связаны отношениями Родитель-Потомок. Это возможно благодаря утиной типизации. ","date":"17.10.2021","objectID":"/python-oop/:4:4","series":["oop"],"tags":["python","oop-tag"],"title":"Объектно-ориентированное программирование (ООП) в Python","uri":"/python-oop/#полиморфизм"},{"categories":["python-interview"],"content":"Метаклассы Метаклассы – это классы, инстансы которых тоже являются классами.8 Принципы ООП. Классы, объекты, поля и методы. Уровни доступа. ↩︎ Wikipedia - ООП ↩︎ Пользовательские атрибуты в Python ↩︎ What’s the difference between a Python “property” and “attribute”? ↩︎ ООП на Python: концепции, принципы и примеры реализации ↩︎ PEP 8 - Designing for Inheritance ↩︎ Объектно-ориентированное программирование и классы ↩︎ Метаклассы в Python: что это такое и с чем его едят ↩︎ ","date":"17.10.2021","objectID":"/python-oop/:5:0","series":["oop"],"tags":["python","oop-tag"],"title":"Объектно-ориентированное программирование (ООП) в Python","uri":"/python-oop/#метаклассы"},{"categories":["python-interview"],"content":"В Python анонимная функция — это функция, определенная без имени. Анонимные функции определяются с помощью ключевого слова lambda и называются лямбда-функциями.","date":"14.09.2021","objectID":"/python-lambda/","series":null,"tags":["python","functional-programming"],"title":"lambda функции в Python 3 - определение анонимной фукции, примеры","uri":"/python-lambda/"},{"categories":["python-interview"],"content":"Список вопросов к Python собеседованию ","date":"14.09.2021","objectID":"/python-lambda/:0:0","series":null,"tags":["python","functional-programming"],"title":"lambda функции в Python 3 - определение анонимной фукции, примеры","uri":"/python-lambda/#"},{"categories":["python-interview"],"content":"Что такое анонимная функция В буквальном смысле, анонимная функция — это функция без имени. В Python анонимная функция создается с помощью ключевого слова lambda.1 lambda принимает произвольное количество аргументов, за которыми следует одно выражение. Оно становится телом функции, а его значение будет тем, что вернет лямбда-функция. lambda \u003cargs\u003e: \u003cexpression\u003e Взаимозаменяемые термины Следующие термины могут использоваться взаимозаменяемо в зависимости от языка программирования: Анонимные функции Лямбда-функции Лямбда-выражения Лямбда-абстракции Лямбда-форма Функциональные литералы ","date":"14.09.2021","objectID":"/python-lambda/:1:0","series":null,"tags":["python","functional-programming"],"title":"lambda функции в Python 3 - определение анонимной фукции, примеры","uri":"/python-lambda/#что-такое-анонимная-функция"},{"categories":["python-interview"],"content":"Аргументы lambda-функци lambda поддерживают все способы передачи аргументов: Позиционные аргументы; Именованные аргументы; Переменный список неименованных аргументов (*args); Переменный список именованных аргументов (**kwargs). (lambda x, y, z: x + y + z)(1, 2, 3) (lambda x, y, z=3: x + y + z)(1, 2) (lambda x, y, z=3: x + y + z)(1, y=2) (lambda *args: sum(args))(1,2,3) (lambda **kwargs: sum(kwargs.values()))(one=1, two=2, three=3) (lambda x, *, y=0, z=0: x + y + z)(1, y=2, z=3) ","date":"14.09.2021","objectID":"/python-lambda/:2:0","series":null,"tags":["python","functional-programming"],"title":"lambda функции в Python 3 - определение анонимной фукции, примеры","uri":"/python-lambda/#аргументы-lambda-функци"},{"categories":["python-interview"],"content":"Отличия lambda от обычной функции Лямбда имеет синтаксические отличия от обычной функции: Может содержать только выражение и не может включать операторы в свое тело; Записывается в одну строку; Не поддерживает аннотации типов; Может быть немедленно вызвана (IIFE); Не может содержать утверждения (return, pass, assert или raise вызовут исключение SyntaxError). Декоратор может быть применен к лямбде. Хотя невозможно декорировать лямбду с помощью синтаксиса @decorator, декоратор — это просто функция, поэтому он может вызывать функцию lambda: # Defining a decorator def trace(f): def wrap(*args, **kwargs): print(f\"[TRACE] func: {f.__name__}, args: {args}, kwargs: {kwargs}\") return f(*args, **kwargs) return wrap # Applying decorator to a lambda print((trace(lambda x: x ** 2))(3)) # [TRACE] func: \u003clambda\u003e, args: (3,), kwargs: {} ","date":"14.09.2021","objectID":"/python-lambda/:3:0","series":null,"tags":["python","functional-programming"],"title":"lambda функции в Python 3 - определение анонимной фукции, примеры","uri":"/python-lambda/#отличия-lambda-от-обычной-функции"},{"categories":["python-interview"],"content":"Особенности lambda-функции Часто используются с функциями более высокого порядка, которые принимают одну или несколько функций в качестве аргументов или возвращают одну или несколько функций. Может быть функцией более высокого порядка, принимая функцию (нормальную или лямбда-функцию) в качестве аргумента. Регулярно используется со встроенными функциями map() и filter(), а также functools.reduce(), представленными в модуле functools. Лямбда-функций следует избегать, когда код: не следует руководству по стилю Python (PEP 8); выглядит громоздким и трудно читаемым. Всегда используйте оператор def вместо оператора присваивания, который связывает лямбду непосредственно с идентификатором. (PEP 8)2 ","date":"14.09.2021","objectID":"/python-lambda/:4:0","series":null,"tags":["python","functional-programming"],"title":"lambda функции в Python 3 - определение анонимной фукции, примеры","uri":"/python-lambda/#особенности-lambda-функции"},{"categories":["python-interview"],"content":"Примеры # Сортировка списка a = [(1, 2), (4, 1), (9, 10), (13, -3)] a.sort(key=lambda x: x[1]) # Параллельная сортировка списков data = list(zip(list1, list2)) data.sort() # map list(map(lambda x: x.upper(), ['cat', 'dog', 'cow'])) # ['CAT', 'DOG', 'COW'] # filter list(filter(lambda x: 'o' in x, ['cat', 'dog', 'cow'])) # ['dog', 'cow'] # reduce from functools import reduce reduce(lambda acc, x: f'{acc}| {x}', ['cat', 'dog', 'cow']) # 'cat | dog | cow' How to Use Python Lambda Functions ↩︎ PEP8 ↩︎ ","date":"14.09.2021","objectID":"/python-lambda/:5:0","series":null,"tags":["python","functional-programming"],"title":"lambda функции в Python 3 - определение анонимной фукции, примеры","uri":"/python-lambda/#примеры"},{"categories":["python-interview"],"content":"К основным встроенным (built-in) типам относятся: NoneType (None), Numeric Type (int, float, complex), Boolean (True и False), Sequence Type (str, list, tuple, range), а так же set, frozenset и dict.","date":"06.09.2021","objectID":"/python-built-in-data-types/","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/"},{"categories":["python-interview"],"content":"Говоря о типах данных, стоит упомянуть, что Python - язык с неявной сильной динамической типизацией (подробнее о видах типизации в языках программирования). Встроенные и не встроенные типы В Python типы данных можно разделить на встроенные в интерпретатор (built-in) и не встроенные, которые можно использовать при импортировании соответствующих модулей. Int - больше, чем просто int Стандартная реализация Python написана на C (CPython). Это означает, что каждый объект Python — это просто искусно замаскированная структура C, которая содержит не только его значение, но и другую информацию. Каждое значение в Python имеет тип данных. Поскольку в Python все является объектом, типы данных на самом деле являются классами, а переменные являются экземплярами (объектами) этих классов. На аппаратном уровне переменная — это ссылка на место в памяти. ","date":"06.09.2021","objectID":"/python-built-in-data-types/:0:0","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#"},{"categories":["python-interview"],"content":"Числовые типы (Numeric Types) Существует три базовых числовых типа: int, float, complex. ","date":"06.09.2021","objectID":"/python-built-in-data-types/:1:0","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#числовые-типы-numeric-types"},{"categories":["python-interview"],"content":"Integer int - целые числа. Отрицательные и положительные числа любой длины (ограничением является только количество памяти). # integer a = 1000 type(a) # \u003cclass 'int'\u003e ","date":"06.09.2021","objectID":"/python-built-in-data-types/:1:1","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#integer"},{"categories":["python-interview"],"content":"Float float - числа с плавающей точкой, отрицательные или положительные, содержащие десятичную точку или символ экспоненты “e” (показатель возведения в степень 10: 35e3, 12E4). Точность до 15 знаков после запятой. float может принимать значения nan и inf/-inf. # float b = 12.5634423 # 35e3, 12E4, -87.7e100 type(b) # \u003cclass 'float'\u003e # Not A Number x = float(\"nan\") print(x) # nan type(x) # \u003cclass 'float'\u003e # Аналогично с бесконечностью y = float(\"inf\") # inf z = float(\"-inf\") # -inf ","date":"06.09.2021","objectID":"/python-built-in-data-types/:1:2","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#float"},{"categories":["python-interview"],"content":"Complex complex - комплексные числа (x+yj, где x - действительная часть, y - мнимая часть, а j - мнимая единица). # complex c = 3+5j # 5j, -5j type(c) # \u003cclass 'complex'\u003e print(c.real) # 3.0 print(c.imag) # 5.0 ","date":"06.09.2021","objectID":"/python-built-in-data-types/:1:3","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#complex"},{"categories":["python-interview"],"content":"Long long - использовался для представления больших целых чисел. Кроме того, boolean является подтипом int. ","date":"06.09.2021","objectID":"/python-built-in-data-types/:1:4","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#long"},{"categories":["python-interview"],"content":"Логический тип (Boolean Type) В булевом типе данных есть только два типа значений: True и False (встроенные константы чувствительные к регистру). type(True) # \u003cclass 'bool'\u003e type(False) # \u003cclass 'bool'\u003e Функция приведения типа bool() позволяет оценить любое значение и вернуть True или False. В Python истинными и ложными значениями считаются не только True и False: Истинное значение: любое ненулевое число любая непустая строка любой непустой объект Ложное значение: 0 None пустая строка пустой объект ","date":"06.09.2021","objectID":"/python-built-in-data-types/:2:0","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#логический-тип-boolean-type"},{"categories":["python-interview"],"content":"Последовательности (Sequence Type) К ним относятся основные: str (строка), list (список), tuple (кортеж), range (диапазон) и бинарные: bytes (байтовая строка), bytearray (байтовый массив), memoryview (специальные объекты для доступа к внутренним данным объекта через protocol buffer). Как и все типы данных, последовательности делятся на изменяемые (mutable) и неизменяемые (immutable). Операции, поддерживаемые большинством последовательностей (изменяемых и неизменяемых): x in s # (x not in s) - проверка принадлежности s + t # конкатенация s * n # s[i] # получение по индексу s[i:j:k] # срезы (старт:стоп:шаг) len(s) # длина s min(s) # минимальный элемент s max(s) # максимальный элемент s s.index(x[, i[, j]]) # индекс первого появления x (at or after index i and before index j) s.count(x) # общее кол-во вхождений x в s hash() - единственная операция, реализованная в неизменяемых типах последовательностей и отсутствующая в изменяемых. Это позволяет использовать неизменяемые последовательности, такие как экземпляры кортежей, в качестве ключей словаря и хранить их в set и frozenset. Операции над изменяемыми последовательностями: s[i] = x s[i:j] = t del s[i:j] s[i:j:k] = t del s[i:j:k] s.append(x) s.clear() s.copy() s.extend(t) # or s += t s *= n s.insert(i, x) s.pop() # or s.pop(i) s.remove(x) s.reverse() ","date":"06.09.2021","objectID":"/python-built-in-data-types/:3:0","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#последовательности-sequence-type"},{"categories":["python-interview"],"content":"Строка (string) Cтрока - это неизменяемая упорядоченная последовательность символов Юникода. В питоне нет символьного типа данных char, символ представляет собой строку одинарной длины. Строку можно создать различными способами: # Одинарные кавычки first_way = 'This is a string' # Двойные кавычки second_way = \"This is a string\" # Тройные кавычки (одинарные или двойные) third_way_single = '''This is a string''' third_way_double = \"\"\"This is a string\"\"\" Для строк доступны общие операции c последовательностями, а так же дополнительные методы встроенного класса str(). ","date":"06.09.2021","objectID":"/python-built-in-data-types/:3:1","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#строка-string"},{"categories":["python-interview"],"content":"Список (list) Список — это изменяемая упорядоченная последовательность, обычно используемая для хранения коллекций однородных элементов. Поскольку списки индексируются, то могут содержать элементы с одинаковым значением. list1 = [10, 20, 30, 77] list2 = ['one', 'dog', 'seven'] list3 = [1, 20, 4.0, 'word'] ","date":"06.09.2021","objectID":"/python-built-in-data-types/:3:2","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#список-list"},{"categories":["python-interview"],"content":"Кортеж (tuple) Кортеж — это неизменяемая упорядоченная последовательность, обычно используемая для хранения коллекций разнородных элементов. Также используются в случаях, когда требуется неизменяемая последовательность однородных данных (например, использование в экземпляре set или dict). Кортежи, как правило, быстрее, чем списки в Python. tuple1 = (1, 2, 5, 6) tuple2 = tuple('a', 'b', 'c') tuple3 = () # пустой кортеж tuple4 = 23, 13, 100 tuple5 = (\"London\", \"Tokyo\", \"Korea\", 1986, 1640, 1948) ","date":"06.09.2021","objectID":"/python-built-in-data-types/:3:3","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#кортеж-tuple"},{"categories":["python-interview"],"content":"Диапазон (range) Тип range представляет собой упорядоченную неизменяемую последовательность чисел и обычно используется для выполнения определенного количества раз циклов for. Для диапазонов доступны общие операции с последовательностями, кроме конкатенации и повторения. Проверка диапазонов range на равенство с == и != сравнивает их как последовательности. Атрибуты start, stop и step. ","date":"06.09.2021","objectID":"/python-built-in-data-types/:3:4","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#диапазон-range"},{"categories":["python-interview"],"content":"Байтовые строки (bytes) Тип данных bytes - это упорядоченная неизменяемая последовательность отдельных байтов. Синтаксис для байтовых строк в основном такой же, как и для обычных строк, за исключением того, что добавляется префикс b. ","date":"06.09.2021","objectID":"/python-built-in-data-types/:3:5","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#байтовые-строки-bytes"},{"categories":["python-interview"],"content":"Байтовый массив (bytearray) Bytearray объекты являются упорядоченным неизменяемым аналогом bytes. ","date":"06.09.2021","objectID":"/python-built-in-data-types/:3:6","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#байтовый-массив-bytearray"},{"categories":["python-interview"],"content":"Буфер обмена (memoryview) Объекты memoryview позволяют коду Python получать доступ к внутренним данным объекта, который поддерживает буферный протокол, без копирования. ","date":"06.09.2021","objectID":"/python-built-in-data-types/:3:7","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#буфер-обмена-memoryview"},{"categories":["python-interview"],"content":"Множества (Set Types) Множество - это неупорядоченный набор различных хешируемых объектов. Обычно множества используются для проверки вхождения элемента, удаления дубликатов из последовательности и вычисления математических операций, таких как пересечение, объединение, разность и т. д. Будучи неупорядоченной коллекцией, множества не сохраняют положение элемента или порядок вставки. Соответственно, не поддерживают индексы, срезы или другое поведение, подобное упорядоченной последовательности. Существует два встроенных типа множеств: set и frozenset. ","date":"06.09.2021","objectID":"/python-built-in-data-types/:4:0","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#множества-set-types"},{"categories":["python-interview"],"content":"Множество (set) Тип set является изменяемым множеством, содержимое может быть изменено с помощью таких методов, как add() и remove(), так же поддерживает операции доступные frozenset. Поскольку тип set является изменяемым, он не имеет хеш-значения и не может использоваться ни как ключ словаря, ни как элемент другого множества. # Use the type constructor set2 = set('a', 'b', 'c') # Use a comma-separated list of elements within braces set1 = {1, 2, 5, 6} # Use a set comprehension {c for c in 'abracadabra' if c not in 'abc'} ","date":"06.09.2021","objectID":"/python-built-in-data-types/:4:1","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#множество-set"},{"categories":["python-interview"],"content":"Неизменяемое множество (frozenset) Тип frozenset является неизменяемым и хешируемым множеством, его содержимое не может быть изменено после его создания, поэтому он может использоваться как ключ словаря или как элемент другого множества. # Use the type constructor s = frozenset({'a', 'b', 'c'}) ","date":"06.09.2021","objectID":"/python-built-in-data-types/:4:2","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#неизменяемое-множество-frozenset"},{"categories":["python-interview"],"content":"Словарь (dict) Словарь — это упорядоченная, изменяемая коллекция пар ключ: значение, в которой не допускается дублирование ключей. Ключи словаря - это произвольные, неизменяемые (хешируемые) значения. Значения элементов словаря могут иметь любой тип данных. Словари стали упорядоченными. Словари и объекты представления словаря (dict.keys(), dict.values(), dict.items()) теперь обратимы. Словарь может быть создан несколькими способами: # Используя разделенный запятыми список пар ключ: значение в фигурных скобках dict1 = {'Moscow': 1023, 'SPB': 2048} # Используя dict comprehension dict2 = {x: x ** 2 for x in range(10)} # Используя конструктор типа dict3 = dict([('foo', 100), ('bar', 200)]) dict4 = dict(foo=100, bar=200) В других языках программирования тип данных подобный словарю может называться ассоциативный массив, хеш или хеш-таблица. ","date":"06.09.2021","objectID":"/python-built-in-data-types/:5:0","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#словарь-dict"},{"categories":["python-interview"],"content":"Итераторы и генераторы ``` Объект с id = 1672501744 будет иметь значение 15 и изменить его уже нельзя. Если тип данных изменяемый, то можно менять значение объекта. Например, создадим список [1, 2], а потом заменим второй элемент на 3. ```python a = [1, 2] id(a) # 47997336 a[1] = 3 print(a) # [1, 3] id(a) # 47997336 ``` ## Упорядоченные и неупорядоченные типы -- Источники: Python documentation - Built-in Types Understand How Much Memory Your Python Objects Use Understanding Data Types in Python ","date":"06.09.2021","objectID":"/python-built-in-data-types/:6:0","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#итераторы-и-генераторы"},{"categories":["python-interview"],"content":"Интроспекция (introspection) — это способность объекта во время выполнения получить тип, доступные атрибуты и методы, а также другую информацию, необходимую для выполнения дополнительных операций с объектом.","date":"23.08.2021","objectID":"/introspection-in-python/","series":null,"tags":["python"],"title":"Интроспекция в Python","uri":"/introspection-in-python/"},{"categories":["python-interview"],"content":"Список вопросов к Python собеседованию ","date":"23.08.2021","objectID":"/introspection-in-python/:0:0","series":null,"tags":["python"],"title":"Интроспекция в Python","uri":"/introspection-in-python/#"},{"categories":["python-interview"],"content":"Определение понятия интроспекции Интроспекция (introspection) в контексте объектно-ориентированных языков программирования — это возможность запросить тип и структуру объекта во время выполнения программы. Среди языков, поддерживающих интроспекцию — C++ (с RTTI), Go, Java, Kotlin, JavaScript, Perl, Ruby, Smalltalk, PHP и Python. В PHP и Python интроспекция интегрирована в сам язык. В Python интроспекция может быть функционально реализована с помощью: встроенных методов dir(), type(), isinstance(), hasattr(), id(); встроенного модуля inspect; идти непосредственно от имени объекта с помощью встроенных аттрибутов __class__ и __dict__. Пользоваться интроспекцией в Python особенно удобно, благодаря парадигме, что “всё является объектом”. Любая сущность, являясь объектом, имеет метаданные (данные об объекте), называемые аттрибутами, и связаные с этой сущностью функциональности, называемые методами. В Python новый класс по-умолчанию является сам по себе объектом метакласса type. Наиболее часто используемые функции интроспекции в Python: ","date":"23.08.2021","objectID":"/introspection-in-python/:1:0","series":null,"tags":["python"],"title":"Интроспекция в Python","uri":"/introspection-in-python/#определение-понятия-интроспекции"},{"categories":["python-interview"],"content":"dir() Предоставляет список атрибутов и методов, доступных для указанного объекта, который может быть объявленной переменной или функцией. Возвращаемое значение это отсортированный в алфавитном порядке список. При вызове функции dir() без аргумента она возвращает имена, доступные в локальной области видимости. a = [1, 2, 3] dir(a) # ['__add__', '__class__', '__contains__', ... , 'sort'] ","date":"23.08.2021","objectID":"/introspection-in-python/:2:0","series":null,"tags":["python"],"title":"Интроспекция в Python","uri":"/introspection-in-python/#dir"},{"categories":["python-interview"],"content":"type() Возвращает тип объекта, который может быть примитивным типом данных, объектом, классом или модулем. Можно напрямую сравнить возвращаемое значение с типом, который мы хотим проверить, используя == или is. type(8.7) # \u003cclass 'float'\u003e type(\"test\") == int # False type((7, 5,)) is tuple # True ","date":"23.08.2021","objectID":"/introspection-in-python/:3:0","series":null,"tags":["python"],"title":"Интроспекция в Python","uri":"/introspection-in-python/#type"},{"categories":["python-interview"],"content":"isinstance() Позволяет определить, является ли определенный объект экземпляром указанного класса. isinstance() может принимать кортеж в качестве второго аргумента, isinstance([1,2], list) # True isinstance([1,2], tuple) # False isinstance(1, (int, float, tuple)) # True type() vs isinstance() При использовании type() проводится сравнение один к одному. По сути, мы сравниваем тип объекта с типом, который мы указали, чтобы проверить, совпадают ли они. isinstance() является более гибкой функцией. Фактически она определяет, является ли объект экземпляром указанного класса (классов) или его подкласса. Для isinstance() экземпляр подкласса также является экземпляром базового класса. Другими словами, она сравнивает объект со списком потенциально релевантных классов, что является своего рода сравнением один к нескольким. ","date":"23.08.2021","objectID":"/introspection-in-python/:4:0","series":null,"tags":["python"],"title":"Интроспекция в Python","uri":"/introspection-in-python/#isinstance"},{"categories":["python-interview"],"content":"hasattr() Функция hasattr() проверяет существование атрибута с именем name в объекте object. Возвращает True, если атрибут существует, иначе False. Реализация функция hasattr() основывается на вызове функции getattr() с последующей проверкой на предмет брошенного ей исключения AttributeError. x = ('one', 'two', 'boom') hasattr(x, 'some_attr') # False hasattr(x, 'count') # True ","date":"23.08.2021","objectID":"/introspection-in-python/:5:0","series":null,"tags":["python"],"title":"Интроспекция в Python","uri":"/introspection-in-python/#hasattr"},{"categories":["python-interview"],"content":"id() Функция id() возвращает уникальный идентификатор для указанного объекта. x = ('one', 'two', 'boom') id(x) # 140575915669688 В CPython идентификатор объекта — это адрес объекта в памяти. Все объекты в Python имеют свой уникальный идентификатор. Идентификатор присваивается объекту при его создании. Идентификатор является адресом памяти объекта и будет отличаться при каждом запуске программы. Объекты могут иметь одинаковый идентификатор, если периоды их существования не пересекаются. Некоторые объекты могут иметь один и тот же идентификатор, например: мелкие целые от -5 до 256, True и False. ","date":"23.08.2021","objectID":"/introspection-in-python/:6:0","series":null,"tags":["python"],"title":"Интроспекция в Python","uri":"/introspection-in-python/#id"},{"categories":["python-interview"],"content":"Модуль inspect Модуль inspect также предоставляет несколько полезных функций для получения информации об объектах. Например, можно проверить элементы объекта: import inspect print(inspect.getmembers(str)) # Output: [('__add__', \u003cslot wrapper '__add__' of ... ... Источники: Wiki Интроспекция в Python ","date":"23.08.2021","objectID":"/introspection-in-python/:7:0","series":null,"tags":["python"],"title":"Интроспекция в Python","uri":"/introspection-in-python/#модуль-inspect"},{"categories":["python-interview"],"content":"Понятие программной инженерии и процесса разработки ПО","date":"19.07.2021","objectID":"/software-engineering-and-development-process/","series":null,"tags":["base"],"title":"Понятие программной инженерии и процесса разработки ПО","uri":"/software-engineering-and-development-process/"},{"categories":["python-interview"],"content":"Список вопросов к Python собеседованию ","date":"19.07.2021","objectID":"/software-engineering-and-development-process/:0:0","series":null,"tags":["base"],"title":"Понятие программной инженерии и процесса разработки ПО","uri":"/software-engineering-and-development-process/#"},{"categories":["python-interview"],"content":"Кризис программного обеспечения В 1968 году на конференции НАТО «Инженерия программного обеспечения» Фридрихом Л. Бауэром был введен термин «кризис программного обеспечения». Проявления кризиса: Стоимость проектов превышает бюджет. В проектах превышаются сроки выполнения. Программное обеспечение было слишком неэффективным. Программное обеспечение имело слишком низкое качество. Программное обеспечение зачастую не отвечало необходимым требованиям. Трудности с поддержкой кода. ПО было непригодным для распространения. ","date":"19.07.2021","objectID":"/software-engineering-and-development-process/:1:0","series":null,"tags":["base"],"title":"Понятие программной инженерии и процесса разработки ПО","uri":"/software-engineering-and-development-process/#кризис-программного-обеспечения"},{"categories":["python-interview"],"content":"Программная инженерия На той же конференции был введен и термин «программная инженерия». С тех пор это переросло в профессию инженера-программиста (англ. software engineer) и область исследований, посвящённых созданию программного обеспечения, более качественного, доступного, лучше поддерживаемого и быстрее разрабатываемого. Программная инженерия (англ. software engineering) - виды деятельности, выполняемые в процессе промышленного программирования и необходимые для успешного выполнения заказов. В сферу программной инженерии попадают все вопросы и темы, связанные с организацией и улучшением процесса разработки ПО, управлением коллектива разработчиков, разработкой и внедрением программных средств поддержки жизненного цикла разработки ПО. ","date":"19.07.2021","objectID":"/software-engineering-and-development-process/:2:0","series":null,"tags":["base"],"title":"Понятие программной инженерии и процесса разработки ПО","uri":"/software-engineering-and-development-process/#программная-инженерия"},{"categories":["python-interview"],"content":"Процесс разработки ПО Процесс разработки программного обеспечения (англ. software development process) — процесс, посредством которого потребности пользователей преобразуются в программный продукт. Процесс разработки программного обеспечения является составной частью программной инженерии. Процесс разработки состоит из множества подпроцессов: Анализ требований → Спецификация программного обеспечения Проектирование программного обеспечения Программирование Тестирование программного обеспечения Системная интеграция (System integration) Внедрение программного обеспечения Сопровождение программного обеспечения Модели процесса: Водопадная (каскадная, последовательная) модель (англ. waterfall model) Итерационная модель Спиральная модель «Серебряной пули нет» На сегодняшний день не существует универсального процесса разработки ПО - набора методик, правил и предписаний, подходящих для ПО любого вида, для любых компаний, для команд любой национальности. Источники: Подробная статья ","date":"19.07.2021","objectID":"/software-engineering-and-development-process/:3:0","series":null,"tags":["base"],"title":"Понятие программной инженерии и процесса разработки ПО","uri":"/software-engineering-and-development-process/#процесс-разработки-по"},{"categories":null,"content":"Основные шаги по настройке VPS с Ubuntu 20.04 для деплоя проекта. Установка Docker и Docker Compose, настройка UFW.","date":"07.06.2021","objectID":"/ubuntu-setup-for-python-stack/","series":null,"tags":["linux"],"title":"Настройка Ubuntu 20.04 для развертывания проекта в Docker","uri":"/ubuntu-setup-for-python-stack/"},{"categories":null,"content":"У нас имеется VPS с Ubuntu 20.04, нужно настроить его для развертывания проекта. ","date":"07.06.2021","objectID":"/ubuntu-setup-for-python-stack/:0:0","series":null,"tags":["linux"],"title":"Настройка Ubuntu 20.04 для развертывания проекта в Docker","uri":"/ubuntu-setup-for-python-stack/#"},{"categories":null,"content":"Первые шаги # Обновим apt update \u0026\u0026 sudo apt upgrade -y # Создаем нового юзера adduser www \u0026\u0026 usermod -aG sudo www # password for sudo - off sudo visudo # %sudo ALL=(ALL:ALL) NOPASSWD:ALL Выходим с сервера и копируем ssh-key ssh-copy-id www@ip Заходим под пользователем www и продолжаем настройку. Отключим возможность заходить под root, а так же возможность логиниться по паролю:1 sudo vim /etc/ssh/sshd_config # Ищем и исправляем следующие строки: # AllowUsers www # PermitRootLogin no # PasswordAuthentication no sudo systemctl restart sshd ","date":"07.06.2021","objectID":"/ubuntu-setup-for-python-stack/:1:0","series":null,"tags":["linux"],"title":"Настройка Ubuntu 20.04 для развертывания проекта в Docker","uri":"/ubuntu-setup-for-python-stack/#первые-шаги"},{"categories":null,"content":"Настройка UFW Настроим фаервол UFW:2 sudo ufw allow OpenSSH \u0026\u0026 sudo ufw allow http \u0026\u0026 sudo ufw allow https sudo ufw enable sudo ufw status ","date":"07.06.2021","objectID":"/ubuntu-setup-for-python-stack/:2:0","series":null,"tags":["linux"],"title":"Настройка Ubuntu 20.04 для развертывания проекта в Docker","uri":"/ubuntu-setup-for-python-stack/#настройка-ufw"},{"categories":null,"content":"zsh + Oh-My-zsh Установим zsh и Oh-My-zsh и настроим тему powerlevel10k: sudo apt install zsh -y # reconnect sh -c \"$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\" git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/themes/powerlevel10k vim ~/.zshrc # ZSH_THEME=\"powerlevel10k/powerlevel10k\" # alias cls=\"clear\" source ~/.zshrc ","date":"07.06.2021","objectID":"/ubuntu-setup-for-python-stack/:3:0","series":null,"tags":["linux"],"title":"Настройка Ubuntu 20.04 для развертывания проекта в Docker","uri":"/ubuntu-setup-for-python-stack/#zsh--oh-my-zsh"},{"categories":null,"content":"Установка Docker и Docker Compose Следующий шаг - установка Docker и Docker Compose3 sudo apt install apt-transport-https ca-certificates curl software-properties-common -y curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - sudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu focal stable\" sudo apt update apt-cache policy docker-ce sudo apt install docker-ce -y sudo systemctl status docker sudo usermod -aG docker ${USER} # Релогин id -nG Установка Docker Compose4 Свежий релиз Docker Compose sudo curl -L \"https://github.com/docker/compose/releases/download/v2.2.3/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose docker-compose --version ","date":"07.06.2021","objectID":"/ubuntu-setup-for-python-stack/:4:0","series":null,"tags":["linux"],"title":"Настройка Ubuntu 20.04 для развертывания проекта в Docker","uri":"/ubuntu-setup-for-python-stack/#установка-docker-и-docker-compose"},{"categories":null,"content":"Полезные утилиты # Free disk space df -h -t ext4 # process top # free memory free -h Настройка ключей SSH в Ubuntu 20.04 ↩︎ UFW Essentials: Common Firewall Rules and Commands ↩︎ Установка и использование Docker в Ubuntu 20.04 ↩︎ Установка и использование Docker Compose в Ubuntu 20.04 ↩︎ ","date":"07.06.2021","objectID":"/ubuntu-setup-for-python-stack/:5:0","series":null,"tags":["linux"],"title":"Настройка Ubuntu 20.04 для развертывания проекта в Docker","uri":"/ubuntu-setup-for-python-stack/#полезные-утилиты"},{"categories":["notes"],"content":"PostgresSQL CLI command cheatsheet","date":"21.05.2021","objectID":"/postgres-cli-commands/","series":null,"tags":["postgres","db"],"title":"PostgresSQL CLI command cheatsheet","uri":"/postgres-cli-commands/"},{"categories":["notes"],"content":"Connect to PostgreSQL database # connects to a database under a specific user psql -d database -U user -W # connect to a database that resides on another host psql -h host -d database -U user -W # use SSL mode for the connection psql -U user -h host \"dbname=db sslmode=require\" \\du – список пользователей \\dp (или \\z) – список таблиц, представлений, последовательностей, прав доступа к ним \\di – индексы \\ds – последовательности \\dt – список таблиц \\dt+ — список всех таблиц с описанием \\dt s — список всех таблиц, содержащих s в имени \\dv – представления \\dS – системные таблицы \\d+ – описание таблицы \\o – пересылка результатов запроса в файл \\l – список баз данных \\i – читать входящие данные из файла \\e – открывает текущее содержимое буфера запроса в редакторе (если иное не указано в окружении переменной EDITOR, то будет использоваться по умолчанию vi) \\d “table_name” – описание таблицы \\i запуск команды из внешнего файла, например \\i /my/directory/my.sql \\pset – команда настройки параметров форматирования \\echo – выводит сообщение \\set – устанавливает значение переменной среды. Без параметров выводит список текущих переменных (\\unset – удаляет) ? – справочник psql \\help – справочник SQL \\q (или Ctrl+D) – выход из программы \\timing - Turn on query execution time ","date":"21.05.2021","objectID":"/postgres-cli-commands/:0:0","series":null,"tags":["postgres","db"],"title":"PostgresSQL CLI command cheatsheet","uri":"/postgres-cli-commands/#"},{"categories":["notes"],"content":"Just badges","date":"18.04.2021","objectID":"/github-badges/","series":null,"tags":["github"],"title":"GitHub badges","uri":"/github-badges/"},{"categories":["notes"],"content":"Подробнее на странице автора1 ","date":"18.04.2021","objectID":"/github-badges/:0:0","series":null,"tags":["github"],"title":"GitHub badges","uri":"/github-badges/#"},{"categories":["notes"],"content":"GitHub stats \u003cimg src=\"https://github-readme-stats.vercel.app/api?username=baikov\u0026count_private=true\u0026hide_title=true\u0026hide=issues,contribs\u0026show_icons=true\u0026theme=calm\u0026text_color=#fff\u0026icon_color=#e31e25\u0026border_color=#e31e25\"\u003e ","date":"18.04.2021","objectID":"/github-badges/:1:0","series":null,"tags":["github"],"title":"GitHub badges","uri":"/github-badges/#github-stats"},{"categories":["notes"],"content":"Repo info \u003ca href=\"https://github.com/baikov/allflags\"\u003e \u003cimg src=\"https://github-readme-stats.vercel.app/api/pin/?username=baikov\u0026repo=traefik-prometheus\u0026theme=calm\u0026border_color=#e31e25\" /\u003e \u003c/a\u003e \u003ca href=\"https://github.com/baikov/allflags\"\u003e \u003cimg src=\"https://github-readme-stats.vercel.app/api/pin/?username=baikov\u0026repo=allflags\u0026border_color=#e31e25\u0026text_color=#ffffff\u0026title_color=#ffffff\" /\u003e \u003c/a\u003e ","date":"18.04.2021","objectID":"/github-badges/:2:0","series":null,"tags":["github"],"title":"GitHub badges","uri":"/github-badges/#repo-info"},{"categories":["notes"],"content":"Github top langs \u003cimg id=\"elem\" src=\"https://github-readme-stats.vercel.app/api/top-langs/?username=baikov\" /\u003e ","date":"18.04.2021","objectID":"/github-badges/:3:0","series":null,"tags":["github"],"title":"GitHub badges","uri":"/github-badges/#github-top-langs"},{"categories":["notes"],"content":"GitHub activity \u003cimg id=\"elem\" src=\"https://ghchart.rshah.org/e31e25/baikov\" /\u003e GitHub Readme Stats ↩︎ ","date":"18.04.2021","objectID":"/github-badges/:4:0","series":null,"tags":["github"],"title":"GitHub badges","uri":"/github-badges/#github-activity"},{"categories":["notes"],"content":"Django Cookiecutter commands","date":"15.03.2021","objectID":"/cookiecutter-commands/","series":null,"tags":["django"],"title":"[Шпаргалка] Django Cookiecutter commands","uri":"/cookiecutter-commands/"},{"categories":["notes"],"content":" pip install \"cookiecutter\u003e=1.7.0\" sudo docker-compose -f production.yml build sudo docker-compose -f production.yml down sudo docker-compose -f production.yml up -d sudo docker-compose -f production.yml run --rm django python manage.py migrate sudo docker-compose -f production.yml logs sudo docker-compose -f production.yml run --rm django python manage.py shell -i ipython docker-compose -f local.yml run --rm django python manage.py shell -i ipython from app.utils.import_countries import create_countries # Create db backup docker-compose -f local.yml exec postgres backup docker-compose -f production.yml exec postgres backup # DB backup list docker-compose -f local.yml exec postgres backups docker-compose -f production.yml exec postgres backups # Copy backup from docker to local (postgres - is container name) docker cp postgres:/backups . # Copy backup to docker docker cp backup_2021_09_10T09_23_12.sql.gz postgres:/backups docker cp ./backups/backup_2021_08_10T13_40_02.sql.gz allflags_postgres_1:/backups # Restoring from the Existing Backup docker-compose -f local.yml exec postgres restore backup_2021_09_10T09_23_12.sql.gz docker-compose -f production.yml exec postgres restore backup_2021_08_10T13_40_02.sql.gz ","date":"15.03.2021","objectID":"/cookiecutter-commands/:0:0","series":null,"tags":["django"],"title":"[Шпаргалка] Django Cookiecutter commands","uri":"/cookiecutter-commands/#"},{"categories":["python-interview"],"content":"Парадигма программирования — это совокупность идей и понятий, определяющих стиль написания компьютерных программ. Это способ концептуализации, определяющий организацию вычислений и структурирование работы, выполняемой компьютером.","date":"11.02.2021","objectID":"/programming-paradigms/","series":null,"tags":["base"],"title":"Парадигмы программирования - список и краткие описания","uri":"/programming-paradigms/"},{"categories":["python-interview"],"content":"Список вопросов к Python собеседованию Источники: Подробная статья ","date":"11.02.2021","objectID":"/programming-paradigms/:0:0","series":null,"tags":["base"],"title":"Парадигмы программирования - список и краткие описания","uri":"/programming-paradigms/#"},{"categories":["python-interview","algorithms"],"content":"Алгоритмы","date":"08.02.2021","objectID":"/algorithms/","series":null,"tags":null,"title":"Алгоритмы","uri":"/algorithms/"},{"categories":["python-interview","algorithms"],"content":"Список вопросов к Python собеседованию ","date":"08.02.2021","objectID":"/algorithms/:0:0","series":null,"tags":null,"title":"Алгоритмы","uri":"/algorithms/#"},{"categories":["python-interview","algorithms"],"content":"Время выполения алгоритма («О-большое») На самом деле, существует не только «большое О», но и ряд других обозначений: O(ƒ(n)) – (Big-O) – верхняя граница, «не хуже чем»; o(ƒ(n)) – (Little-o) – верхняя граница, «лучше чем»; Ω(ƒ(n)) – (Omega) – нижняя граница, «не лучше чем»; Θ(ƒ(n)) – (Theta) – точная оценка. Наиболее часто встречающиеся оценки: О(1) - константное время (получение одного элемента в массиве) O(log n) - логарифмическое время (бинарный поиск). О(n) - линейное время (простой поиск). О(n*log n) - линейно-логарифмическое время (эффективные алгоритмы сортировки, напр. быстрая сортировка). О(n2) - квадратичное время (медленные алгоритмы сортировки: сортировка выбо­ром). О(n3) - кубическое время (Обычное умножение двух n на n матриц). О(n!) - очень медленные алгоритмы (задача о коммивояжере полным перебором). Сложность алгоритмов\" Сложность алгоритмов Скорость алгоритмов измеряется не в секундах, а в темпе роста количе­ ства операций.1 В некоторых случаях константа может иметь значение Один из примеров такого рода - быстрая сортировка и сортировка слиянием. У бы­строй сортировки константа меньше, чем у сортировки слиянием, поэтому, несмотря на то что оба алгоритма характеризуются временем О(n*log n), быстрая сортировка работает быстрее. А на практике быстрая сортировка работает быстрее, потому что средний случай встречается намного чаще худшего. ","date":"08.02.2021","objectID":"/algorithms/:1:0","series":null,"tags":null,"title":"Алгоритмы","uri":"/algorithms/#время-выполения-алгоритма-о-большое"},{"categories":["python-interview","algorithms"],"content":"Бинарный поиск Бинарный поиск - на входе получает отсортированный список элементов. Если искомый элемент присутствует в списке - возвращает его позицию. В противном слу­чае возвращает null. Time Complexities Best case complexity: O(1) Average case complexity: O(log n) Worst case complexity: O(log n) The space complexity of the binary search is O(1). def binary_search(arr: List[int], elem: int) -\u003e Union[int, None]: low = 0 high = len(arr) - 1 while low \u003c= high: mid = (low + high) // 2 guess = arr[mid] if guess == elem: return mid elif guess \u003e elem: high = mid - 1 else: low = mid + 1 return None More ","date":"08.02.2021","objectID":"/algorithms/:2:0","series":null,"tags":null,"title":"Алгоритмы","uri":"/algorithms/#бинарный-поиск"},{"categories":["python-interview","algorithms"],"content":"Сортировка выбором Наиболее простая, но медленная сортировка. Сложность О(n2). def search_min(arr: List) -\u003e int: min_index = 0 for i in range(len(arr) - 1): if arr[min_index] \u003e arr[i]: min_index = i return min_index def selection_sort(arr: List) -\u003e List: result = [] copy = arr[:] while len(copy) \u003e 0: min_index = search_min(copy) result.append(copy.pop(min_index)) return result More ","date":"08.02.2021","objectID":"/algorithms/:3:0","series":null,"tags":null,"title":"Алгоритмы","uri":"/algorithms/#сортировка-выбором"},{"categories":["python-interview","algorithms"],"content":"Рекурсия Рекурсия - это такой способ организации обработки данных, при котором программа вызывает сама себя непосредственно, либо с помощью других программ. Примеры в реальной жизни: эффект Дросте, треугольник Серпинского. Любой алгоритм, реализованный в рекурсивной форме, может быть переписан в итерационном виде и наоборот. Рекурсивная функция состоит из: Условие остановки / Базовый случай Условие продолжения / Шаг рекурсии — способ сведения задачи к более простым. Рекурсивные функции используют стек вызовов, где каждый вызов создает собственную копию переменной. Обратиться к переменной, принадлежащей другому уровню, невозможно. Стек — абстрактный тип данных, представляющий собой список элементов, организованных по принципу LIFO (last in — first out). В Python стеком можно назвать любой список, так как для них доступны операции pop и push. В интерпретаторе Python (CPython) есть защита от переполнения стека. Достигнув лимита глубины интерпретатор выдаст ошибку RecursionError: maximum recursion depth exceeded in comparison Лимит глубины рекурсии можно узнать при помощи функции sys.getrecursionlimit, а изменить этот лимит при помощи sys.setrecursionlimit: import sys print(sys.getrecursionlimit()) # 997 sys.setrecursionlimit(1500) Увеличение лимита рекурсии может привести к переполнению стека, поэтому лучше переписать алгоритм итеративно. Если в гугле ввести слово “рекурсия”, то он наряду с результатми поиска выдаст «возможно, вы имели в виду “рекурсия”» :-) ","date":"08.02.2021","objectID":"/algorithms/:4:0","series":null,"tags":null,"title":"Алгоритмы","uri":"/algorithms/#рекурсия"},{"categories":["python-interview","algorithms"],"content":"Быстрая сортировка Быстродействие быстрой сортировки сильно зависит от выбора опорного элемента. Быстрая сортировка О-большое\" Быстрая сортировка О-большое Лучший сценарий: O(n*log n) (он же средний) - когда пограничным элементом выбирается средний, или ближайший к середине. Худший сценарий: O(n2) - это происходит в случае, если за пограничный элемент берется первый или последний элемент массива. from typing import List from random import randint # top answer on stackoveflow def quick_sort(arr: List) -\u003e List: less = [] equal = [] greater = [] if len(arr) \u003e 1: pivot = arr[0] # pivot = arr[len(arr) // 2] # pivot = randint(0, len(arr) - 1) for elem in arr: if elem \u003c pivot: less.append(elem) elif elem == pivot: equal.append(elem) else: greater.append(elem) return quick_sort(less) + equal + quick_sort(greater) else: return arr # В одну строку =) def qsort_one_line_mid(arr: List) -\u003e List: return ( arr if len(arr) \u003c 2 else qsort([val for val in arr if val \u003c arr[len(arr) // 2]]) + [arr[len(arr) // 2]] * arr.count(arr[len(arr) // 2]) + qsort([val for val in arr if val \u003e arr[len(arr) // 2]]) ) Существует параллельная версия быстрой сор­ тировки, которая сортирует массив за время О(n). More ","date":"08.02.2021","objectID":"/algorithms/:5:0","series":null,"tags":null,"title":"Алгоритмы","uri":"/algorithms/#быстрая-сортировка"},{"categories":["python-interview","algorithms"],"content":"Хеш-таблицы aka «ассоциативные массивы», «словари», «отображения», «хеш­ карты», «хеши» В научной терминологии говорят, что хеш-функция «отображает строки на числа». Хеш-функция должна соответствовать некоторым требованиям: Быть последовательной Разным строкам должны соответствовать разные числа Коллизии Существует много разных стратегий обработки коллизий. Простейшая из них выглядит так: если несколько ключей отображаются на один элемент, в этом элементе создается связанный список. выбор хеш-функции действительно важен. Хеш-функция, отображаю­ щая все ключи на один элемент массива, никуда не годится. В идеале хеш-функция должна распределять ключи равномерно по всему хешу; если связанные списки становятся слишком длинными, работа с хеш- таблицей сильно замедляется. Но они не станут слишком длинными при использовании хорошей хеш-функции! ","date":"08.02.2021","objectID":"/algorithms/:6:0","series":null,"tags":null,"title":"Алгоритмы","uri":"/algorithms/#хеш-таблицы"},{"categories":["python-interview","algorithms"],"content":"Поиск в ширину (BFS, Breadth-First Search) BFS - это алгоритм для решения задачи поиска кратчайшего пути. BFS помогает ответить на вопросы двух типов: тип 1: существует ли путь от узла А к узлу В? тип 2: как выглядит кратчайший путь от узла А к узлу В (нахо­дит путь с минимальным количеством сегментов)? Поиск в ширину выполняется за время O(V+E) ( V - количество вершин,Е - количество ребер). import collections def bfs(graph, root): visited, queue = set(), collections.deque([root]) visited.add(root) while queue: vertex = queue.popleft() for neighbour in graph[vertex]: if neighbour not in visited: visited.add(neighbour) queue.append(neighbour) BFS - это жадный алгоритм. ","date":"08.02.2021","objectID":"/algorithms/:7:0","series":null,"tags":null,"title":"Алгоритмы","uri":"/algorithms/#поиск-в-ширину-bfs-breadth-first-search"},{"categories":["python-interview","algorithms"],"content":"Алгоритм Дейкстры Алгоритм Дейкстры - алгоритм на графах, изобретённый нидерландским учёным Эдсгером Дейкстрой в 1959 году. Находит кратчайшие пути от одной из вершин графа до всех остальных. Алгоритм работает только для графов без рёбер отрицательного веса.2 Для графов с отрицательными весами - алгоритм Беллмана-Форда. Ал­горитм Дейкстры работает только с направленными ациклическими графами, которые нередко обозначаются сокращением DAG (Directed Acyclic Graph). Алгоритм Дейкстры состоит из четырех шагов: Найти узел с наименьшей стоимостью (то есть узел, до которого можно добраться за минимальное время). Проверить, существует ли более дешевый путь к соседям этого узла, и если существует, обновить их стоимости. Повторять, пока это не будет сделано для всех узлов графа. Вычислить итоговый путь. Алгоритм Дейкстры - это жадный алгоритм. Свести задачу к решаемой BFS можно, но если заменить все рёбра неединичной длины n рёбрами длины 1, то граф очень разрастётся, и это приведёт к огромному числу действий при вычислении оптимального маршрута. Условие неотрицательности весов рёбер крайне важно и от него нельзя просто избавиться. Не получится свести задачу к решаемой алгоритмом Дейкстры, прибавив наибольший по модулю вес ко всем рёбрам. Это может изменить оптимальный маршрут. Попытка избавиться от отрицательных весов\" Попытка избавиться от отрицательных весов В оригинале путь проходит через a -\u003e b -\u003e c -\u003e d, а после добавления семёрки ко всем рёбрам, оптимальный путь проходит через a -\u003e c -\u003e d. Эффективная реализация предполагает использование кучи. Статья с кодом Статья на Хабре ","date":"08.02.2021","objectID":"/algorithms/:8:0","series":null,"tags":null,"title":"Алгоритмы","uri":"/algorithms/#алгоритм-дейкстры"},{"categories":["python-interview","algorithms"],"content":"Жадные алгоритмы Жадный алгоритм прост: на каж­дом шаге он выбирает оптимальный вариант. В техни­ческой терминологии: на каждом шаге выбирается локально-оптимальное решение, а в итоге мы получаем глобально-оптимальное решение. Иногда идеальное - враг хорошего. В некоторых случаях достаточно алгоритма, способного решить задачу достаточно хорошо. И в таких областях жадные алгоритмы работают просто отлично, потому что они просто реализуются, а получен­ное решение обычно близко к оптимуму. Когда вычисление точного реше­ния занимает слишком много времени, применяется приближенный алго­ритм. Эффективность приближенного алгоритма оценивается по быстроте и близости полученного решения к оптимальному. ","date":"08.02.2021","objectID":"/algorithms/:9:0","series":null,"tags":null,"title":"Алгоритмы","uri":"/algorithms/#жадные-алгоритмы"},{"categories":["python-interview","algorithms"],"content":"NP-полные задачи Задача о коммивояжере и задача покрытия множества Не существует простого способа определить, является ли задача, с которой вы работаете, NР-полной. Несколько характерных признаков: алгоритм быстро работает при малом количестве элементов, но сильно замедляется при увеличении их числа; формулировка «все комбинации х» часто указывает на NР-полноту за­дачи; приходится вычислять все возможные варианты Х, потому что за­дачу невозможно разбить на меньшие подзадачи? Такая задача может оказаться NР-полной; если в задаче встречается некоторая последовательность (например, последовательность городов, как в задаче о коммивояжере) и задача не имеет простого решения, она может оказаться NР-полной; если в задаче встречается некоторое множество и задача не имеет простого решения, она может оказаться NР-полной; можно ли переформулировать задачу в условиях задачи покрытия множества или задачи о коммивояжере? В таком случае задача определенно является NР-полной. У NР-полных задач не существует известных быстрых решений. ","date":"08.02.2021","objectID":"/algorithms/:10:0","series":null,"tags":null,"title":"Алгоритмы","uri":"/algorithms/#np-полные-задачи"},{"categories":["python-interview","algorithms"],"content":"Динамическое программирование Динамическое программирование применяется при оптимизации не­ которой характеристики. Динамическое программирование работает только в ситуациях, в кото­рых задача может быть разбита на автономные подзадачи. В каждом решении из области динамического программирования стро­ится таблица. Значения ячеек таблицы обычно соответствуют оптимизируемой харак­теристике. Каждая ячейка представляет подзадачу, поэтому нужно думать о том, как разбить задачу на подзадачи. Не существует единой формулы для вычисления решений методом ди­намического программирования. Расстояние Левенштейна оцени­вает, насколько похожи две строки , а для его вычисления применяется динамическое программирование. ","date":"08.02.2021","objectID":"/algorithms/:11:0","series":null,"tags":null,"title":"Алгоритмы","uri":"/algorithms/#динамическое-программирование"},{"categories":["python-interview","algorithms"],"content":"Алгоритм Фейнмана Алгоритм Фейнмана, названный по имени известного физика Ричарда Фейнмана, работает так: Записать формулировку задачи. Хорошенько подумать. Записать решение. ","date":"08.02.2021","objectID":"/algorithms/:12:0","series":null,"tags":null,"title":"Алгоритмы","uri":"/algorithms/#алгоритм-фейнмана"},{"categories":["python-interview","algorithms"],"content":"Алгоритм k ближайших соседей Алгоритм k ближайших соседей применяется для классификации и ре­грессии. В нем используется проверка k ближайших соседей. Классификация = распределение по категориям. Регрессия = прогнозирование результата. «Извлечением признаков» называется преобразование элемента в список чисел, которые могут ис­пользоваться для сравнения. Качественный выбор признаков - важная часть успешного алгоритма k ближайших соседей. ","date":"08.02.2021","objectID":"/algorithms/:13:0","series":null,"tags":null,"title":"Алгоритмы","uri":"/algorithms/#алгоритм-k-ближайших-соседей"},{"categories":["python-interview","algorithms"],"content":"Преобразование Фурье ","date":"08.02.2021","objectID":"/algorithms/:14:0","series":null,"tags":null,"title":"Алгоритмы","uri":"/algorithms/#преобразование-фурье"},{"categories":["python-interview","algorithms"],"content":"Фильтры Блума и Hyperloglog ","date":"08.02.2021","objectID":"/algorithms/:15:0","series":null,"tags":null,"title":"Алгоритмы","uri":"/algorithms/#фильтры-блума-и-hyperloglog"},{"categories":["python-interview","algorithms"],"content":"Параллельные алгоритмы ","date":"08.02.2021","objectID":"/algorithms/:16:0","series":null,"tags":null,"title":"Алгоритмы","uri":"/algorithms/#параллельные-алгоритмы"},{"categories":["python-interview","algorithms"],"content":"Распределенные алгоритмы ","date":"08.02.2021","objectID":"/algorithms/:17:0","series":null,"tags":null,"title":"Алгоритмы","uri":"/algorithms/#распределенные-алгоритмы"},{"categories":["python-interview","algorithms"],"content":"Алгоритмы SHA ","date":"08.02.2021","objectID":"/algorithms/:18:0","series":null,"tags":null,"title":"Алгоритмы","uri":"/algorithms/#алгоритмы-sha"},{"categories":["python-interview","algorithms"],"content":"Алгоритм Диффи-Хеллмана ","date":"08.02.2021","objectID":"/algorithms/:19:0","series":null,"tags":null,"title":"Алгоритмы","uri":"/algorithms/#алгоритм-диффи-хеллмана"},{"categories":["python-interview","algorithms"],"content":"Линейное программирование Направленный / ненаправленный граф Взвешенный / невзвешенный граф Дерево в-деревья; красно-черные деревья; кучи; скошенные (splay) деревья. О-большое (Wiki) ↩︎ Алгоритм Дейкстры ↩︎ ","date":"08.02.2021","objectID":"/algorithms/:20:0","series":null,"tags":null,"title":"Алгоритмы","uri":"/algorithms/#линейное-программирование"},{"categories":["python-interview"],"content":"Подчеркивание (underscore) в Python используется: в именах объектов, в интерпретаторе, при игнорировании значений, в функционале локализации и для разделения цифр в числах. Двойное подчеркивание (dunder) только в именах объектов.","date":"14.11.2020","objectID":"/underscore-in-python/","series":null,"tags":["python"],"title":"Символ подчеркивания в Python - использование Underscores и Dunders","uri":"/underscore-in-python/"},{"categories":["python-interview"],"content":"Список вопросов к Python собеседованию ","date":"14.11.2020","objectID":"/underscore-in-python/:0:0","series":null,"tags":["python"],"title":"Символ подчеркивания в Python - использование Underscores и Dunders","uri":"/underscore-in-python/#"},{"categories":["python-interview"],"content":"Подчеркивание в именах объектов Наиболее простой и очевидный способ применения подчеркивания - это разделение слов в именах объектов: lower_case_with_underscores UPPER_CASE_WITH_UNDERSCORES Capitalized_Words_With_Underscores (ugly!)1 Одинарные и двойные подчеркивания в именах переменных и методов имеют определенное значение. Часть вариантов использования - это просто договоренность и предназначены как подсказка программисту, а часть используется интерпретатором Python:2 _single_leading_underscore: слабый показатель того, что объект (переменная, функция, метод, класс) предназначен для «внутреннего использования» - protected на словах. (Например, from M import * не импортирует объекты, имена которых начинаются с подчеркивания); single_trailing_underscore_: используется по соглашению, чтобы избежать конфликтов с ключевыми словами Python; __double_leading_underscore: такие имена трансформируются в формат «имя класса + имя метода/атрибута». Это позволяет создавать уникальные методы и атрибуты классов (внутри класса FooBar __boo становится _FooBar__boo). Это также называется “Name Mangling” - интерпретатор меняет имя переменной таким образом, что затрудняет создание коллизий при расширении класса позже.; __double_leading_and_trailing_underscore__: «магические» методы или атрибуты, которые живут в контролируемых пользователем пространствах имен. Например. __init__, __import__ или __file__. PEP 8 рекомендует никогда не придумывать таких имен, а использовать их только в соответствии с документацией.1 ","date":"14.11.2020","objectID":"/underscore-in-python/:1:0","series":null,"tags":["python"],"title":"Символ подчеркивания в Python - использование Underscores и Dunders","uri":"/underscore-in-python/#подчеркивание-в-именах-объектов"},{"categories":["python-interview"],"content":"Символ подчеркивания в интерпретаторе В интерпретаторе символ подчеркивания _ хранит результат последнего неошибочного действия, выведенного на экран, если он не был явно использован в качестве переменной. Это связано с тем, что sys.stdout экранируется с помощью displayhook. Пример из официальной документации: def displayhook(value): if value is None: return # Set '_' to None to avoid recursion builtins._ = None text = repr(value) try: sys.stdout.write(text) except UnicodeEncodeError: bytes = text.encode(sys.stdout.encoding, 'backslashreplace') if hasattr(sys.stdout, 'buffer'): sys.stdout.buffer.write(bytes) else: text = bytes.decode(sys.stdout.encoding, 'strict') sys.stdout.write(text) sys.stdout.write(\"\\n\") builtins._ = value ","date":"14.11.2020","objectID":"/underscore-in-python/:2:0","series":null,"tags":["python"],"title":"Символ подчеркивания в Python - использование Underscores и Dunders","uri":"/underscore-in-python/#символ-подчеркивания-в-интерпретаторе"},{"categories":["python-interview"],"content":"Подчеркивание для игнорирования значений Нижнее подчеркивание _ также используется для игнорирования ненужных нам значений.3 Игнорирование значения при распаковке x, _, y = (3, 7, 8) # x = 3, y = 8 Игнорирование нескольких значений - “Extended Unpacking” x, *_, y = (5, 7, 1, 8, 2) # x = 5, y = 2 Игнорирование индекса в цикле for _ in range(100): do_something() Игнорирование значения в определенной позиции for _, val in some_dict.items(): print(val) ","date":"14.11.2020","objectID":"/underscore-in-python/:3:0","series":null,"tags":["python"],"title":"Символ подчеркивания в Python - использование Underscores и Dunders","uri":"/underscore-in-python/#подчеркивание-для-игнорирования-значений"},{"categories":["python-interview"],"content":"Подчеркивание в i18n и l10n Сокращения i18n и l10n i18n - Internationalization: i(18 букв)n l10n - Localization: l(10 букв)n g11n - Globalization: g(11 букв)n l12y - Localizability: l(12 букв)y Пример использования из офф. документации4: import gettext gettext.bindtextdomain('myapplication','/path/to/my/language/directory') gettext.textdomain('myapplication') _ = gettext.gettext # ... print(_('This is a translatable string.')) Это просто соглашение, а не синтаксис функции. Этого соглашения придерживается и модуль gettext из встроенной стандартной библиотеки, и Django. ","date":"14.11.2020","objectID":"/underscore-in-python/:4:0","series":null,"tags":["python"],"title":"Символ подчеркивания в Python - использование Underscores и Dunders","uri":"/underscore-in-python/#подчеркивание-в-i18n-и-l10n"},{"categories":["python-interview"],"content":"Подчеркивание для разделения цифр Символ нижнего подчеркивания может использоваться для разделения цифр в больших числах. big_int = 2_000_000 # 2000000 hex_num = 0x_3212_ffff # 840105983 bin_num = 0b_1010_0111 # 167 PEP 8 - Descriptive: Naming Styles ↩︎ ↩︎ Dan Bader - The Meaning of Underscores in Python ↩︎ Understanding the underscore ( _ ) of Python ↩︎ Python Docs - gettext - Multilingual internationalization services ↩︎ ","date":"14.11.2020","objectID":"/underscore-in-python/:5:0","series":null,"tags":["python"],"title":"Символ подчеркивания в Python - использование Underscores и Dunders","uri":"/underscore-in-python/#подчеркивание-для-разделения-цифр"},{"categories":["notes"],"content":"Git commands","date":"09.11.2020","objectID":"/git-commands/","series":null,"tags":["git"],"title":"Git commands","uri":"/git-commands/"},{"categories":["notes"],"content":" git init git add . git commit -m 'Description' git commit -a -m 'Description' # коммитит все файлы, не требует выполнять add git rm \u003cfile\u003e # -f если файл уже в коммите git rm --cached \u003cfile\u003e # Удалить файл из индекса, оставив его при этом в рабочем каталоге git mv \u003cfile_from\u003e \u003cfile_to\u003e git status (-s --short) git reset HEAD \u003cfile\u003e git clone [url] git filter-branch --force --index-filter \\ \"git rm --cached --ignore-unmatch PATH-TO-YOUR-FILE-WITH-SENSITIVE-DATA\" \\ --prune-empty --tag-name-filter cat -- --all git push origin --force --all git push origin --force --tags # Branches git branch # Список веток git branch \u003cbranch_name\u003e git checkout \u003cbranch_name\u003e git checkout -b \u003cbranch_name\u003e # Предыдущие 2 команды в одну строку # Слияние с master git checkout master git merge \u003cbranch_name\u003e git branch -d \u003cbranch_name\u003e # Удаление ветки git remote -v # внешний репозиторий git remote add origin https://github.com/baikov/baikov.dev.git # Rename git branch -m \u003coldname\u003e \u003cnewname\u003e # If you want to rename the current branch, you can do: git branch -m \u003cnewname\u003e # If you want to push the local branch and reset the upstream branch: git push origin -u \u003cnewname\u003e # And finally if you want to Delete the remote branch: git push origin --delete \u003coldname\u003e ","date":"09.11.2020","objectID":"/git-commands/:0:0","series":null,"tags":["git"],"title":"Git commands","uri":"/git-commands/#"},{"categories":["python-interview"],"content":"Разница между операторами сравнения 'is' и '==' в Python в том, что оператор '==' проверяет равенство значений двух объектов, а оператор 'is' проверяет идентичность самих объектов. Его используют, чтобы удостовериться, что переменные указывают на один и тот же объект в памяти.","date":"01.10.2020","objectID":"/difference-between-is-and-equal-in-python/","series":null,"tags":["python"],"title":"В чем разница между операторами \"is\" и \"==\" в Python","uri":"/difference-between-is-and-equal-in-python/"},{"categories":["python-interview"],"content":"Список вопросов к Python собеседованию ","date":"01.10.2020","objectID":"/difference-between-is-and-equal-in-python/:0:0","series":null,"tags":["python"],"title":"В чем разница между операторами \"is\" и \"==\" в Python","uri":"/difference-between-is-and-equal-in-python/#"},{"categories":["python-interview"],"content":"Определение и особенности операторов сравнения оператор == проверяет равенство значений двух объектов; оператор is проверяет идентичность самих объектов. Его используют, чтобы удостовериться, что переменные указывают на один и тот же объект в памяти. Два объекта, имеющие одинаковые значения, не обязательно идентичны. Python (CPython, если быть точнее) в целях производительности кеширует короткие строки и малые целые числа. Подробнее тут - “What the f*ck Python!”.1 Под целые числа из диапазона от -5 до 256 включительно интерпретатор заранее выделяет место в памяти и даёт переменным ссылки на эти объекты, поэтому возможны такие казусы: str1 = 'hello' str2 = 'hello' str1 == str2 # True str1 is str2 # True Оператор is - это в общем-то “синтаксический сахар”: a is b по факту обертка для id(a) == id(b) ","date":"01.10.2020","objectID":"/difference-between-is-and-equal-in-python/:1:0","series":null,"tags":["python"],"title":"В чем разница между операторами \"is\" и \"==\" в Python","uri":"/difference-between-is-and-equal-in-python/#определение-и-особенности-операторов-сравнения"},{"categories":["python-interview"],"content":"Что PEP8 говорит об этом? Сравнение с синглтонами, такими как None, всегда должно производиться с помощью операторов is или is not, и никогда с помощью операторов равенства (== и !=). Кроме того, остерегайтесь записи, if x, если на самом деле имеете в виду, if x is not None - например, при проверке того, было ли переменной или аргументу, который по умолчанию равен None, присвоено какое-либо другое значение. Другое значение может иметь тип (например, контейнер), который в булевом контексте может иметь значение False!2 is работает быстрее, чем ==. В конце концов, is реализовано на C и представляет собой простое сравнение идентификаторов двух объектов. Вызов функции не требуется, и нам, конечно же, не нужно сравнивать значения двух объектов, что также может занять некоторое время.3 ","date":"01.10.2020","objectID":"/difference-between-is-and-equal-in-python/:2:0","series":null,"tags":["python"],"title":"В чем разница между операторами \"is\" и \"==\" в Python","uri":"/difference-between-is-and-equal-in-python/#что-pep8-говорит-об-этом"},{"categories":["python-interview"],"content":"Варианты применения is и == Примеры использования is включают:4 None значения enum (при использовании Enums из модуля enum) модули объекты класса, полученные из определений классов (зачастую) функциональные объекты, полученные в результате определений функций (зачастую) все остальное, что должно существовать в памяти только один раз (как правило, все синглтоны) конкретный объект, который вы хотите проверить по идентичности Обычные варианты использования == включают: числа, в том числе целые строки списки множества словари кастомные изменяемые объекты в большинстве случаев другие встроенные неизменяемые объекты What the f*ck Python! ↩︎ PEP8 ↩︎ Why you should almost never use “is” in Python ↩︎ stackoverflow ↩︎ ","date":"01.10.2020","objectID":"/difference-between-is-and-equal-in-python/:3:0","series":null,"tags":["python"],"title":"В чем разница между операторами \"is\" и \"==\" в Python","uri":"/difference-between-is-and-equal-in-python/#варианты-применения-is-и-"},{"categories":["python-interview"],"content":"Методология разработки ПО – это система, определяющая порядок выполнения задач, методы оценки и контроля. Модели разработки ПО выбирают, исходя из направления проекта, его бюджета и сроков реализации конечного продукта.","date":"20.09.2020","objectID":"/software-development-methodologies/","series":null,"tags":["base"],"title":"Модели и методологии разработки ПО - жизненный цикл продукта","uri":"/software-development-methodologies/"},{"categories":["python-interview"],"content":"Список вопросов к Python собеседованию ","date":"20.09.2020","objectID":"/software-development-methodologies/:0:0","series":null,"tags":["base"],"title":"Модели и методологии разработки ПО - жизненный цикл продукта","uri":"/software-development-methodologies/#"},{"categories":["python-interview"],"content":"Жизненный цикл ПО Software Development Life Cycle, SDLC - период времени, который начинается с момента принятия решения о необходимости создания программного продукта и заканчивается в момент его полного изъятия из эксплуатации Создание и развитие любого продукта происходит постепенно, проходя ряд обязательных этапов, часть из которых может идти параллельно. Жизненный цикл проекта в IT – непрерывный процесс, который заканчивается, лишь когда его решают закрыть. Этапы жизненного цикла ПО: Анализ (подготовка) Проектирование Создание (программирование) Тестирование Внедрение Сопровождение Существует некая вариативность в прохождении этих этапов во время разработки и внедрения продукта. Для каждого продукта это происходит по-своему, но чтобы процессом как-то управлять были сформулированы модели жизненного цикла ПО – упрощенное и обобщенное представление о том, как развивается продукт. В реальности жизнь продукта редко соответствует какой-либо модели. ","date":"20.09.2020","objectID":"/software-development-methodologies/:1:0","series":null,"tags":["base"],"title":"Модели и методологии разработки ПО - жизненный цикл продукта","uri":"/software-development-methodologies/#жизненный-цикл-по"},{"categories":["python-interview"],"content":"Парадигмы и модели разработки ПО По большому счету все модели можно разделить на две больших группы: последовательные и итерационные модели. ","date":"20.09.2020","objectID":"/software-development-methodologies/:2:0","series":null,"tags":["base"],"title":"Модели и методологии разработки ПО - жизненный цикл продукта","uri":"/software-development-methodologies/#парадигмы-и-модели-разработки-по"},{"categories":["python-interview"],"content":"Code and Fix Являлась первой моделью разработки ПО. Этапы модели: выяснение потребностей заказчика; создание; внедрение исправления по итогам отзывов; Повторяем цикл до полного удовлетворения заказчика (или пока у него не кончатся деньги или терпение) ","date":"20.09.2020","objectID":"/software-development-methodologies/:3:0","series":null,"tags":["base"],"title":"Модели и методологии разработки ПО - жизненный цикл продукта","uri":"/software-development-methodologies/#code-and-fix"},{"categories":["python-interview"],"content":"Каскадная модель Waterfall Model или «водопад» В этой модели разработка осуществляется поэтапно: каждая следующая стадия начинается только после того, как заканчивается предыдущая. Каскадная модель разработки ПО (Waterfall) - схема\" Каскадная модель разработки ПО (Waterfall) - схема Преимущества: Линейность модели облегчает ее понимание; Все спецификации и результаты изложены до начала разработки; Строгость этапов позволяет планировать сроки завершения всех работ и соответствующие ресурсы Хорошо работает для небольших проектов; Стоимость проекта определяется на начальном этапе; Недостатки: Сложности при формулировке четких требований и невозможность их изменения; Модель водопада неприменима к проектам, требующим непрерывной доработки; Отсутствие работающего продукта до окончания последней стадии разработки; Тестирование начинается только с середины развития проекта; Много технической документации ","date":"20.09.2020","objectID":"/software-development-methodologies/:4:0","series":null,"tags":["base"],"title":"Модели и методологии разработки ПО - жизненный цикл продукта","uri":"/software-development-methodologies/#каскадная-модель"},{"categories":["python-interview"],"content":"V-образная модель V-образная модель разработки ПО - схема\" V-образная модель разработки ПО - схема V-Model (разработка через тестирование) Суть этой модели состоит в том, что процессы на всех этапах контролируются, чтобы убедиться в возможности перехода на следующий уровень. Уже на стадии написания требований начинается процесс тестирования. Частично устраняет недостатки каскадной модели. Преимущества: Этапы строго определены; Минимизация рисков и устранение потенциальных проблем за счет раннего тестирования; Усовершенствованный тайм-менеджмент. Недостатки: Нет возможности адаптироваться к измененным требованиям заказчика; Длительное время разработки (иногда до нескольких лет) приводит к тому, что продукт может быть уже не нужен заказчику, поскольку его потребности меняются; Нет действий, направленных на анализ рисков. ","date":"20.09.2020","objectID":"/software-development-methodologies/:5:0","series":null,"tags":["base"],"title":"Модели и методологии разработки ПО - жизненный цикл продукта","uri":"/software-development-methodologies/#v-образная-модель"},{"categories":["python-interview"],"content":"Итерационная модель Iterative Model - Итерационная (итеративная) модель Предполагает разбиение проекта на части (этапы, итерации) и прохождение этапов жизненного цикла на каждом их них. Каждый этап является законченным сам по себе, совокупность этапов формирует конечный результат. Преимущества: Быстрый выпуск минимального продукта даёт возможность оперативно получать обратную связь от заказчика и пользователей; Фокус на наиболее важных функциях ПО и улучшение их в соответствии с требованиями рынка и пожеланиями клиента. Постоянное тестирование пользователями позволяет быстро обнаруживать и устранять ошибки. Недостатки: Вероятность того, что на определенной итерации придётся переписывать большую часть приложения. Отсутствие фиксированного бюджета и сроков. ","date":"20.09.2020","objectID":"/software-development-methodologies/:6:0","series":null,"tags":["base"],"title":"Модели и методологии разработки ПО - жизненный цикл продукта","uri":"/software-development-methodologies/#итерационная-модель"},{"categories":["python-interview"],"content":"Инкрементная модель Инкрементная модель разработки ПО - схема\" Инкрементная модель разработки ПО - схема Incremental Model Эта модель разработки дает возможность делать продукт по частям — инкрементам. Каждая часть представляет собой готовый фрагмент итогового продукта, который в идеале не переделывается. Улучшение продукта проходит запланировано все время пока жизненный цикл разработки ПО не завершится. Требования к системе определяются в самом начале работы, после чего процесс разработки проводится в виде последовательности версий, каждая из которых является законченным и работоспособным продуктом. Преимущества: Заказчик может дать свой отзыв касательно каждой версии продукта; Есть возможность пересмотреть риски, которые связаны с затратами и соблюдением графика; Ошибка обходится дешевле. Недостатки: Функциональная система должна быть полностью определена в начале жизненного цикла для выделения итераций; При постоянных изменениях структура системы может быть нарушена; Сроки сдачи системы могут быть затянуты из-за ограниченности ресурсов (исполнители, финансы). ","date":"20.09.2020","objectID":"/software-development-methodologies/:7:0","series":null,"tags":["base"],"title":"Модели и методологии разработки ПО - жизненный цикл продукта","uri":"/software-development-methodologies/#инкрементная-модель"},{"categories":["python-interview"],"content":"Спиральная модель Спиральная модель разработки ПО - схема\" Спиральная модель разработки ПО - схема Spiral Model Эту модель начали использовать в 1988 году. В спиральной модели жизненный путь разрабатываемого продукта изображается в виде спирали, которая, начавшись на этапе планирования, раскручивается с прохождением каждого следующего шага. Таким образом, на выходе из очередного витка: получаем готовый протестированный прототип, который дополняет существующую сборку; принимается решение, продолжать ли проект. Спиральная модель предполагает 4 этапа для каждого витка: планирование; анализ рисков; конструирование; оценка результата и при удовлетворительном качестве переход к новому витку. Преимущества: Управлению рисками уделяется особое внимание; Дополнительные функции могут быть добавлены на поздних этапах; Есть возможность гибкого проектирования. Недостатки: Оценка рисков на каждом этапе является довольно затратной; Постоянные отзывы и реакция заказчика может провоцировать все новые и новые итерации, которые могут приводить к временному затягиванию разработки продукта; Более применима для больших проектов. ","date":"20.09.2020","objectID":"/software-development-methodologies/:8:0","series":null,"tags":["base"],"title":"Модели и методологии разработки ПО - жизненный цикл продукта","uri":"/software-development-methodologies/#спиральная-модель"},{"categories":["python-interview"],"content":"Модель хаоса Chaos model Её создатель Л.Б.С.Ракун отмечает, что такие модели управления проектами, как спиральная модель и каскадная модель, хотя и хороши в управлении расписаниями и персоналом, не обеспечивают методами устранения ошибок и решениями других технических задач, не помогают ни в управлении конечными сроками, ни в реагировании на запросы клиентов. Модель хаоса — это инструмент пытающийся помочь понять эти ограничения и восполнить пробелы. Стратегия хаоса — это стратегия разработки программного обеспечения, основанная на модели хаоса. Главное правило — это всегда решать наиболее важную задачу первой. ","date":"20.09.2020","objectID":"/software-development-methodologies/:9:0","series":null,"tags":["base"],"title":"Модели и методологии разработки ПО - жизненный цикл продукта","uri":"/software-development-methodologies/#модель-хаоса"},{"categories":["python-interview"],"content":"Гибкая (Agile) модель Agile Model - гибкая модель разработки, по которой сегодня работает большинство ИТ-проектов.Представляет собой совокупность различных подходов к разработке ПО. Основные идеи Agile: люди и взаимодействие важнее процессов и инструментов; работающий продукт важнее исчерпывающей документации; сотрудничество с заказчиком важнее согласования условий контракта; готовность к изменениям важнее следования первоначальному плану. Преимущества: после каждой итерации заказчик может наблюдать результат и понимать, удовлетворяет он его или нет. быстрое принятие решений за счет постоянных коммуникаций; минимизация рисков; облегченная работа с документацией. Недостатки: большое количество митингов и бесед, что может увеличить время разработки продукта; сложно планировать процессы, так как требования постоянно меняются; редко используется для реализации больших проектов. ","date":"20.09.2020","objectID":"/software-development-methodologies/:10:0","series":null,"tags":["base"],"title":"Модели и методологии разработки ПО - жизненный цикл продукта","uri":"/software-development-methodologies/#гибкая-agile-модель"},{"categories":["python-interview"],"content":"Гибкие методологии разработки ПО SCRUM Kanban (看板) RUP (Rational Unified Process) OpenUP DSDM (Dynamic Systems Development Model) RAD (Rapid Application Development) XP (Extreme Programming) FDD (Feature Driven Development) ASD (Adaptive Software Development) DevOps (Development and Operations) DAD (Disciplined Agile Delivery) Lean SD (Lean Software Development) MDD (Model-Driven Development) MSF (Microsoft Solutions Framework) PSP (Personal Software Process) SAFe (Scaled Agile Framework) UP (Unified Process) Источники1234 Agile манифест ↩︎ Модели жизненного цикла, принципы и методологии разработки ПО ↩︎ Модели и методологии разработки ПО ↩︎ Ещё раз про семь основных методологий разработки ↩︎ ","date":"20.09.2020","objectID":"/software-development-methodologies/:11:0","series":null,"tags":["base"],"title":"Модели и методологии разработки ПО - жизненный цикл продукта","uri":"/software-development-methodologies/#гибкие-методологии-разработки-по"},{"categories":["notes"],"content":"Настройки Vim","date":"14.09.2020","objectID":"/vim-settings/","series":null,"tags":["vim"],"title":"Настройки Vim","uri":"/vim-settings/"},{"categories":["notes"],"content":"Vundle Vim Установка git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim Настройка Vundle Размещаем это в начале .vimrc, чтобы использовать Vundle: set nocompatiblefiletype offset rtp+=~/.vim/bundle/Vundle.vimcall vundle#begin()Plugin 'VundleVim/Vundle.vim'Plugin 'tpope/vim-fugitive'Plugin 'ambv/black'Plugin 'nvie/vim-flake8'Plugin 'scrooloose/nerdtree'Plugin 'davidhalter/jedi-vim'Plugin 'mitsuhiko/vim-jinja'Plugin 'git://git.wincent.com/command-t.git'Plugin 'rstacruz/sparkup', {'rtp': 'vim/'}Plugin 'flazz/vim-colorschemes'Plugin 'tpope/vim-surround'call vundle#end() \" requiredfiletype onfiletype plugin onfiletype plugin indent on \" required\" Put your non-Plugin stuff after this line Установка плагинов Заходим в vim и запускаем команду :PluginInstall Для установки плагинов из командной строки: vim +PluginInstall +qall Команды Vundle :PluginList - список настроенных плагинов :PluginInstall - устанавливает плагины (с добавленем ! - обновляет) :PluginUpdate - обновляет плагины :PluginSearch foo - ищет foo (с добавленем ! обновляет локальный кэш) :PluginClean - подтверждает удаление неиспользуемых плагинов (добавить ! для автоматического подтверждения удаления) ","date":"14.09.2020","objectID":"/vim-settings/:1:0","series":null,"tags":["vim"],"title":"Настройки Vim","uri":"/vim-settings/#vundle-vim"},{"categories":["notes"],"content":"Список плагинов tpope/vim-fugitive - :Git commit, :Git rebase -i и другие команды git; tpope/vim-commentary — позволяет закомментировать код: командой gcc — строку, а командой gc — выделенный фрагмент в визуальном режиме; tpope/vim-surround ambv/black nvie/vim-flake8 scrooloose/nerdtree davidhalter/jedi-vim mitsuhiko/vim-jinja git://git.wincent.com/command-t.git rstacruz/sparkup' flazz/vim-colorschemes ","date":"14.09.2020","objectID":"/vim-settings/:2:0","series":null,"tags":["vim"],"title":"Настройки Vim","uri":"/vim-settings/#список-плагинов"},{"categories":["notes"],"content":"Дополнительные настройки set cursorline \" выделять строку, на которой находится курсор \" установить tab равным 4 пробеламset tabstop=4 \" set ts=4\" при использовании команд \u003e\u003e или \u003c\u003c сдвигать строки на 4 пробелаset shiftwidth=4set smarttab\" преобразование tab-ов в пробелыset expandtab\"4 пробела в табеset softtabstop=4\" Автоотступ при переходе на следующую строку при написании кодаset autoindent\" включить подсветку синтаксиса Pythonlet python_highlight_all = 1\" Включаем 256 цветов в терминале, мы ведь работаем из иксов?\" Нужно во многих терминалах, например в gnome-terminalset t_Co=256\" Перед сохранением вырезаем пробелы на концах (только в .py файлах)autocmd BufWritePre *.py normal m`:%s/\\s\\+$//e ``\" В .py файлах включаем умные отступы после ключевых словautocmd BufRead *.py set smartindent cinwords=if,elif,else,for,while,try,except,finally,def,classsyntax on \"Включить подсветку синтаксиса syntax enableset nu \"Включаем нумерацию строкset showmatch \" показывать парную скобку для [] {} и ()\" set cursorline \" выделять строку, на которой находится курсорset mousehide \"Спрятать курсор мыши когда набираем текстset mouse=a \"Включить поддержку мышиset termencoding=utf-8 \"Кодировка терминалаset novisualbell \"Не мигатьset t_vb= \"Не пищать! (Опции 'не портить текст', к сожалению, нету)\" Удобное поведение backspaceset backspace=indent,eol,start whichwrap+=\u003c,\u003e,[,]\" Вырубаем черточки на табахset showtabline=1\" Переносим на другую строчку, разрываем строкиset wrapset linebreak\" Вырубаем .swp и ~ (резервные) файлыset nobackupset noswapfileset encoding=utf-8 \" Кодировка файлов по умолчаниюset fileencodings=utf8,cp1251set clipboard=unnamedset rulerset hiddennnoremap \u003cC-N\u003e :bnext\u003cCR\u003ennoremap \u003cC-P\u003e :bprev\u003cCR\u003ennoremap \u003cF3\u003e :NERDTreeMirror\u003cCR\u003ennoremap \u003cF3\u003e :NERDTreeToggle\u003cCR\u003e\" Выключаем звук в Vimset visualbell t_vb=\"Переключение табов по CMD+number для MacVimif has(\"gui_macvim\")\" Press Ctrl-Tab to switch between open tabs (like browser tabs) to\" the right side. Ctrl-Shift-Tab goes the other way.noremap \u003cC-Tab\u003e :tabnext\u003cCR\u003enoremap \u003cC-S-Tab\u003e :tabprev\u003cCR\u003e\" Switch to specific tab numbers with Command-numbernoremap \u003cD-1\u003e :tabn 1\u003cCR\u003enoremap \u003cD-2\u003e :tabn 2\u003cCR\u003enoremap \u003cD-3\u003e :tabn 3\u003cCR\u003enoremap \u003cD-4\u003e :tabn 4\u003cCR\u003enoremap \u003cD-5\u003e :tabn 5\u003cCR\u003enoremap \u003cD-6\u003e :tabn 6\u003cCR\u003enoremap \u003cD-7\u003e :tabn 7\u003cCR\u003enoremap \u003cD-8\u003e :tabn 8\u003cCR\u003enoremap \u003cD-9\u003e :tabn 9\u003cCR\u003e\" Command-0 goes to the last tabnoremap \u003cD-0\u003e :tablast\u003cCR\u003eendifset guifont=Monaco:h18colorscheme OceanicNextnnoremap \u003cEsc\u003ej :m .+1\u003cCR\u003e==nnoremap \u003cEsc\u003ek :m .-2\u003cCR\u003e==inoremap \u003cEsc\u003ej \u003cEsc\u003e:m .+1\u003cCR\u003e==giinoremap \u003cEsc\u003ek \u003cEsc\u003e:m .-2\u003cCR\u003e==givnoremap \u003cEsc\u003ej :m '\u003e+1\u003cCR\u003egv=gvvnoremap \u003cEsc\u003ek :m '\u003c-2\u003cCR\u003egv=gv Источники12 Learn Vim For the Last Time: A Tutorial and Primer ↩︎  ↩︎ ","date":"14.09.2020","objectID":"/vim-settings/:3:0","series":null,"tags":["vim"],"title":"Настройки Vim","uri":"/vim-settings/#дополнительные-настройки"}]