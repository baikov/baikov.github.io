[{"categories":null,"content":"Образование: ННГУ Лобачевского (ВМК). Стек: Python 3.6+, Django 2.2+, DRF, PostgreSQL, Redis, Celery, Docker, git, pytest, HTML, CSS, JS. Более 10 лет опыта в разработке и продвижении сайтов.","date":"08.12.2021","objectID":"/cv/","series":null,"tags":null,"title":"Резюме: Junior python backend developer | Байков Алексей","uri":"/cv/"},{"categories":null,"content":"Резюме на вакансию в компанию -- Скачать (.pdf) Байков Алексей 02.01.1987 (35 лет) Python backend разработчик Уровень: Junior, Junior+ Уровень: Middle-- Занятость: полная Формат работы: удаленная, в офисе Зарплатные ожидания: 100.000 руб Контакты +7 (929) 053-73-35 https://t.me/alexbaikov alex@baikov.dev Нижний Новгород, Россия -- Python Django DRF JSON APIs PostgreSQL Celery Flower Nginx Traefik Redis Prometheus Grafana Docker Docker Compose Git GitHub GitHub Actions Unit testing HTML CSS Все навыки... -- Образование ННГУ им. Лобачевского Нижегородский государственный университет им. Н.И. Лобачевского 2004-2009 (5 лет), дневное отделение, очно Факультет вычислительной математики и кибернетики Специальность: Прикладная математика и информатика Специализация: Системы поддержки принятия решений -- Квалификация: математик, системный программист Цели Начать карьеру backend-разработчика в современной продуктовой компании. Профессиональный рост до уровня Middle в течение года и, как следствие, повышение своей рентабельности. Стек: Python 3.6+, Django 2.2+, PostgreSQL, DRF, FastAPI, Docker. -- Опыт работы февраль 2021 — по настоящее время (1 год) Изучение нового стека Все изучаемые технологии применял на практике (проект allflags.ru) Краткий список практических навыков: Администрирование VPS, работа с Heroku, AWS, Yandex.Cloud; Настройка Nginx, Traefik, Prometheus, Grafana; Работа с Docker и Docker Compose, основы CI/CD; Codestyle (flake8, black), тестирование (pytest, coverage), документирование (Sphinx); Контроль версий и процесс ветвления (git, github, git-flow, github-flow); Работа с Django, DRF, PostgreSQL, Redis, Celery, Flower. Python Django Git Docker Celery PostgreSQL DRF Redis CI/CD Traefik Linux Prometheus Grafana -- октябрь 2015 — по настоящее время (6 лет 4 мес) ПКФ Луидор, Нижний Новгород (автомобильный завод, спецавтомобили) Web-разработчик, SEO-специалист Разработал сервис поиска запчастей по VIN (backend: Django и DRF, frontend: Vue.js); Разработка, доработка и продвижение сайтов компании на 1C-Bitrix; Более 3 лет опыта удаленной работы. HTML CSS Vue.js SCSS 1С-Bitrix PHP SEO JavaScript Gulp -- апрель 2012 — октябрь 2015 (3 года 7 мес) Фриланс, собственные проекты Full-stack разработчик, SEO специалист создание и продвижение сайтов (1C-Bitrix, WordPress, OpenCart). сентябрь 2011 — апрель 2012 (1 год 1 мес) Редокс, Москва (оптовая торговля, товары для здоровья) Заместитель руководителя филиала сентябрь 2008 — апрель 2011 (2 года 7 мес) Редокс, Нижний Новгород (розничная торговля, товары для здоровья) Менеджер по продажам ноябрь 2006 — май 2008 (1 год 7 мес) Тэлма Софт, Нижний Новгород (разработка ПО) Инженер-стажер в отделе разработки и тестирования ПО Стажировка во время обучения в университете. Обо мне Я люблю веб-разработку и занимаюсь ей более 10 лет. За это время приобрел как менеджерский опыт, так и опыт во frontend, backend и DevOps. Надеюсь, что новый стек и углубление в бэкенд позволят мне участвовать в разработке более крупных и интересных проектов. Моя цель на текущий год: начать карьеру backend-разработчика в современной компании и дорасти до уровня Middle. Навыки Python Django DRF JSON APIs PostgreSQL Celery Flower Nginx Traefik Redis Prometheus Grafana Docker Docker Compose Git GitHub GitHub Actions Unit testing HTML CSS -- Образование ННГУ им. Лобачевского Нижегородский государственный университет им. Н.И. Лобачевского 2004-2009 (5 лет), дневное отделение, очно Факультет вычислительной математики и кибернетики Специальность: Прикладная математика и информатика Специализация: Системы поддержки принятия решений -- Квалификация: математик, системный программист Навыки Python Django DRF JSON APIs PostgreSQL Celery Flower Nginx Traefik Redis Prometheus Grafana Docker Docker Compose Git GitHub GitHub Actions Unit testing HTML CSS Языки Русский родной Английский Intermediate Курсы Docker 2021, slurm.io-- Docker | 2021, slurm.io Build a Backend REST API with Python \u0026 Django 2021, Udemi-- Build a Backend REST AP","date":"08.12.2021","objectID":"/cv/:0:0","series":null,"tags":null,"title":"Резюме: Junior python backend developer | Байков Алексей","uri":"/cv/#"},{"categories":["python-interview"],"content":"К основным встроенным (built-in) типам относятся: NoneType (None), Numeric Type (int, float, complex), Boolean (True и False), Sequence Type (str, list, tuple, range), а так же set, frozenset и dict.","date":"11.12.2021","objectID":"/python-built-in-data-types/","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/"},{"categories":["python-interview"],"content":"Говоря о типах данных, стоит упомянуть, что Python - язык с неявной сильной динамической типизацией (подробнее о видах типизации в языках программирования). Встроенные и не встроенные типы В Python типы данных можно разделить на встроенные в интерпретатор (built-in) и не встроенные, которые можно использовать при импортировании соответствующих модулей. Int - больше, чем просто int Стандартная реализация Python написана на C (CPython). Это означает, что каждый объект Python — это просто искусно замаскированная структура C, которая содержит не только его значение, но и другую информацию. Каждое значение в Python имеет тип данных. Поскольку в Python все является объектом, типы данных на самом деле являются классами, а переменные являются экземплярами (объектами) этих классов. На аппаратном уровне переменная — это ссылка на место в памяти. ","date":"11.12.2021","objectID":"/python-built-in-data-types/:0:0","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#"},{"categories":["python-interview"],"content":"Числовые типы (Numeric Types) Существует три базовых числовых типа: int, float, complex. ","date":"11.12.2021","objectID":"/python-built-in-data-types/:1:0","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#числовые-типы-numeric-types"},{"categories":["python-interview"],"content":"Integer int - целые числа. Отрицательные и положительные числа любой длины (ограничением является только количество памяти). # integer a = 1000 type(a) # \u003cclass 'int'\u003e ","date":"11.12.2021","objectID":"/python-built-in-data-types/:1:1","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#integer"},{"categories":["python-interview"],"content":"Float float - числа с плавающей точкой, отрицательные или положительные, содержащие десятичную точку или символ экспоненты “e” (показатель возведения в степень 10: 35e3, 12E4). Точность до 15 знаков после запятой. float может принимать значения nan и inf/-inf. # float b = 12.5634423 # 35e3, 12E4, -87.7e100 type(b) # \u003cclass 'float'\u003e # Not A Number x = float(\"nan\") print(x) # nan type(x) # \u003cclass 'float'\u003e # Аналогично с бесконечностью y = float(\"inf\") # inf z = float(\"-inf\") # -inf ","date":"11.12.2021","objectID":"/python-built-in-data-types/:1:2","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#float"},{"categories":["python-interview"],"content":"Complex complex - комплексные числа (x+yj, где x - действительная часть, y - мнимая часть, а j - мнимая единица). # complex c = 3+5j # 5j, -5j type(c) # \u003cclass 'complex'\u003e print(c.real) # 3.0 print(c.imag) # 5.0 ","date":"11.12.2021","objectID":"/python-built-in-data-types/:1:3","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#complex"},{"categories":["python-interview"],"content":"Long long - использовался для представления больших целых чисел. Кроме того, boolean является подтипом int. ","date":"11.12.2021","objectID":"/python-built-in-data-types/:1:4","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#long"},{"categories":["python-interview"],"content":"Логический тип (Boolean Type) В булевом типе данных есть только два типа значений: True и False (встроенные константы чувствительные к регистру). type(True) # \u003cclass 'bool'\u003e type(False) # \u003cclass 'bool'\u003e Функция приведения типа bool() позволяет оценить любое значение и вернуть True или False. В Python истинными и ложными значениями считаются не только True и False: Истинное значение: любое ненулевое число любая непустая строка любой непустой объект Ложное значение: 0 None пустая строка пустой объект ","date":"11.12.2021","objectID":"/python-built-in-data-types/:2:0","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#логический-тип-boolean-type"},{"categories":["python-interview"],"content":"Последовательности (Sequence Type) К ним относятся основные: str (строка), list (список), tuple (кортеж), range (диапазон) и бинарные: bytes (байтовая строка), bytearray (байтовый массив), memoryview (специальные объекты для доступа к внутренним данным объекта через protocol buffer). Как и все типы данных, последовательности делятся на изменяемые (mutable) и неизменяемые (immutable). Операции, поддерживаемые большинством последовательностей (изменяемых и неизменяемых): x in s # (x not in s) - проверка принадлежности s + t # конкатенация s * n # s[i] # получение по индексу s[i:j:k] # срезы (старт:стоп:шаг) len(s) # длина s min(s) # минимальный элемент s max(s) # максимальный элемент s s.index(x[, i[, j]]) # индекс первого появления x (at or after index i and before index j) s.count(x) # общее кол-во вхождений x в s hash() - единственная операция, реализованная в неизменяемых типах последовательностей и отсутствующая в изменяемых. Это позволяет использовать неизменяемые последовательности, такие как экземпляры кортежей, в качестве ключей словаря и хранить их в set и frozenset. Операции над изменяемыми последовательностями: s[i] = x s[i:j] = t del s[i:j] s[i:j:k] = t del s[i:j:k] s.append(x) s.clear() s.copy() s.extend(t) # or s += t s *= n s.insert(i, x) s.pop() # or s.pop(i) s.remove(x) s.reverse() ","date":"11.12.2021","objectID":"/python-built-in-data-types/:3:0","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#последовательности-sequence-type"},{"categories":["python-interview"],"content":"Строка (string) Cтрока - это неизменяемая упорядоченная последовательность символов Юникода. В питоне нет символьного типа данных char, символ представляет собой строку одинарной длины. Строку можно создать различными способами: # Одинарные кавычки first_way = 'This is a string' # Двойные кавычки second_way = \"This is a string\" # Тройные кавычки (одинарные или двойные) third_way_single = '''This is a string''' third_way_double = \"\"\"This is a string\"\"\" Для строк доступны общие операции c последовательностями, а так же дополнительные методы встроенного класса str(). ","date":"11.12.2021","objectID":"/python-built-in-data-types/:3:1","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#строка-string"},{"categories":["python-interview"],"content":"Список (list) Список — это изменяемая упорядоченная последовательность, обычно используемая для хранения коллекций однородных элементов. Поскольку списки индексируются, то могут содержать элементы с одинаковым значением. list1 = [10, 20, 30, 77] list2 = ['one', 'dog', 'seven'] list3 = [1, 20, 4.0, 'word'] ","date":"11.12.2021","objectID":"/python-built-in-data-types/:3:2","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#список-list"},{"categories":["python-interview"],"content":"Кортеж (tuple) Кортеж — это неизменяемая упорядоченная последовательность, обычно используемая для хранения коллекций разнородных элементов. Также используются в случаях, когда требуется неизменяемая последовательность однородных данных (например, использование в экземпляре set или dict). Кортежи, как правило, быстрее, чем списки в Python. tuple1 = (1, 2, 5, 6) tuple2 = tuple('a', 'b', 'c') tuple3 = () # пустой кортеж tuple4 = 23, 13, 100 tuple5 = (\"London\", \"Tokyo\", \"Korea\", 1986, 1640, 1948) ","date":"11.12.2021","objectID":"/python-built-in-data-types/:3:3","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#кортеж-tuple"},{"categories":["python-interview"],"content":"Диапазон (range) Тип range представляет собой упорядоченную неизменяемую последовательность чисел и обычно используется для выполнения определенного количества раз циклов for. Для диапазонов доступны общие операции с последовательностями, кроме конкатенации и повторения. Проверка диапазонов range на равенство с == и != сравнивает их как последовательности. Атрибуты start, stop и step. ","date":"11.12.2021","objectID":"/python-built-in-data-types/:3:4","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#диапазон-range"},{"categories":["python-interview"],"content":"Байтовые строки (bytes) Тип данных bytes - это упорядоченная неизменяемая последовательность отдельных байтов. Синтаксис для байтовых строк в основном такой же, как и для обычных строк, за исключением того, что добавляется префикс b. ","date":"11.12.2021","objectID":"/python-built-in-data-types/:3:5","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#байтовые-строки-bytes"},{"categories":["python-interview"],"content":"Байтовый массив (bytearray) Bytearray объекты являются упорядоченным неизменяемым аналогом bytes. ","date":"11.12.2021","objectID":"/python-built-in-data-types/:3:6","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#байтовый-массив-bytearray"},{"categories":["python-interview"],"content":"Буфер обмена (memoryview) Объекты memoryview позволяют коду Python получать доступ к внутренним данным объекта, который поддерживает буферный протокол, без копирования. ","date":"11.12.2021","objectID":"/python-built-in-data-types/:3:7","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#буфер-обмена-memoryview"},{"categories":["python-interview"],"content":"Множества (Set Types) Множество - это неупорядоченный набор различных хешируемых объектов. Обычно множества используются для проверки вхождения элемента, удаления дубликатов из последовательности и вычисления математических операций, таких как пересечение, объединение, разность и т. д. Будучи неупорядоченной коллекцией, множества не сохраняют положение элемента или порядок вставки. Соответственно, не поддерживают индексы, срезы или другое поведение, подобное упорядоченной последовательности. Существует два встроенных типа множеств: set и frozenset. ","date":"11.12.2021","objectID":"/python-built-in-data-types/:4:0","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#множества-set-types"},{"categories":["python-interview"],"content":"Множество (set) Тип set является изменяемым множеством, содержимое может быть изменено с помощью таких методов, как add() и remove(), так же поддерживает операции доступные frozenset. Поскольку тип set является изменяемым, он не имеет хеш-значения и не может использоваться ни как ключ словаря, ни как элемент другого множества. # Use the type constructor set2 = set('a', 'b', 'c') # Use a comma-separated list of elements within braces set1 = {1, 2, 5, 6} # Use a set comprehension {c for c in 'abracadabra' if c not in 'abc'} ","date":"11.12.2021","objectID":"/python-built-in-data-types/:4:1","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#множество-set"},{"categories":["python-interview"],"content":"Неизменяемое множество (frozenset) Тип frozenset является неизменяемым и хешируемым множеством, его содержимое не может быть изменено после его создания, поэтому он может использоваться как ключ словаря или как элемент другого множества. # Use the type constructor s = frozenset({'a', 'b', 'c'}) ","date":"11.12.2021","objectID":"/python-built-in-data-types/:4:2","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#неизменяемое-множество-frozenset"},{"categories":["python-interview"],"content":"Словарь (dict) Словарь — это упорядоченная, изменяемая коллекция пар ключ: значение, в которой не допускается дублирование ключей. Ключи словаря - это произвольные, неизменяемые (хешируемые) значения. Значения элементов словаря могут иметь любой тип данных. Словари стали упорядоченными. Словари и объекты представления словаря (dict.keys(), dict.values(), dict.items()) теперь обратимы. Словарь может быть создан несколькими способами: # Используя разделенный запятыми список пар ключ: значение в фигурных скобках dict1 = {'Moscow': 1023, 'SPB': 2048} # Используя dict comprehension dict2 = {x: x ** 2 for x in range(10)} # Используя конструктор типа dict3 = dict([('foo', 100), ('bar', 200)]) dict4 = dict(foo=100, bar=200) В других языках программирования тип данных подобный словарю может называться ассоциативный массив, хеш или хеш-таблица. ","date":"11.12.2021","objectID":"/python-built-in-data-types/:5:0","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#словарь-dict"},{"categories":["python-interview"],"content":"Итераторы и генераторы ``` Объект с id = 1672501744 будет иметь значение 15 и изменить его уже нельзя. Если тип данных изменяемый, то можно менять значение объекта. Например, создадим список [1, 2], а потом заменим второй элемент на 3. ```python a = [1, 2] id(a) # 47997336 a[1] = 3 print(a) # [1, 3] id(a) # 47997336 ``` ## Упорядоченные и неупорядоченные типы -- Источники: Python documentation - Built-in Types Understand How Much Memory Your Python Objects Use Understanding Data Types in Python ","date":"11.12.2021","objectID":"/python-built-in-data-types/:6:0","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#итераторы-и-генераторы"},{"categories":null,"content":"Описание","date":"08.12.2021","objectID":"/skills/","series":null,"tags":null,"title":"Навыки","uri":"/skills/"},{"categories":null,"content":"Актуальные навыки Языки: Python, JavaScript Backend: Django, Flask, Celery, Flower API: Django REST Framework, JSON APIs Тестирование: Unit тестирование Frontend: HTML (flex, grid), CSS3 (BEM), SASS (SCSS), Bootstrap (2, 3, 4), Vue.js, Webpack, Gulp, npm, DevTools, SSG (Hugo) БД: PostgreSQL, Redis, SQLite Cloud platform: Reg.ru, AWS, Yandex.Cloud Web servers: Nginx, Traefik Web security: HTTPS, SSL/TLS, CORS Мониторинг: Prometheus, Grafana Другое: Docker, Docker Compose, Git, GitHub, git-flow, github-flow, Follow the \"Twelve factor app\", Sphinx CI/CD: GitHub Actions Tools: VSCode, iTerm2 + zsh + oh-my-zsh, Vim, Homebrew OS: MacOS, Linux (Debian, Ubuntu) Навыки в смежных сферах SEO: Link building, аудит, техническая оптимизация Web analytics: GTM, Google Analytics, Yandex Metrica, PowerBI Web security: pentesting, XSS, CSRF, SQL-Injection OS: Kali Linux Планирую изучить Языки: Go Backend: aiohttp, sqlalchemy, RabbitMQ, RPC, asyncio API: FastAPI, GraphQL, gRPC Тестирование: Integration Тестирование, Functional Тестирование, Selenium Мониторинг: Datadog Frontend: VueX, SSR (Nuxt.js), Pre-rendering, Bootstrap 5 БД: MongoDB CI/CD: Circle CI, Travis CI, Jenkins Другое: Elasticsearch, Kubernetes, Ansible, Agile Development \u0026 Scrum С чем работал раньше Языки: PHP, Java, C++, Perl Frontend: jQuery, LESS, SSG (Jekyll) Design: Axure, Photoshop БД: MySQL CMS: 1C-Bitrix, Wordpress, OpenCart, Joomla, InstantCMS Tools: MS Visual Studio, SublimeText, Atom, bash OS: Linux (Mint, Ubuntu), Windows (98, 2000, XP, 7, 8, 10) Hosting and cloud platforms: Heroku, DigitalOcean, HostSailor, nic.ru Web servers: Apache ","date":"08.12.2021","objectID":"/skills/:0:0","series":null,"tags":null,"title":"Навыки","uri":"/skills/#"},{"categories":null,"content":"Описание","date":"08.12.2021","objectID":"/about/","series":null,"tags":null,"title":"Обо мне","uri":"/about/"},{"categories":null,"content":" 🖖 Привет! Меня зовут Алексей, мне 35 лет и я Веб-мастер Backend разработчик. -- Мой путь -- Первую HTML страничку я сделал примерно в 2001 году, и это во многом определило мою дальнейшую жизнь. В 2004 поступил в ННГУ Лобачевского на факультет ВМК (прикладная математика и информатика). В 2009 получил диплом специалиста по специальности \"математик, системный программист\". Будучи студентом, а затем стажером - изучал и применял на практике С++ и Java. -- По своей инициативе ковырялся в PHP, Perl и JS. Наверное, с тех пор я и отдал предпочтение интерпретируемым языкам. -- Более 10 лет я занимался разработкой и продвижением сайтов. За это время успел поработать с CMS Joomla, InstantCMS, Opencart, Wordpress, 1C-Bitrix. Разрабатывал с нуля сайты-визитки, одностраничники, интернет-магазины, корпоративные сайты, статейники и агрегаторы. Работая как частный специалист проходил все этапы разработки: Как менеджер проекта: выявление потребностей клиента, разработка и согласование ТЗ, анализ ниши, согласование этапов разработки; Как frontend-разработчик: прототипирование, верстка, интеграция; Как backend-разработчик: развертывание сайта на хостинге, установка и настройка CMS, доработка функционала; Как SEO-специалист: анализ конкурентов, сбор и кластеризация семантического ядра, рекомендации по созданию структуры и подготовке контента, оптимизация сайта, технический аудит, настройка аналитики; Как контент-менеджер: создание структуры сайта, наполнение сайта; Ценность полученного мной опыта в том, что я могу глубже погружаться в поставленную задачу на основе существующих знаний. Считаю, что разработчик, понимающий весь стек технологий, способен: писать более качественные приложения; более эффективно взаимодействовать с коллегами; обладая обширным арсеналом идей и концепций, лучше справляться со своими основными задачами; лучше понимать, что происходит при использовании клиентом программного обеспечения; лучше понимать бизнес клиента. Навыки Python Django DRF JSON APIs PostgreSQL Celery Flower Nginx Traefik Redis Prometheus Grafana Docker Docker Compose Git GitHub GitHub Actions Unit testing HTML CSS Таймлайн февраль 2021 — по настоящее время Погружаюсь в бэкенд (Python, Django) октябрь 2015 — февраль 2022 Web-разработчик, SEO-специалист в ПКФ Луидор, Нижний Новгород (автомобильный завод, спецавтомобили) апрель 2012 — октябрь 2015 Full-stack разработчик, SEO специалист на фрилансе сентябрь 2011 — апрель 2012 Заместитель руководителя филиала в Редокс, Москва (оптовая торговля, товары для здоровья) сентябрь 2008 — апрель 2011 Менеджер по продажам в Редокс, Нижний Новгород (розничная торговля, товары для здоровья) ноябрь 2006 — май 2008 Инженер-стажер в Тэлма Софт, Нижний Новгород (разработка ПО) сентябрь 2004 — май 2009 ННГУ им. Лобачевского, ВМК Нижний Новгород сентябрь 1994 — май 2004 Средняя школа №4, Городец -- -- ","date":"08.12.2021","objectID":"/about/:0:0","series":null,"tags":null,"title":"Обо мне","uri":"/about/#"},{"categories":["python-interview"],"content":"Алгоритмы","date":"11.02.2021","objectID":"/algorithms/","series":null,"tags":["base"],"title":"Алгоритмы","uri":"/algorithms/"},{"categories":["python-interview"],"content":"Список вопросов к Python собеседованию ","date":"11.02.2021","objectID":"/algorithms/:0:0","series":null,"tags":["base"],"title":"Алгоритмы","uri":"/algorithms/#"},{"categories":["python-interview"],"content":"Время выполения алгоритма («О-большое») О(1) - константное время (получение одного элемента в массиве) O(log n) - логарифмическое время (бинарный поиск). О(n) - линейное время (простой поиск). О(n*log n) - линейно-логарифмическое время (эффективные алгоритмы сортировки, напр. быстрая сортировка). О(n2) - квадратичное время (медленные алгоритмы сортировки: сортировка выбо­ром). О(n3) - кубическое время (Обычное умножение двух n на n матриц). О(n!) - очень медленные алгоритмы (задача о коммивояжере полным перебором). Сложность алгоритмов\" Сложность алгоритмов Скорость алгоритмов измеряется не в секундах, а в темпе роста количе­ ства операций.1 В некоторых случаях константа может иметь значение Один из примеров такого рода - быстрая сортировка и сортировка слиянием. У бы­строй сортировки константа меньше, чем у сортировки слиянием, поэтому, несмотря на то что оба алгоритма характеризуются временем О(n*log n), быстрая сортировка работает быстрее. А на практике быстрая сортировка работает быстрее, потому что средний случай встречается намного чаще худшего. ","date":"11.02.2021","objectID":"/algorithms/:1:0","series":null,"tags":["base"],"title":"Алгоритмы","uri":"/algorithms/#время-выполения-алгоритма-о-большое"},{"categories":["python-interview"],"content":"Бинарный поиск Бинарный поиск - на входе получает отсортированный список элементов. Если искомый элемент присутствует в списке - возвращает его позицию. В противном слу­чае возвращает null. Time Complexities Best case complexity: O(1) Average case complexity: O(log n) Worst case complexity: O(log n) The space complexity of the binary search is O(1). def binary_search(arr: List[int], elem: int) -\u003e Union[int, None]: low = 0 high = len(arr) - 1 while low \u003c= high: mid = (low + high) // 2 guess = arr[mid] if guess == elem: return mid elif guess \u003e elem: high = mid - 1 else: low = mid + 1 return None More ","date":"11.02.2021","objectID":"/algorithms/:2:0","series":null,"tags":["base"],"title":"Алгоритмы","uri":"/algorithms/#бинарный-поиск"},{"categories":["python-interview"],"content":"Сортировка выбором Наиболее простая, но медленная сортировка. Сложность О(n2). def search_min(arr: List) -\u003e int: min_index = 0 for i in range(len(arr) - 1): if arr[min_index] \u003e arr[i]: min_index = i return min_index def selection_sort(arr: List) -\u003e List: result = [] copy = arr[:] while len(copy) \u003e 0: min_index = search_min(copy) result.append(copy.pop(min_index)) return result More ","date":"11.02.2021","objectID":"/algorithms/:3:0","series":null,"tags":["base"],"title":"Алгоритмы","uri":"/algorithms/#сортировка-выбором"},{"categories":["python-interview"],"content":"Рекурсия Рекурсия - это такой способ организации обработки данных, при котором программа вызывает сама себя непосредственно, либо с помощью других программ. Примеры в реальной жизни: эффект Дросте, треугольник Серпинского. Любой алгоритм, реализованный в рекурсивной форме, может быть переписан в итерационном виде и наоборот. Рекурсивная функция состоит из: Условие остановки / Базовый случай Условие продолжения / Шаг рекурсии — способ сведения задачи к более простым. Рекурсивные функции используют стек вызовов, где каждый вызов создает собственную копию переменной. Обратиться к переменной, принадлежащей другому уровню, невозможно. Стек — абстрактный тип данных, представляющий собой список элементов, организованных по принципу LIFO (last in — first out). В Python стеком можно назвать любой список, так как для них доступны операции pop и push. В интерпретаторе Python (CPython) есть защита от переполнения стека. Достигнув лимита глубины интерпретатор выдаст ошибку RecursionError: maximum recursion depth exceeded in comparison Лимит глубины рекурсии можно узнать при помощи функции sys.getrecursionlimit, а изменить этот лимит при помощи sys.setrecursionlimit: import sys print(sys.getrecursionlimit()) # 997 sys.setrecursionlimit(1500) Увеличение лимита рекурсии может привести к переполнению стека, поэтому лучше переписать алгоритм итеративно. Если в гугле ввести слово “рекурсия”, то он наряду с результатми поиска выдаст «возможно, вы имели в виду “рекурсия”» :-) ","date":"11.02.2021","objectID":"/algorithms/:4:0","series":null,"tags":["base"],"title":"Алгоритмы","uri":"/algorithms/#рекурсия"},{"categories":["python-interview"],"content":"Быстрая сортировка Быстродействие быстрой сортировки сильно зависит от выбора опорного элемента. Быстрая сортировка О-большое\" Быстрая сортировка О-большое Лучший сценарий: O(n*log n) (он же средний) - когда пограничным элементом выбирается средний, или ближайший к середине. Худший сценарий: O(n2) - это происходит в случае, если за пограничный элемент берется первый или последний элемент массива. from typing import List from random import randint # top answer on stackoveflow def quick_sort(arr: List) -\u003e List: less = [] equal = [] greater = [] if len(arr) \u003e 1: pivot = arr[0] # pivot = arr[len(arr) // 2] # pivot = randint(0, len(arr) - 1) for elem in arr: if elem \u003c pivot: less.append(elem) elif elem == pivot: equal.append(elem) else: greater.append(elem) return quick_sort(less) + equal + quick_sort(greater) else: return arr # В одну строку =) def qsort_one_line_mid(arr: List) -\u003e List: return ( arr if len(arr) \u003c 2 else qsort([val for val in arr if val \u003c arr[len(arr) // 2]]) + [arr[len(arr) // 2]] * arr.count(arr[len(arr) // 2]) + qsort([val for val in arr if val \u003e arr[len(arr) // 2]]) ) Существует параллельная версия быстрой сор­ тировки, которая сортирует массив за время О(n). More ","date":"11.02.2021","objectID":"/algorithms/:5:0","series":null,"tags":["base"],"title":"Алгоритмы","uri":"/algorithms/#быстрая-сортировка"},{"categories":["python-interview"],"content":"Хеш-таблицы aka «ассоциативные массивы», «словари», «отображения», «хеш­ карты», «хеши» В научной терминологии говорят, что хеш-функция «отображает строки на числа». Хеш-функция должна соответствовать некоторым требованиям: Быть последовательной Разным строкам должны соответствовать разные числа Коллизии Существует много разных стратегий обработки коллизий. Простейшая из них выглядит так: если несколько ключей отображаются на один элемент, в этом элементе создается связанный список. выбор хеш-функции действительно важен. Хеш-функция, отображаю­ щая все ключи на один элемент массива, никуда не годится. В идеале хеш-функция должна распределять ключи равномерно по всему хешу; если связанные списки становятся слишком длинными, работа с хеш- таблицей сильно замедляется. Но они не станут слишком длинными при использовании хорошей хеш-функции! ","date":"11.02.2021","objectID":"/algorithms/:6:0","series":null,"tags":["base"],"title":"Алгоритмы","uri":"/algorithms/#хеш-таблицы"},{"categories":["python-interview"],"content":"Поиск в ширину (BFS, Breadth-First Search) BFS - это алгоритм для решения задачи поиска кратчайшего пути. BFS помогает ответить на вопросы двух типов: тип 1: существует ли путь от узла А к узлу В? тип 2: как выглядит кратчайший путь от узла А к узлу В (нахо­дит путь с минимальным количеством сегментов)? Поиск в ширину выполняется за время O(V+E) ( V - количество вершин,Е - количество ребер). import collections def bfs(graph, root): visited, queue = set(), collections.deque([root]) visited.add(root) while queue: vertex = queue.popleft() for neighbour in graph[vertex]: if neighbour not in visited: visited.add(neighbour) queue.append(neighbour) BFS - это жадный алгоритм. ","date":"11.02.2021","objectID":"/algorithms/:7:0","series":null,"tags":["base"],"title":"Алгоритмы","uri":"/algorithms/#поиск-в-ширину-bfs-breadth-first-search"},{"categories":["python-interview"],"content":"Алгоритм Дейкстры Алгоритм Дейкстры - алгоритм на графах, изобретённый нидерландским учёным Эдсгером Дейкстрой в 1959 году. Находит кратчайшие пути от одной из вершин графа до всех остальных. Алгоритм работает только для графов без рёбер отрицательного веса.2 Для графов с отрицательными весами - алгоритм Беллмана-Форда. Ал­горитм Дейкстры работает только с направленными ациклическими графами, которые нередко обозначаются сокращением DAG (Directed Acyclic Graph). Алгоритм Дейкстры состоит из четырех шагов: Найти узел с наименьшей стоимостью (то есть узел, до которого можно добраться за минимальное время). Проверить, существует ли более дешевый путь к соседям этого узла, и если существует, обновить их стоимости. Повторять, пока это не будет сделано для всех узлов графа. Вычислить итоговый путь. Алгоритм Дейкстры - это жадный алгоритм. Свести задачу к решаемой BFS можно, но если заменить все рёбра неединичной длины n рёбрами длины 1, то граф очень разрастётся, и это приведёт к огромному числу действий при вычислении оптимального маршрута. Условие неотрицательности весов рёбер крайне важно и от него нельзя просто избавиться. Не получится свести задачу к решаемой алгоритмом Дейкстры, прибавив наибольший по модулю вес ко всем рёбрам. Это может изменить оптимальный маршрут. Попытка избавиться от отрицательных весов\" Попытка избавиться от отрицательных весов В оригинале путь проходит через a -\u003e b -\u003e c -\u003e d, а после добавления семёрки ко всем рёбрам, оптимальный путь проходит через a -\u003e c -\u003e d. Эффективная реализация предполагает использование кучи. Статья с кодом Статья на Хабре ","date":"11.02.2021","objectID":"/algorithms/:8:0","series":null,"tags":["base"],"title":"Алгоритмы","uri":"/algorithms/#алгоритм-дейкстры"},{"categories":["python-interview"],"content":"Жадные алгоритмы Жадный алгоритм прост: на каж­дом шаге он выбирает оптимальный вариант. В техни­ческой терминологии: на каждом шаге выбирается локально-оптимальное решение, а в итоге мы получаем глобально-оптимальное решение. Иногда идеальное - враг хорошего. В некоторых случаях достаточно алгоритма, способного решить задачу достаточно хорошо. И в таких областях жадные алгоритмы работают просто отлично, потому что они просто реализуются, а получен­ное решение обычно близко к оптимуму. Когда вычисление точного реше­ния занимает слишком много времени, применяется приближенный алго­ритм. Эффективность приближенного алгоритма оценивается по быстроте и близости полученного решения к оптимальному. ","date":"11.02.2021","objectID":"/algorithms/:9:0","series":null,"tags":["base"],"title":"Алгоритмы","uri":"/algorithms/#жадные-алгоритмы"},{"categories":["python-interview"],"content":"NP-полные задачи Задача о коммивояжере и задача покрытия множества Не существует простого способа определить, является ли задача, с которой вы работаете, NР-полной. Несколько характерных признаков: алгоритм быстро работает при малом количестве элементов, но сильно замедляется при увеличении их числа; формулировка «все комбинации х» часто указывает на NР-полноту за­дачи; приходится вычислять все возможные варианты Х, потому что за­дачу невозможно разбить на меньшие подзадачи? Такая задача может оказаться NР-полной; если в задаче встречается некоторая последовательность (например, последовательность городов, как в задаче о коммивояжере) и задача не имеет простого решения, она может оказаться NР-полной; если в задаче встречается некоторое множество и задача не имеет простого решения, она может оказаться NР-полной; можно ли переформулировать задачу в условиях задачи покрытия множества или задачи о коммивояжере? В таком случае задача определенно является NР-полной. У NР-полных задач не существует известных быстрых решений. ","date":"11.02.2021","objectID":"/algorithms/:10:0","series":null,"tags":["base"],"title":"Алгоритмы","uri":"/algorithms/#np-полные-задачи"},{"categories":["python-interview"],"content":"Динамическое программирование Динамическое программирование применяется при оптимизации не­ которой характеристики. Динамическое программирование работает только в ситуациях, в кото­рых задача может быть разбита на автономные подзадачи. В каждом решении из области динамического программирования стро­ится таблица. Значения ячеек таблицы обычно соответствуют оптимизируемой харак­теристике. Каждая ячейка представляет подзадачу, поэтому нужно думать о том, как разбить задачу на подзадачи. Не существует единой формулы для вычисления решений методом ди­намического программирования. Расстояние Левенштейна оцени­вает, насколько похожи две строки , а для его вычисления применяется динамическое программирование. ","date":"11.02.2021","objectID":"/algorithms/:11:0","series":null,"tags":["base"],"title":"Алгоритмы","uri":"/algorithms/#динамическое-программирование"},{"categories":["python-interview"],"content":"Алгоритм Фейнмана Алгоритм Фейнмана, названный по имени известного физика Ричарда Фейнмана, работает так: Записать формулировку задачи. Хорошенько подумать. Записать решение. ","date":"11.02.2021","objectID":"/algorithms/:12:0","series":null,"tags":["base"],"title":"Алгоритмы","uri":"/algorithms/#алгоритм-фейнмана"},{"categories":["python-interview"],"content":"Алгоритм k ближайших соседей Алгоритм k ближайших соседей применяется для классификации и ре­грессии. В нем используется проверка k ближайших соседей. Классификация = распределение по категориям. Регрессия = прогнозирование результата. «Извлечением признаков» называется преобразование элемента в список чисел, которые могут ис­пользоваться для сравнения. Качественный выбор признаков - важная часть успешного алгоритма k ближайших соседей. ","date":"11.02.2021","objectID":"/algorithms/:13:0","series":null,"tags":["base"],"title":"Алгоритмы","uri":"/algorithms/#алгоритм-k-ближайших-соседей"},{"categories":["python-interview"],"content":"Преобразование Фурье ","date":"11.02.2021","objectID":"/algorithms/:14:0","series":null,"tags":["base"],"title":"Алгоритмы","uri":"/algorithms/#преобразование-фурье"},{"categories":["python-interview"],"content":"Фильтры Блума и Hyperloglog ","date":"11.02.2021","objectID":"/algorithms/:15:0","series":null,"tags":["base"],"title":"Алгоритмы","uri":"/algorithms/#фильтры-блума-и-hyperloglog"},{"categories":["python-interview"],"content":"Параллельные алгоритмы ","date":"11.02.2021","objectID":"/algorithms/:16:0","series":null,"tags":["base"],"title":"Алгоритмы","uri":"/algorithms/#параллельные-алгоритмы"},{"categories":["python-interview"],"content":"Распределенные алгоритмы ","date":"11.02.2021","objectID":"/algorithms/:17:0","series":null,"tags":["base"],"title":"Алгоритмы","uri":"/algorithms/#распределенные-алгоритмы"},{"categories":["python-interview"],"content":"Алгоритмы SHA ","date":"11.02.2021","objectID":"/algorithms/:18:0","series":null,"tags":["base"],"title":"Алгоритмы","uri":"/algorithms/#алгоритмы-sha"},{"categories":["python-interview"],"content":"Алгоритм Диффи-Хеллмана ","date":"11.02.2021","objectID":"/algorithms/:19:0","series":null,"tags":["base"],"title":"Алгоритмы","uri":"/algorithms/#алгоритм-диффи-хеллмана"},{"categories":["python-interview"],"content":"Линейное программирование Направленный / ненаправленный граф Взвешенный / невзвешенный граф Дерево в-деревья; красно-черные деревья; кучи; скошенные (splay) деревья. О-большое (Wiki) ↩︎ Алгоритм Дейкстры ↩︎ ","date":"11.02.2021","objectID":"/algorithms/:20:0","series":null,"tags":["base"],"title":"Алгоритмы","uri":"/algorithms/#линейное-программирование"},{"categories":["python-interview"],"content":"Интроспекция (introspection) — это способность объекта во время выполнения получить тип, доступные атрибуты и методы, а также другую информацию, необходимую для выполнения дополнительных операций с объектом.","date":"11.02.2021","objectID":"/introspection-in-python/","series":null,"tags":["python"],"title":"Интроспекция в Python","uri":"/introspection-in-python/"},{"categories":["python-interview"],"content":"Список вопросов к Python собеседованию ","date":"11.02.2021","objectID":"/introspection-in-python/:0:0","series":null,"tags":["python"],"title":"Интроспекция в Python","uri":"/introspection-in-python/#"},{"categories":["python-interview"],"content":"Определение понятия интроспекции Интроспекция (introspection) в контексте объектно-ориентированных языков программирования — это возможность запросить тип и структуру объекта во время выполнения программы. Среди языков, поддерживающих интроспекцию — C++ (с RTTI), Go, Java, Kotlin, JavaScript, Perl, Ruby, Smalltalk, PHP и Python. В PHP и Python интроспекция интегрирована в сам язык. В Python интроспекция может быть функционально реализована с помощью: встроенных методов dir(), type(), isinstance(), hasattr(), id(); встроенного модуля inspect; идти непосредственно от имени объекта с помощью встроенных аттрибутов __class__ и __dict__. Пользоваться интроспекцией в Python особенно удобно, благодаря парадигме, что “всё является объектом”. Любая сущность, являясь объектом, имеет метаданные (данные об объекте), называемые аттрибутами, и связаные с этой сущностью функциональности, называемые методами. В Python новый класс по-умолчанию является сам по себе объектом метакласса type. Наиболее часто используемые функции интроспекции в Python: ","date":"11.02.2021","objectID":"/introspection-in-python/:1:0","series":null,"tags":["python"],"title":"Интроспекция в Python","uri":"/introspection-in-python/#определение-понятия-интроспекции"},{"categories":["python-interview"],"content":"dir() Предоставляет список атрибутов и методов, доступных для указанного объекта, который может быть объявленной переменной или функцией. Возвращаемое значение это отсортированный в алфавитном порядке список. При вызове функции dir() без аргумента она возвращает имена, доступные в локальной области видимости. a = [1, 2, 3] dir(a) # ['__add__', '__class__', '__contains__', ... , 'sort'] ","date":"11.02.2021","objectID":"/introspection-in-python/:2:0","series":null,"tags":["python"],"title":"Интроспекция в Python","uri":"/introspection-in-python/#dir"},{"categories":["python-interview"],"content":"type() Возвращает тип объекта, который может быть примитивным типом данных, объектом, классом или модулем. Можно напрямую сравнить возвращаемое значение с типом, который мы хотим проверить, используя == или is. type(8.7) # \u003cclass 'float'\u003e type(\"test\") == int # False type((7, 5,)) is tuple # True ","date":"11.02.2021","objectID":"/introspection-in-python/:3:0","series":null,"tags":["python"],"title":"Интроспекция в Python","uri":"/introspection-in-python/#type"},{"categories":["python-interview"],"content":"isinstance() Позволяет определить, является ли определенный объект экземпляром указанного класса. isinstance() может принимать кортеж в качестве второго аргумента, isinstance([1,2], list) # True isinstance([1,2], tuple) # False isinstance(1, (int, float, tuple)) # True type() vs isinstance() При использовании type() проводится сравнение один к одному. По сути, мы сравниваем тип объекта с типом, который мы указали, чтобы проверить, совпадают ли они. isinstance() является более гибкой функцией. Фактически она определяет, является ли объект экземпляром указанного класса (классов) или его подкласса. Для isinstance() экземпляр подкласса также является экземпляром базового класса. Другими словами, она сравнивает объект со списком потенциально релевантных классов, что является своего рода сравнением один к нескольким. ","date":"11.02.2021","objectID":"/introspection-in-python/:4:0","series":null,"tags":["python"],"title":"Интроспекция в Python","uri":"/introspection-in-python/#isinstance"},{"categories":["python-interview"],"content":"hasattr() Функция hasattr() проверяет существование атрибута с именем name в объекте object. Возвращает True, если атрибут существует, иначе False. Реализация функция hasattr() основывается на вызове функции getattr() с последующей проверкой на предмет брошенного ей исключения AttributeError. x = ('one', 'two', 'boom') hasattr(x, 'some_attr') # False hasattr(x, 'count') # True ","date":"11.02.2021","objectID":"/introspection-in-python/:5:0","series":null,"tags":["python"],"title":"Интроспекция в Python","uri":"/introspection-in-python/#hasattr"},{"categories":["python-interview"],"content":"id() Функция id() возвращает уникальный идентификатор для указанного объекта. x = ('one', 'two', 'boom') id(x) # 140575915669688 В CPython идентификатор объекта — это адрес объекта в памяти. Все объекты в Python имеют свой уникальный идентификатор. Идентификатор присваивается объекту при его создании. Идентификатор является адресом памяти объекта и будет отличаться при каждом запуске программы. Объекты могут иметь одинаковый идентификатор, если периоды их существования не пересекаются. Некоторые объекты могут иметь один и тот же идентификатор, например: мелкие целые от -5 до 256, True и False. ","date":"11.02.2021","objectID":"/introspection-in-python/:6:0","series":null,"tags":["python"],"title":"Интроспекция в Python","uri":"/introspection-in-python/#id"},{"categories":["python-interview"],"content":"Модуль inspect Модуль inspect также предоставляет несколько полезных функций для получения информации об объектах. Например, можно проверить элементы объекта: import inspect print(inspect.getmembers(str)) # Output: [('__add__', \u003cslot wrapper '__add__' of ... ... Источники: Wiki Интроспекция в Python ","date":"11.02.2021","objectID":"/introspection-in-python/:7:0","series":null,"tags":["python"],"title":"Интроспекция в Python","uri":"/introspection-in-python/#модуль-inspect"},{"categories":["python-interview"],"content":"Область видимости или scope определяет контекст переменной, в рамках которого ее можно использовать. В Python есть три типа контекста: глобальный, локальный и нелокальный.","date":"11.02.2021","objectID":"/python-scope-of-variables/","series":null,"tags":["python"],"title":"Область видимости переменных в Python","uri":"/python-scope-of-variables/"},{"categories":["python-interview"],"content":"Список вопросов к Python собеседованию Область видимости (scope) определяет контекст переменной, в рамках которого ее можно использовать. В Python существует три области видимости: локальная глобальная нелокальная Основные моменты: Изнутри функции видны переменные, которые были определены и внутри нее и снаружи. Переменные, определенные внутри функции – локальные, снаружи – глобальные. Снаружи функций не видны никакие переменные, определенные внутри них. Изнутри функции можно изменять значение переменных, которые определены в глобальной области видимости с помощью спецификатора global. Изнутри вложенной функции с помощью спецификатора nonlocal можно изменять значения переменных, которые были определены во внешней функции, но не находятся в глобальной области видимости. Источники: Хабр статья Документация Python ","date":"11.02.2021","objectID":"/python-scope-of-variables/:0:0","series":null,"tags":["python"],"title":"Область видимости переменных в Python","uri":"/python-scope-of-variables/#"},{"categories":null,"content":"Основные шаги по настройке VPS с Ubuntu 20.04 для деплоя проекта. Установка Docker и Docker Compose, настройка UFW.","date":"11.04.2020","objectID":"/ubuntu-setup-for-python-stack/","series":null,"tags":["linux"],"title":"Настройка Ubuntu 20.04 для развертывания проекта в Docker","uri":"/ubuntu-setup-for-python-stack/"},{"categories":null,"content":"У нас имеется VPS с Ubuntu 20.04, нужно настроить его для развертывания проекта. ","date":"11.04.2020","objectID":"/ubuntu-setup-for-python-stack/:0:0","series":null,"tags":["linux"],"title":"Настройка Ubuntu 20.04 для развертывания проекта в Docker","uri":"/ubuntu-setup-for-python-stack/#"},{"categories":null,"content":"Первые шаги # Обновим apt update \u0026\u0026 sudo apt upgrade -y # Создаем нового юзера adduser www \u0026\u0026 usermod -aG sudo www # password for sudo - off sudo visudo # %sudo ALL=(ALL:ALL) NOPASSWD:ALL Выходим с сервера и копируем ssh-key ssh-copy-id www@ip Заходим под пользователем www и продолжаем настройку. Отключим возможность заходить под root, а так же возможность логиниться по паролю:1 sudo vim /etc/ssh/sshd_config # Ищем и исправляем следующие строки: # AllowUsers www # PermitRootLogin no # PasswordAuthentication no sudo systemctl restart sshd ","date":"11.04.2020","objectID":"/ubuntu-setup-for-python-stack/:1:0","series":null,"tags":["linux"],"title":"Настройка Ubuntu 20.04 для развертывания проекта в Docker","uri":"/ubuntu-setup-for-python-stack/#первые-шаги"},{"categories":null,"content":"Настройка UFW Настроим фаервол UFW:2 sudo ufw allow OpenSSH \u0026\u0026 sudo ufw allow http \u0026\u0026 sudo ufw allow https sudo ufw enable sudo ufw status ","date":"11.04.2020","objectID":"/ubuntu-setup-for-python-stack/:2:0","series":null,"tags":["linux"],"title":"Настройка Ubuntu 20.04 для развертывания проекта в Docker","uri":"/ubuntu-setup-for-python-stack/#настройка-ufw"},{"categories":null,"content":"zsh + Oh-My-zsh Установим zsh и Oh-My-zsh и настроим тему powerlevel10k: sudo apt install zsh -y # reconnect sh -c \"$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\" git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/themes/powerlevel10k vim ~/.zshrc # ZSH_THEME=\"powerlevel10k/powerlevel10k\" # alias cls=\"clear\" source ~/.zshrc ","date":"11.04.2020","objectID":"/ubuntu-setup-for-python-stack/:3:0","series":null,"tags":["linux"],"title":"Настройка Ubuntu 20.04 для развертывания проекта в Docker","uri":"/ubuntu-setup-for-python-stack/#zsh--oh-my-zsh"},{"categories":null,"content":"Установка Docker и Docker Compose Следующий шаг - установка Docker и Docker Compose3 sudo apt install apt-transport-https ca-certificates curl software-properties-common -y curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - sudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu focal stable\" sudo apt update apt-cache policy docker-ce sudo apt install docker-ce -y sudo systemctl status docker sudo usermod -aG docker ${USER} # Релогин id -nG Установка Docker Compose4 Свежий релиз Docker Compose sudo curl -L \"https://github.com/docker/compose/releases/download/v2.2.3/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose docker-compose --version ","date":"11.04.2020","objectID":"/ubuntu-setup-for-python-stack/:4:0","series":null,"tags":["linux"],"title":"Настройка Ubuntu 20.04 для развертывания проекта в Docker","uri":"/ubuntu-setup-for-python-stack/#установка-docker-и-docker-compose"},{"categories":null,"content":"Полезные утилиты # Free disk space df -h -t ext4 # process top # free memory free -h Настройка ключей SSH в Ubuntu 20.04 ↩︎ UFW Essentials: Common Firewall Rules and Commands ↩︎ Установка и использование Docker в Ubuntu 20.04 ↩︎ Установка и использование Docker Compose в Ubuntu 20.04 ↩︎ ","date":"11.04.2020","objectID":"/ubuntu-setup-for-python-stack/:5:0","series":null,"tags":["linux"],"title":"Настройка Ubuntu 20.04 для развертывания проекта в Docker","uri":"/ubuntu-setup-for-python-stack/#полезные-утилиты"},{"categories":["notes"],"content":"Django Cookiecutter commands","date":"11.10.2019","objectID":"/cookiecutter-commands/","series":null,"tags":["django"],"title":"Django Cookiecutter commands","uri":"/cookiecutter-commands/"},{"categories":["notes"],"content":" pip install \"cookiecutter\u003e=1.7.0\" sudo docker-compose -f production.yml build sudo docker-compose -f production.yml down sudo docker-compose -f production.yml up -d sudo docker-compose -f production.yml run --rm django python manage.py migrate sudo docker-compose -f production.yml logs sudo docker-compose -f production.yml run --rm django python manage.py shell -i ipython docker-compose -f local.yml run --rm django python manage.py shell -i ipython from app.utils.import_countries import create_countries # Create db backup docker-compose -f local.yml exec postgres backup docker-compose -f production.yml exec postgres backup # DB backup list docker-compose -f local.yml exec postgres backups docker-compose -f production.yml exec postgres backups # Copy backup from docker to local (postgres - is container name) docker cp postgres:/backups . # Copy backup to docker docker cp backup_2021_09_10T09_23_12.sql.gz postgres:/backups docker cp ./backups/backup_2021_08_10T13_40_02.sql.gz allflags_postgres_1:/backups # Restoring from the Existing Backup docker-compose -f local.yml exec postgres restore backup_2021_09_10T09_23_12.sql.gz docker-compose -f production.yml exec postgres restore backup_2021_08_10T13_40_02.sql.gz ","date":"11.10.2019","objectID":"/cookiecutter-commands/:0:0","series":null,"tags":["django"],"title":"Django Cookiecutter commands","uri":"/cookiecutter-commands/#"},{"categories":["notes"],"content":"Git commands","date":"11.09.2019","objectID":"/git-commands/","series":null,"tags":["git"],"title":"Git commands","uri":"/git-commands/"},{"categories":["notes"],"content":" git init git add . git commit -m 'Description' git commit -a -m 'Description' # коммитит все файлы, не требует выполнять add git rm \u003cfile\u003e # -f если файл уже в коммите git rm --cached \u003cfile\u003e # Удалить файл из индекса, оставив его при этом в рабочем каталоге git mv \u003cfile_from\u003e \u003cfile_to\u003e git status (-s --short) git reset HEAD \u003cfile\u003e git clone [url] git filter-branch --force --index-filter \\ \"git rm --cached --ignore-unmatch PATH-TO-YOUR-FILE-WITH-SENSITIVE-DATA\" \\ --prune-empty --tag-name-filter cat -- --all git push origin --force --all git push origin --force --tags # Branches git branch # Список веток git branch \u003cbranch_name\u003e git checkout \u003cbranch_name\u003e git checkout -b \u003cbranch_name\u003e # Предыдущие 2 команды в одну строку # Слияние с master git checkout master git merge \u003cbranch_name\u003e git branch -d \u003cbranch_name\u003e # Удаление ветки git remote -v # внешний репозиторий git remote add origin https://github.com/baikov/baikov.dev.git # Rename git branch -m \u003coldname\u003e \u003cnewname\u003e # If you want to rename the current branch, you can do: git branch -m \u003cnewname\u003e # If you want to push the local branch and reset the upstream branch: git push origin -u \u003cnewname\u003e # And finally if you want to Delete the remote branch: git push origin --delete \u003coldname\u003e ","date":"11.09.2019","objectID":"/git-commands/:0:0","series":null,"tags":["git"],"title":"Git commands","uri":"/git-commands/#"},{"categories":["notes"],"content":"Just badges","date":"11.08.2019","objectID":"/github-badges/","series":null,"tags":["github"],"title":"GitHub badges","uri":"/github-badges/"},{"categories":["notes"],"content":"Подробнее на странице автора1 ","date":"11.08.2019","objectID":"/github-badges/:0:0","series":null,"tags":["github"],"title":"GitHub badges","uri":"/github-badges/#"},{"categories":["notes"],"content":"GitHub stats \u003cimg src=\"https://github-readme-stats.vercel.app/api?username=baikov\u0026count_private=true\u0026hide_title=true\u0026hide=issues,contribs\u0026show_icons=true\u0026theme=calm\u0026text_color=#fff\u0026icon_color=#e31e25\u0026border_color=#e31e25\"\u003e ","date":"11.08.2019","objectID":"/github-badges/:1:0","series":null,"tags":["github"],"title":"GitHub badges","uri":"/github-badges/#github-stats"},{"categories":["notes"],"content":"Repo info \u003ca href=\"https://github.com/baikov/allflags\"\u003e \u003cimg src=\"https://github-readme-stats.vercel.app/api/pin/?username=baikov\u0026repo=traefik-prometheus\u0026theme=calm\u0026border_color=#e31e25\" /\u003e \u003c/a\u003e \u003ca href=\"https://github.com/baikov/allflags\"\u003e \u003cimg src=\"https://github-readme-stats.vercel.app/api/pin/?username=baikov\u0026repo=allflags\u0026border_color=#e31e25\u0026text_color=#ffffff\u0026title_color=#ffffff\" /\u003e \u003c/a\u003e ","date":"11.08.2019","objectID":"/github-badges/:2:0","series":null,"tags":["github"],"title":"GitHub badges","uri":"/github-badges/#repo-info"},{"categories":["notes"],"content":"Github top langs \u003cimg id=\"elem\" src=\"https://github-readme-stats.vercel.app/api/top-langs/?username=baikov\" /\u003e ","date":"11.08.2019","objectID":"/github-badges/:3:0","series":null,"tags":["github"],"title":"GitHub badges","uri":"/github-badges/#github-top-langs"},{"categories":["notes"],"content":"GitHub activity \u003cimg id=\"elem\" src=\"https://ghchart.rshah.org/e31e25/baikov\" /\u003e GitHub Readme Stats ↩︎ ","date":"11.08.2019","objectID":"/github-badges/:4:0","series":null,"tags":["github"],"title":"GitHub badges","uri":"/github-badges/#github-activity"}]