[{"categories":["howto"],"content":"Устанавливаем и настраиваем редактор Neovim для комфортной работы с Python. Все необходимые плагины: от автодополнения до подсветки ошибок.","date":"21.12.2020","objectID":"/neovim-settings/","series":null,"tags":["vim","neovim"],"title":"Установка и настройка Neovim","uri":"/neovim-settings/"},{"categories":["howto"],"content":"Установка Neovim Сверхрасширяемый текстовый редактор на основе Vim1 brew install neovim ","date":"21.12.2020","objectID":"/neovim-settings/:1:0","series":null,"tags":["vim","neovim"],"title":"Установка и настройка Neovim","uri":"/neovim-settings/#установка-neovim"},{"categories":["howto"],"content":"Установка vim-plugМинималистичный менеджер плагинов Vim.2 curl -fLo ~/.config/nvim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim ","date":"21.12.2020","objectID":"/neovim-settings/:2:0","series":null,"tags":["vim","neovim"],"title":"Установка и настройка Neovim","uri":"/neovim-settings/#установка-vim-plug"},{"categories":["howto"],"content":"Файл конфигурации Neovim для MacСоздаем файл ~/.comfig/nvim/init.vim со следующим содержимым: \" Baseset mouse=aset encoding=utf-8set numberset noswapfileset scrolloff=7set tabstop=4set softtabstop=4set shiftwidth=4set expandtabset autoindentset fileformat=unixset t_Co=256set guifont=Monaco:h18set colorcolumn=120\" load filetype-specific indent filesfiletype indent on\" Pluginscall plug#begin('~/.config/nvim/plugged')Plug 'neovim/nvim-lspconfig'Plug 'hrsh7th/nvim-cmp'Plug 'hrsh7th/cmp-nvim-lsp'Plug 'saadparwaiz1/cmp_luasnip'Plug 'L3MON4D3/LuaSnip'\" color schemas\"Plug 'morhetz/gruvbox' \" colorscheme gruvboxPlug 'mhartington/oceanic-next' \" colorscheme OceanicNext\"Plug 'kaicataldo/material.vim', { 'branch': 'main' }\"Plug 'ayu-theme/ayu-vim'\" For JS/JSXPlug 'yuezk/vim-js'Plug 'maxmellon/vim-jsx-pretty'Plug 'scrooloose/nerdtree'Plug 'tpope/vim-surround'Plug 'tpope/vim-fugitive'Plug 'tpope/vim-commentary'Plug 'mattn/emmet-vim'\"Plug 'davidhalter/jedi-vim'Plug 'klen/python-mode'\"Plug 'ambv/black'\"Plug 'nvie/vim-flake8'Plug 'mitsuhiko/vim-jinja'Plug 'git://git.wincent.com/command-t.git'\"Plugin 'flazz/vim-colorschemes'Plug 'alvan/vim-closetag'call plug#end()\"colorscheme gruvboxcolorscheme OceanicNext\"let g:material_terminal_italics = 1\" variants: default, palenight, ocean, lighter, darker, default-community,\" palenight-community, ocean-community, lighter-community,\" darker-community\"let g:material_theme_style = 'darker'\"colorscheme materialif (has('termguicolors')) set termguicolorsendif\" variants: mirage, dark, dark\"let ayucolor=\"mirage\"\"colorscheme ayulua \u003c\u003c EOF-- Set completeopt to have a better completion experiencevim.o.completeopt = 'menuone,noselect'-- luasnip setuplocal luasnip = require 'luasnip'-- nvim-cmp setuplocal cmp = require 'cmp'cmp.setup { completion = { autocomplete = false }, snippet = { expand = function(args) require('luasnip').lsp_expand(args.body) end, }, mapping = { ['\u003cC-p\u003e'] = cmp.mapping.select_prev_item(), ['\u003cC-n\u003e'] = cmp.mapping.select_next_item(), ['\u003cC-d\u003e'] = cmp.mapping.scroll_docs(-4), ['\u003cC-f\u003e'] = cmp.mapping.scroll_docs(4), ['\u003cC-Space\u003e'] = cmp.mapping.complete(), ['\u003cC-e\u003e'] = cmp.mapping.close(), ['\u003cCR\u003e'] = cmp.mapping.confirm { behavior = cmp.ConfirmBehavior.Replace, select = true, }, ['\u003cTab\u003e'] = function(fallback) if vim.fn.pumvisible() == 1 then vim.fn.feedkeys(vim.api.nvim_replace_termcodes('\u003cC-n\u003e', true, true, true), 'n') elseif luasnip.expand_or_jumpable() then vim.fn.feedkeys(vim.api.nvim_replace_termcodes('\u003cPlug\u003eluasnip-expand-or-jump', true, true, true), '') else fallback() end end, ['\u003cS-Tab\u003e'] = function(fallback) if vim.fn.pumvisible() == 1 then vim.fn.feedkeys(vim.api.nvim_replace_termcodes('\u003cC-p\u003e', true, true, true), 'n') elseif luasnip.jumpable(-1) then vim.fn.feedkeys(vim.api.nvim_replace_termcodes('\u003cPlug\u003eluasnip-jump-prev', true, true, true), '') else fallback() end end, }, sources = { { name = 'nvim_lsp' }, { name = 'luasnip' }, },}EOFlua \u003c\u003c EOFlocal nvim_lsp = require('lspconfig')-- Use an on_attach function to only map the following keys-- after the language server attaches to the current bufferlocal on_attach = function(client, bufnr) local function buf_set_keymap(...) vim.api.nvim_buf_set_keymap(bufnr, ...) end local function buf_set_option(...) vim.api.nvim_buf_set_option(bufnr, ...) end -- Enable completion triggered by \u003cc-x\u003e\u003cc-o\u003e buf_set_option('omnifunc', 'v:lua.vim.lsp.omnifunc') -- Mappings. local opts = { noremap=true, silent=true } -- See `:help vim.lsp.*` for documentation on any of the below functions buf_set_keymap('n', 'gD', '\u003ccmd\u003elua vim.lsp.buf.declaration()\u003cCR\u003e', opts) buf_set_keymap('n', 'gd', '\u003ccmd\u003elua vim.lsp.buf.definition()\u003cCR\u003e', opts) buf_set_keymap('n', 'K', '\u003ccmd\u003elua vim.lsp.buf.hover()\u003cCR\u003e', opts) buf_set_keymap('n', 'gi', '\u003ccmd\u003elua vim.lsp.buf.implementation()\u003cCR\u003e', opts) buf_set_keymap('n', '\u003cC-k\u003e', '\u003ccmd\u003elua vim.lsp.buf.signature_help()\u003cCR\u003e', opts) buf_set_keymap('n', '\u003cspace\u003ewa', '\u003ccmd\u003elua vim.lsp.buf.add_workspace_folder()\u003cCR\u003e', opts) buf_set_keymap('n', '\u003cs","date":"21.12.2020","objectID":"/neovim-settings/:3:0","series":null,"tags":["vim","neovim"],"title":"Установка и настройка Neovim","uri":"/neovim-settings/#файл-конфигурации-neovim-для-mac"},{"categories":["howto"],"content":"Установка плагиновЗаходим в nvim и запускаем установку плагинов :PlugInstall И еще один полезный gist ","date":"21.12.2020","objectID":"/neovim-settings/:4:0","series":null,"tags":["vim","neovim"],"title":"Установка и настройка Neovim","uri":"/neovim-settings/#установка-плагинов"},{"categories":["howto"],"content":"nvim -d (вместо vimdiff)Добавляем в .zshrc / .bashrc: alias vimdiff='nvim -d' Neovim ↩︎ vim-plug ↩︎ alexey-goloburdin/nvim-config ↩︎ БОЖЕСТВЕННЫЙ nvim как IDE для Python, Rust и всех-всех-всех — встречаем LSP! ↩︎ ","date":"21.12.2020","objectID":"/neovim-settings/:5:0","series":null,"tags":["vim","neovim"],"title":"Установка и настройка Neovim","uri":"/neovim-settings/#nvim--d-вместо-vimdiff"},{"categories":null,"content":"Описание","date":"08.12.2021","objectID":"/skills/","series":null,"tags":null,"title":"Навыки","uri":"/skills/"},{"categories":null,"content":"Актуальные навыки Языки: Python, JavaScript Backend: Django, Flask, Celery, Flower API: Django REST Framework, JSON APIs Тестирование: Unit тестирование Frontend: HTML (flex, grid), CSS3 (BEM), SASS (SCSS), Bootstrap (2, 3, 4), Vue.js, Webpack, Gulp, npm, DevTools, SSG (Hugo) БД: PostgreSQL, Redis, SQLite Cloud platform: Reg.ru, AWS, Yandex.Cloud Web servers: Nginx, Traefik Web security: HTTPS, SSL/TLS, CORS Мониторинг: Prometheus, Grafana Другое: Docker, Docker Compose, Git, GitHub, git-flow, github-flow, Follow the \"Twelve factor app\", Sphinx CI/CD: GitHub Actions Tools: VSCode, iTerm2 + zsh + oh-my-zsh, Vim Neovim, Homebrew OS: MacOS, Linux (Debian, Ubuntu) Навыки в смежных сферах SEO: Link building, аудит, техническая оптимизация Web analytics: GTM, Google Analytics, Yandex Metrica, PowerBI Web security: pentesting, XSS, CSRF, SQL-Injection OS: Kali Linux Планирую изучить Языки: Go Backend: aiohttp, sqlalchemy, RabbitMQ, RPC, asyncio API: FastAPI, GraphQL, gRPC Тестирование: Integration Тестирование, Functional Тестирование, Selenium Мониторинг: Datadog Frontend: VueX, SSR (Nuxt.js), Pre-rendering, Bootstrap 5 БД: MongoDB CI/CD: Circle CI, Travis CI, Jenkins Другое: Elasticsearch, Kubernetes, Ansible, Agile Development \u0026 Scrum С чем работал раньше Языки: PHP, Java, C++, Perl Frontend: jQuery, LESS, SSG (Jekyll) Design: Axure, Photoshop БД: MySQL CMS: 1C-Bitrix, Wordpress, OpenCart, Joomla, InstantCMS Tools: MS Visual Studio, SublimeText, Atom, bash OS: Linux (Mint, Ubuntu), Windows (98, 2000, XP, 7, 8, 10) Hosting and cloud platforms: Heroku, DigitalOcean, HostSailor, nic.ru Web servers: Apache ","date":"08.12.2021","objectID":"/skills/:0:0","series":null,"tags":null,"title":"Навыки","uri":"/skills/#"},{"categories":["django","drf"],"content":"Тесты писать нужно. На первй взгляд кажется, что это отнимает много времени, но в итоге окажется, что гораздо больше времени будет сэкономлено не только себе будущему, но и другим разработчикам.","date":"11.09.2022","objectID":"/django-drf-tests/","series":null,"tags":["unit-test"],"title":"Написание unit-тестов в Django и DRF","uri":"/django-drf-tests/"},{"categories":["django","drf"],"content":"SimpleTestCase и APISimpleTestCaseSimpleTestCase - подкласс unittest.TestCase, с расширенной функциональностью. Есть Client. Нет работы с БД. APISimpleTestCase - подкласс SimpleTestCase для тестирования DRF. Дополнительно использует APIClient. ","date":"11.09.2022","objectID":"/django-drf-tests/:1:0","series":null,"tags":["unit-test"],"title":"Написание unit-тестов в Django и DRF","uri":"/django-drf-tests/#simpletestcase-и-apisimpletestcase"},{"categories":["django","drf"],"content":"TestCase и APITestCaseTestCase - наиболее часто используемый класс для написания тестов в Django. Он наследуется от TransactionTestCase (и, соответственно, от SimpleTestCase). Обертывает тесты в два вложенных блока atomic(): один для всего класса и один для каждого теста. Проверяет отложенные ограничения базы данных в конце каждого теста. Имеет дополнительный метод setUpTestData() APITestCase - подкласс TestCase для тестирования DRF. Дополнительно использует APIClient. ","date":"11.09.2022","objectID":"/django-drf-tests/:2:0","series":null,"tags":["unit-test"],"title":"Написание unit-тестов в Django и DRF","uri":"/django-drf-tests/#testcase-и-apitestcase"},{"categories":["django","drf"],"content":"setUpTestData()Описанный выше блок atomic на уровне класса позволяет создавать начальные данные на уровне всего класса, один раз для всего TestCase. Эта техника позволяет ускорить тестирование по сравнению с использованием setUp(). class MyAppTests(APITestCase): @classmethod def setUpTestData(cls): # Set up data for the whole TestCase cls.foo = Foo.objects.create(bar=\"Test\") Изменения обектов из setUpTestData() в тестовых методах будут сохраняться между всеми тестовыми методами. Изменения можно откатить в методе setUp(), например, с помощью refresh_from_db(). ","date":"11.09.2022","objectID":"/django-drf-tests/:3:0","series":null,"tags":["unit-test"],"title":"Написание unit-тестов в Django и DRF","uri":"/django-drf-tests/#setuptestdata"},{"categories":["django","drf"],"content":"Загрузка данных из fixturesПосле того, как мы создали файл с данными (например, в формате .json) и поместили его в каталог app/fixtures/ нашего приложения, можно использовать его в модульных тестах, указав атрибут класса fixtures в любом подклассе django.test.TestCase, например: class MyAppTests(APITestCase): fixtures = ['data_only_for_tests.json', ] Для улучшения производительности fixtures загружаются один раз для всего тестового класса. Это происходит перед вызовом setUpTestData(), а не перед каждым тестом, и использует транзакции для очистки базы данных перед каждым тестом. ","date":"11.09.2022","objectID":"/django-drf-tests/:4:0","series":null,"tags":["unit-test"],"title":"Написание unit-тестов в Django и DRF","uri":"/django-drf-tests/#загрузка-данных-из-fixtures"},{"categories":["django","drf"],"content":"Django JWT Token auth class MyAppTests(APITestCase): fixtures = ['data_only_for_tests.json'] @classmethod def setUpTestData(cls): cls.user_from_fixtures = User.objects.get(id=1) def jwt_auth(self, user): auth = self.client.post( '/api/api-token-auth/', {'email': user.email, 'password': self.password}, format='json' ) token = auth.data['token'] self.client.credentials(HTTP_AUTHORIZATION='JWT {0}'.format(token)) def test_something(self): user = self.user_from_fixtures self.jwt_auth(user=user) # ... Django Rest Framework JWT Unit Test Custom User Testing in Django ","date":"11.09.2022","objectID":"/django-drf-tests/:5:0","series":null,"tags":["unit-test"],"title":"Написание unit-тестов в Django и DRF","uri":"/django-drf-tests/#django-jwt-token-auth"},{"categories":["howto"],"content":"Интеграция .pre-commit hook в Django проект","date":"16.08.2022","objectID":"/precommit-config-djando/","series":null,"tags":["python","git","django"],"title":"Настройка pre-commit hooks для Django проекта","uri":"/precommit-config-djando/"},{"categories":["howto"],"content":"Git имеет в своем составе инструмент, который умеет запускать кастомные скрипты при наступлении какого-либо события (к примеру commit, push и т.п.). .pre-commit является надстройкой над стандартным git pre-commit hook, которая позволяет запускать скрипты описанные в .pre-commit-config.yaml перед созданием коммита. Это, например, позволяет поддерживать код проекта на Django в соответствии с принятыми стандартами PEP при минимальном личном участии. ","date":"16.08.2022","objectID":"/precommit-config-djando/:0:0","series":null,"tags":["python","git","django"],"title":"Настройка pre-commit hooks для Django проекта","uri":"/precommit-config-djando/#"},{"categories":["howto"],"content":"Установка pre-commitСтандартные шаги расписывать не буду (перейти в папку проекта, активировать виртуальное окружение). Устанавливаем pre-commit pip install pre-commit Если нужна определенная версия - устанавливаем нужную. Например, для python 3.5 последняя совместимая версия 1.21.0 pip install pre-commit==1.21.0 ","date":"16.08.2022","objectID":"/precommit-config-djando/:1:0","series":null,"tags":["python","git","django"],"title":"Настройка pre-commit hooks для Django проекта","uri":"/precommit-config-djando/#установка-pre-commit"},{"categories":["howto"],"content":"Файл настроек .pre-commit-config.yamlНастройки пре-коммита находятся в файле .pre-commit-config.yaml. Я добавил только самые основные, но вариаций тут масса, хоть тесты на прекоммите прогоняй. ","date":"16.08.2022","objectID":"/precommit-config-djando/:2:0","series":null,"tags":["python","git","django"],"title":"Настройка pre-commit hooks для Django проекта","uri":"/precommit-config-djando/#файл-настроек-pre-commit-configyaml"},{"categories":["howto"],"content":"Установка хуков pre-commit install Устанавливает хуки в .git/hooks/pre-commit Предварительно лучше удалить старый файл pre-commit (или переименовать) или удалить оттуда кусок с автопепом, иначе вылезет конфликт вызова автопепа у тех, кто настраивал прекоммит по инструкции из ридми. ","date":"16.08.2022","objectID":"/precommit-config-djando/:3:0","series":null,"tags":["python","git","django"],"title":"Настройка pre-commit hooks для Django проекта","uri":"/precommit-config-djando/#установка-хуков"},{"categories":["howto"],"content":"Настройки autopep8, black, flake8 и isortНастройки поведения autopep8 и isort находятся в файле setup.cfg. Можно настроить как угодно и это гораздо прозрачнее, чем в текущем варианте. По дальнейшему процессу использования ничем не отличается от текущего варианта: коммитим, прекоммит переписывает файлы, делаем add еще раз, снова коммитим. Все. Источники: Сайт и документация Список хуков Интеграция .pre-commit hook в Django проект Understanding install vs install –install-hooks Tool Your Django Project: Pre-Commit Hooks ","date":"16.08.2022","objectID":"/precommit-config-djando/:4:0","series":null,"tags":["python","git","django"],"title":"Настройка pre-commit hooks для Django проекта","uri":"/precommit-config-djando/#настройки-autopep8-black-flake8-и-isort"},{"categories":["errors"],"content":"Ошибка при установке устаревших версий Python с обнаруженными уязвимостями на новых версиях MacOS (выше Catalina). Попытки и способы установить эти версии.","date":"05.07.2022","objectID":"/build-failed-osx-using-python-build-20180424/","series":null,"tags":["error","solution","python","macos"],"title":"Ошибка установки устаревших версий Python - BUILD FAILED (OS X 12.x using python-build 20180424)","uri":"/build-failed-osx-using-python-build-20180424/"},{"categories":["errors"],"content":"UPD Наиболее логичный вариант - использовать последнюю версию нужной ветки. Например, вместо python 3.7.3 поставить python 3.7.13. ","date":"05.07.2022","objectID":"/build-failed-osx-using-python-build-20180424/:0:0","series":null,"tags":["error","solution","python","macos"],"title":"Ошибка установки устаревших версий Python - BUILD FAILED (OS X 12.x using python-build 20180424)","uri":"/build-failed-osx-using-python-build-20180424/#"},{"categories":["errors"],"content":"Причина ошибкиПокопавшись в том, что приводит к ошибке выяснилось, что старым версиям python не нравится компилятор С/С++, который идет в комплекте с CommandLine Tools. Из чего следует, что нужно поставить другую версию этого компилятора и подсунуть ее при установке. В новых версиях MacOS (видимо, свежее Catalina) Apple перестал поддерживать старые версии python из-за наличия обнаруженных в них уязвимостей. Например, из ветки python 3.7 нормально будут ставиться python \u003e=3.7.4. При этом некоторые старые версии все же удалось поставить при помощи описанных ниже манипуляций. Поставились версии 3.5.3, 3.5.10, 3.6.0 ","date":"05.07.2022","objectID":"/build-failed-osx-using-python-build-20180424/:1:0","series":null,"tags":["error","solution","python","macos"],"title":"Ошибка установки устаревших версий Python - BUILD FAILED (OS X 12.x using python-build 20180424)","uri":"/build-failed-osx-using-python-build-20180424/#причина-ошибки"},{"categories":["errors"],"content":"Подмена библиотек из commandline-tools в cmake Установим необходимые библиотеки через brew brew install pyenv bzip2 zlib xz openssl@1.1 Подсунем их при установке вместо аналогов из CommandLine Tools CFLAGS=\"-I$(brew --prefix openssl)/include -I$(brew --prefix bzip2)/include -I$(brew --prefix readline)/include -I$(xcrun --show-sdk-path)/usr/include\" LDFLAGS=\"-L$(brew --prefix openssl)/lib -L$(brew --prefix readline)/lib -L$(brew --prefix zlib)/lib -L$(brew --prefix bzip2)/lib\" pyenv install 3.7.13 ","date":"05.07.2022","objectID":"/build-failed-osx-using-python-build-20180424/:2:0","series":null,"tags":["error","solution","python","macos"],"title":"Ошибка установки устаревших версий Python - BUILD FAILED (OS X 12.x using python-build 20180424)","uri":"/build-failed-osx-using-python-build-20180424/#подмена-библиотек-из-commandline-tools-в-cmake"},{"categories":["errors"],"content":"Смена компилятора Устанавливаем gcc через brew brew install gcc Меняем С compiler на установленный и в этой же строке ставим нужную версию python через патч (3.x.x - заменить нужной версией) CC=gcc-12 pyenv install --patch 3.x.x \u003c \u003c(curl -sSL https://github.com/python/cpython/commit/8ea6353.patch) gcc-12 тоже следует заменить на версию, которая была установлена через brew ","date":"05.07.2022","objectID":"/build-failed-osx-using-python-build-20180424/:3:0","series":null,"tags":["error","solution","python","macos"],"title":"Ошибка установки устаревших версий Python - BUILD FAILED (OS X 12.x using python-build 20180424)","uri":"/build-failed-osx-using-python-build-20180424/#смена-компилятора"},{"categories":["errors"],"content":"Проблема на Apple с процессором M1На Macbook с процессорами Apple Silicon (M1 и т.п.) может вывалиться еще одна ошибка: configure: error: Unexpected output of 'arch' on OSX В этом случае можно попробовать добавить в команду установки еще одну инструкцию: CC=gcc-12 arch -x86_64 pyenv install --patch 3.5.3 \u003c \u003c(curl -sSL https://github.com/python/cpython/commit/8ea6353.patch) Если это не помогло, советуют запустить терминал через Rosetta 2 и попробовать установить командой из п.2. Дальше не копал, т.к. у меня нет мака на M1. ","date":"05.07.2022","objectID":"/build-failed-osx-using-python-build-20180424/:4:0","series":null,"tags":["error","solution","python","macos"],"title":"Ошибка установки устаревших версий Python - BUILD FAILED (OS X 12.x using python-build 20180424)","uri":"/build-failed-osx-using-python-build-20180424/#проблема-на-apple-с-процессором-m1"},{"categories":["errors"],"content":"3.7.3 на MacOS MontereyПри всем этом установка python 3.7.3 валится с ошибкой именно на MacOS Monterey (а точнее - выше Catalina): pyenv install 3.7.3 # faild BUILD FAILED (OS X 12.5 using python-build 20180424) #... Last 10 log lines: checking for --with-cxx-main=\u003ccompiler\u003e... no checking for clang++... no configure: By default, distutils will build C++ extension modules with \"clang++\". If this is not intended, then set CXX on the configure command line. checking for the platform triplet based on compiler characteristics... darwin configure: error: internal configure error for the platform triplet, please file a bug report make: *** No targets specified and no makefile found. Stop. pyenv install --patch 3.7.3 \u003c \u003c(curl -sSL https://github.com/python/cpython/commit/8ea6353.patch) # faild BUILD FAILED (OS X 12.5 using python-build 20180424) #... Last 10 log lines: checking for --with-cxx-main=\u003ccompiler\u003e... no checking for clang++... no configure: By default, distutils will build C++ extension modules with \"clang++\". If this is not intended, then set CXX on the configure command line. checking for the platform triplet based on compiler characteristics... darwin configure: error: internal configure error for the platform triplet, please file a bug report make: *** No targets specified and no makefile found. Stop. CC=gcc-12 pyenv install 3.7.3 # faild BUILD FAILED (OS X 12.5 using python-build 20180424) #... make: *** [Modules/posixmodule.o] Error 1 make: *** Waiting for unfinished jobs.... CC=gcc-12 pyenv install --patch 3.7.3 \u003c \u003c(curl -sSL https://github.com/python/cpython/commit/8ea6353.patch) # faild BUILD FAILED (OS X 12.5 using python-build 20180424) #... Last 10 log lines: if test \"xupgrade\" != \"xno\" ; then \\ case upgrade in \\ upgrade) ensurepip=\"--upgrade\" ;; \\ install|*) ensurepip=\"\" ;; \\ esac; \\ ./python.exe -E -m ensurepip \\ $ensurepip --root=/ ; \\ fi /bin/sh: line 1: 84288 Segmentation fault: 11 ./python.exe -E -m ensurepip $ensurepip --root=/ make: *** [install] Error 139 Если категорически нужна именно неподдерживаемая версия, можно поковырять следующие варианты решения: даунгрэйд gcc-12 до gcc-10 (не пробовал) brew install clang; CC=clang pyenv install ... (не помогло) gist github issue Итог: установил python 3.7.13 ","date":"05.07.2022","objectID":"/build-failed-osx-using-python-build-20180424/:5:0","series":null,"tags":["error","solution","python","macos"],"title":"Ошибка установки устаревших версий Python - BUILD FAILED (OS X 12.x using python-build 20180424)","uri":"/build-failed-osx-using-python-build-20180424/#373-на-macos-monterey"},{"categories":["errors"],"content":"Советы из интернета Переустановить CommandLine Tools Выполнить команды: CFLAGS=\"-I$(brew --prefix readline)/include -I$(brew --prefix openssl)/include -I$(xcrun --show-sdk-path)/usr/include\" \\ LDFLAGS=\"-L$(brew --prefix readline)/lib -L$(brew --prefix openssl)/lib\" \\ PYTHON_CONFIGURE_OPTS=--enable-unicode=ucs2 \\ Ставим через патч pyenv install --patch 3.5.3 \u003c \u003c(curl -sSL https://github.com/python/cpython/commit/8ea6353.patch) Источники: PyEnv BUILD FAILED installing Python on MacOS Comment on Github ","date":"05.07.2022","objectID":"/build-failed-osx-using-python-build-20180424/:6:0","series":null,"tags":["error","solution","python","macos"],"title":"Ошибка установки устаревших версий Python - BUILD FAILED (OS X 12.x using python-build 20180424)","uri":"/build-failed-osx-using-python-build-20180424/#советы-из-интернета"},{"categories":["python-interview"],"content":"Разница между HTTP методами PUT и POST","date":"25.06.2022","objectID":"/difference-between-put-and-post/","series":null,"tags":["http-methods"],"title":"Разница между PUT и POST запросами","uri":"/difference-between-put-and-post/"},{"categories":["python-interview"],"content":"Список вопросов к Python собеседованию Разница между PUT и POST Разница между PUT и POST - stack Методы HTTP запроса ","date":"25.06.2022","objectID":"/difference-between-put-and-post/:0:0","series":null,"tags":["http-methods"],"title":"Разница между PUT и POST запросами","uri":"/difference-between-put-and-post/#"},{"categories":["python-interview"],"content":"Тестовое задание на позицию code-reviewer в Яндекс.Практикум состоит из нескольких вопросов и одного практического задания на ревью кода. Мои ответы прилагаются.","date":"04.06.2022","objectID":"/yandex-praktikum-reviewer-test-task/","series":null,"tags":["yandex"],"title":"Тестовое задание на вакансию Код-ревьюера в Яндекс.Практикум","uri":"/yandex-praktikum-reviewer-test-task/"},{"categories":["python-interview"],"content":"HR прислал на почту ссылку на Яндекс-форму с вопросами. На выполнение тестового задания дается 3 дня, но если времени мало - просят предупредить об этом заранее. Подробнее о вакансии. ","date":"04.06.2022","objectID":"/yandex-praktikum-reviewer-test-task/:0:0","series":null,"tags":["yandex"],"title":"Тестовое задание на вакансию Код-ревьюера в Яндекс.Практикум","uri":"/yandex-praktikum-reviewer-test-task/#"},{"categories":["python-interview"],"content":"Вопрос №1: DjangoРасскажите, чем отличается select_related от prefetch_related. Мой ответ select_related: используется, когда мы собираемся получить один связанный объект (OneToOne, ForeignKey); делает SQL join в том же запросе и возвращает результат как часть таблицы. prefetch_related: используется, когда мы собираемся получить набор объектов (ManyToMany, или обратная связь ForeignKey); выполняет дополнительный запрос к базе с набором id (SELECT \u003csomething\u003e WHERE pk IN (...)). ","date":"04.06.2022","objectID":"/yandex-praktikum-reviewer-test-task/:1:0","series":null,"tags":["yandex"],"title":"Тестовое задание на вакансию Код-ревьюера в Яндекс.Практикум","uri":"/yandex-praktikum-reviewer-test-task/#вопрос-1-django"},{"categories":["python-interview"],"content":"Вопрос №2: Unit-testsВы написали view-функцию, обрабатывающую URL /new_post/, которая на GET запрос отвечает страницей с формой, а на POST - создает новый пост из данных формы и редиректит на главную страницу. Опишите кейсы для юнит-тестов, которые вы бы написали для этой view-функции? Мой ответ №1 Проверка доступности формы методом get Действие: Запросить url /new_post/ Ожидаемый результат: response.status_code равен HTTPStatus.OK №2 Проверка успешности отправки формы и редиректа на главную Действие: Отправить post-запрос на url /new_post/ со словарем полей формы (например data={\"title\": \"This is title\"}) Ожидаемый результат: 1) response.status_code равен HTTPStatus.FOUND 2) response[\"Location\"] равен url главной страницы №3 Проверка валидации полей формы Действие: Передать в форму словарь с названием поля и его значением (например: {\"title\": \"post title\"}) Ожидаемый результат: Получить ошибку валидации “Заголовок должен начинаться с заглавной буквы” ","date":"04.06.2022","objectID":"/yandex-praktikum-reviewer-test-task/:2:0","series":null,"tags":["yandex"],"title":"Тестовое задание на вакансию Код-ревьюера в Яндекс.Практикум","uri":"/yandex-praktikum-reviewer-test-task/#вопрос-2-unit-tests"},{"categories":["python-interview"],"content":"Вопрос №3: АлгоритмыРасскажите, как работает алгоритм быстрой сортировки, какая у него сложность в лучшем и худшем случаях, опишите их. Является ли он стабильным? Мой ответ Алгоритм быстрой сортировки состоит из трех шагов: Выбрать опорный элемент (от выбора опорного элемента зависит эффективность сортировки). Сравнить остальные элементы с опорным и сгруппировать их тремя массивами в порядке: элементы меньше опорного, элементы равные опорному, элементы больше опорного. Применить рекурсивно два предыдущих шага для массивов меньших и больших, если они содержат больше одного элемента. Лучший сценарий (он же средний): O(n*log n) - когда пограничным элементом выбирается средний, или ближайший к середине. Худший сценарий: O(n**2) - если за опорный элемент берется первый или последний элемент. Читал, что существует параллельная версия быстрой сор­тировки, которая сортирует массив за время О(n). Алгоритм не является стабильным. ","date":"04.06.2022","objectID":"/yandex-praktikum-reviewer-test-task/:3:0","series":null,"tags":["yandex"],"title":"Тестовое задание на вакансию Код-ревьюера в Яндекс.Практикум","uri":"/yandex-praktikum-reviewer-test-task/#вопрос-3-алгоритмы"},{"categories":["python-interview"],"content":"Вопрос №4: АлгоритмыОпишите алгоритм поиска цикла в односвязном списке, сложность которого по памяти будет равна О(1). Мой ответ Самый очевидный вариант - это алгоритм Флойда с двумя указателями. Первый двигается по i-ым элементам, второй - по 2i. На каждом шаге i увеличивается на единицу и элементы сравниваются. Если элементы равны - цикл есть, если “быстрый” указатель достиг конца списка - цикла нет. Есть еще алгоритм Брента, принцип похож, но проверяется степень двойки. ","date":"04.06.2022","objectID":"/yandex-praktikum-reviewer-test-task/:4:0","series":null,"tags":["yandex"],"title":"Тестовое задание на вакансию Код-ревьюера в Яндекс.Практикум","uri":"/yandex-praktikum-reviewer-test-task/#вопрос-4-алгоритмы"},{"categories":["python-interview"],"content":"Практическое задание: ревью кода студентаЗадание описано по ссылке Мой вариант код-ревью тут. ","date":"04.06.2022","objectID":"/yandex-praktikum-reviewer-test-task/:5:0","series":null,"tags":["yandex"],"title":"Тестовое задание на вакансию Код-ревьюера в Яндекс.Практикум","uri":"/yandex-praktikum-reviewer-test-task/#практическое-задание-ревью-кода-студента"},{"categories":["python-interview"],"content":"Вопрос №6: Общая тематикаРасскажите не менее чем в трех предложениях, почему вам интересно заниматься код-ревью, и что вас мотивировало сделать тестовое. Мой ответ Код-ревью это неотъемлемая часть разработки. Глобально - это коммуникация и передача знаний между участниками этого процесса. Для меня код-ревью позволит внести свой вклад в развитие сообщества, подсказывая начинающим программистам лучшие практики и стандарты. С точки зрения личной выгоды - ревью кода прокачивает хард-скилы, заставляя чаще обращаться к стандартам языка, и тщательнее изучать их самому, что в итоге делает и мой код лучше. Вырасти как специалист, помогая расти другим - это и была моя мотивация. ","date":"04.06.2022","objectID":"/yandex-praktikum-reviewer-test-task/:6:0","series":null,"tags":["yandex"],"title":"Тестовое задание на вакансию Код-ревьюера в Яндекс.Практикум","uri":"/yandex-praktikum-reviewer-test-task/#вопрос-6-общая-тематика"},{"categories":["python-interview"],"content":"Декораторы позволяют менять поведение функции не изменяя ее кода. Это становится возможным благодаря тому, что функции в Python могут принимать и возвращать функции. Декоратор в Python - это реализация структурного шаблона проектирования «Декоратор».","date":"05.04.2022","objectID":"/decorators-in-python/","series":null,"tags":["python"],"title":"Декораторы в Python: определение, особенности, примеры декораторов","uri":"/decorators-in-python/"},{"categories":["python-interview"],"content":"Список вопросов к Python собеседованию Схема для понимания итераторов и генераторов\" Схема для понимания итераторов и генераторов -- -- ","date":"05.04.2022","objectID":"/decorators-in-python/:0:0","series":null,"tags":["python"],"title":"Декораторы в Python: определение, особенности, примеры декораторов","uri":"/decorators-in-python/#"},{"categories":["python-interview"],"content":"Паттерн проектирования “Декоратор” Декоратор (Decorator) — структурный шаблон проектирования, предназначенный для динамического подключения дополнительного поведения к объекту. Шаблон Декоратор предоставляет гибкую альтернативу практике создания подклассов с целью расширения функциональности.1 ","date":"05.04.2022","objectID":"/decorators-in-python/:1:0","series":null,"tags":["python"],"title":"Декораторы в Python: определение, особенности, примеры декораторов","uri":"/decorators-in-python/#паттерн-проектирования-декоратор"},{"categories":["python-interview"],"content":"Декораторы в PythonДекоратор — это функция, которая позволяет обернуть другую функцию для расширения её функциональности без непосредственного изменения её кода. Чтобы лучше пониманять работу декораторов нужно помнить тот факт, что: в Python всё является объектами; Функции — это объекты первого класса; следовательно, язык поддерживает функции высших порядков. Объектами первого класса в контексте конкретного языка программирования называются элементы, с которыми можно делать всё то же, что и с любым другим объектом: передавать как параметр, возвращать из функции и присваивать переменной. Функции высших порядков — это такие функции, которые могут принимать в качестве аргументов и возвращать другие функции. Это означает, что мы можем: сохранять функции в переменные; передавать их в качестве аргументов; возвращать из других функций; определить одну функцию внутри другой (вложенные функции). По сути, это и позволяет реализовать декоратор: def decorator(func): print(\"Inside decorator\") def wrapper(): # вложенная функция (обертка) print(\"Inside wrapper - Befor func exec\") res = func() print(\"Inside wrapper - After func exec\") return res print(\"Inside decorator 2\") return wrapper # возвращаем функцию (не вызывая) def outer_func(): print(\"Inside outer_func\") # Передаем функцию как параметр, результат присваиваем переменной wrapped_func = decorator(outer_func) # вызываем обернутую функцию первый раз wrapped_func() # вызываем обернутую функцию второй раз wrapped_func() Результат запуска: # первый вызов функции wrapped_func() Inside decorator - Befor wrapper def Inside decorator - After wrapper def Inside wrapper - Befor func exec Inside outer_func Inside wrapper - After func exec # Второй вызов функции wrapped_func() Inside wrapper - Befor func exec Inside outer_func Inside wrapper - After func exec Выражение @decorator - это синтаксический сахар, короткая запись для outer_func = decorator(outer_func). def decorator(func): def wrapper(): func() return wrapper @decorator def outer_func(): pass outer_func() Еще немного о декораторах: декораторы можно вкладывать друг в друга (при этом порядок декорирования важен); декораторы можно использовать с другими методами (например, «магическими»); декораторы могут принимать в качестве аргументов не только функции. Условные недостатки декораторов: несколько замедляют вызов функции если функция декорирована — это не отменить (существуют трюки, позволяющие создать декоратор, который можно отсоединить от функции, но это плохая практика) оборачивают функции, что может затруднить отладку (лечится использованием functools.wraps). Области применения декораторов: когда нужно избежать повторений при использовании похожих методов; могут быть использованы для расширения возможностей функций из сторонних библиотек (код которых мы не можем изменять); в Django декораторы используются для управления кешированием, контроля за правами доступа и определения обработчиков адресов; в Twisted — для создания поддельных асинхронных inline-вызовов. ","date":"05.04.2022","objectID":"/decorators-in-python/:2:0","series":null,"tags":["python"],"title":"Декораторы в Python: определение, особенности, примеры декораторов","uri":"/decorators-in-python/#декораторы-в-python"},{"categories":["python-interview"],"content":"Функция с аргументамиДопустим, теперь декорируемая функция outer_func() может принимать произвольное количество аргументов. Чтобы наш декоратор работал корректно необходимо использовать *args и **kwargs (распаковка аргументов) во внутренней функции wrapper(), а так же передавать произвольное число позиционных и ключевых аргументов функции func(), которую декоратор получает в качестве аргумента: def decorator(func): def wrapper(*args, **kwargs): res = func(*args, **kwargs) return res return wrapper @decorator def outer_func(a, b, name: str): pass outer_func(7, 8, name=\"Tom\") Теперь декоратор @decorator будет работать как для функций, которые вообще не принимают аргументы, так и для функций которые принимают произвольное количество аргументов. ","date":"05.04.2022","objectID":"/decorators-in-python/:3:0","series":null,"tags":["python"],"title":"Декораторы в Python: определение, особенности, примеры декораторов","uri":"/decorators-in-python/#функция-с-аргументами"},{"categories":["python-interview"],"content":"functools.wrapsИз-за того, что декоратор возвращает не первоначальную функцию, а функцию обертку wrapper - теряется строка документации (docstring) основной функции, доступ к которой можно получить с помощью метода __doc__. functools.wraps — декоратор Функция wraps из модуля functools копирует всю информацию об оборачиваемой функции (имя, модуля, docstrings и т.п.) в функцию-обёртку. from functools import wraps def decorator(func): '''Декоратор''' @wraps(func) def wrapper(): '''Функция wrapper''' func() return wrapper @decorator def outer_func(): '''Оборачиваемая функция''' print('функция wrapped') print(outer_func.__name__) print(outer_func.__doc__) ","date":"05.04.2022","objectID":"/decorators-in-python/:4:0","series":null,"tags":["python"],"title":"Декораторы в Python: определение, особенности, примеры декораторов","uri":"/decorators-in-python/#functoolswraps"},{"categories":["python-interview"],"content":"Декораторы с аргументамиЧтобы передать параметр в сам декоратор нужно добавить еще один слой абстракции, то есть — еще одну функцию-обертку. from functools import wraps def benchmark(type: str = \"sec\", iters: int = 1): # новый уровень абстракции import time def decorator(func): # сам декоратор @wraps(func) def wrapper(*args, **kwargs): # функция обертка start_time = time.time() for _ in range(iters): result = func(*args, **kwargs) end_time = time.time() exec_time = end_time - start_time if type == \"ms\": print(f\"Exec time of {func.__name__}x{iters}is {exec_time*1000}ms\") else: print(f\"Exec time of {func.__name__}x{iters}is {exec_time}s\") return result return wrapper return decorator @benchmark(type=\"ms\", iters=100) def outer_func(a, b, name: str): \"\"\"Outer_func docstring\"\"\" print('функция wrapped') Функция benchmark() не является декоратором. Это обычная функция, которая принимает аргументы type и iters, а затем возвращает декоратор. В свою очередь, он декорирует функцию outer_func(). Поэтому мы использовали не выражение @benchmark, а @benchmark(type=\"ms\", iters=100) — круглые скобки означают, что функция вызывается, после чего возвращает сам декоратор. ","date":"05.04.2022","objectID":"/decorators-in-python/:5:0","series":null,"tags":["python"],"title":"Декораторы в Python: определение, особенности, примеры декораторов","uri":"/decorators-in-python/#декораторы-с-аргументами"},{"categories":["python-interview"],"content":"Объекты-декораторыДекоратором могут быть не только функции, но и любые вызываемые объекты. Экземпляры класса с методом __call__ тоже можно вызывать, поэтому классы можно использовать в качестве декораторов. Для функций с параметрами *args и **kwargs нужно передать в метод __call__. class Decorator: def __init__(self, func): print('Класс Decorator метод __init__') self.func = func def __call__(self, *args, **kwargs): print('перед вызовом класса...', self.func.__name__) self.func(*args, **kwargs) print('после вызова класса') @Decorator def outer_func(a, b, name: str): print('функция wrapped') outer_func(7, 8, \"Bob\") Для передачи аргументов в класс-декоратор эти аргументы получает инициализатор __init__. Метод __call__ будет получать декорируемую функцию и возвращать функцию-обертку, которая, по сути, будет выполнять эту декорируемую функцию. Функция-обертка wrapper получает *args и **kwargs: from functools import wraps class Decorator: def __init__(self, output: str = \"log\"): print('Класс Decorator метод __init__') self.output = output def __call__(self, func): print('Класс Decorator метод __call__') @wraps(func) def wrapper(*args, **kwargs): print('перед вызовом func...', func.__name__) result = func(*args, **kwargs) if self.output == \"file\": print(\"Save to file\") else: print(\"Console output\") print('после вызова func') return result return wrapper @Decorator(output=\"file\") def outer_func(a, b, name: str): \"\"\"Outer_func docstring\"\"\" print('функция wrapped', a, b, name) outer_func(7, 8, \"Bob\") ","date":"05.04.2022","objectID":"/decorators-in-python/:6:0","series":null,"tags":["python"],"title":"Декораторы в Python: определение, особенности, примеры декораторов","uri":"/decorators-in-python/#объекты-декораторы"},{"categories":["python-interview"],"content":"Декоратор методаФункции и методы в Python — это практически одно и то же. Отличие в том, что методы всегда принимают первым параметром self (ссылку на объект). Следовательно, мы легко можем написать декоратор для метода: def method_decorator(method): def wrapper(self): result = method(self) return result.upper() if self.power \u003e 150 else result return wrapper class Car: def __init__(self, power): self.power = power @method_decorator def wroom_wroom(self) return \"wroom-wroom...\" lada = Car(87) bmw = Car(300) print(lada.wroom_wroom()) # wroom-wroom... print(bmw.wroom_wroom()) # WROOM-WROOM... ","date":"05.04.2022","objectID":"/decorators-in-python/:7:0","series":null,"tags":["python"],"title":"Декораторы в Python: определение, особенности, примеры декораторов","uri":"/decorators-in-python/#декоратор-метода"},{"categories":["python-interview"],"content":"Декоратор класса на примере SingletonДекоратор можно использовать для декорирования класса. Отличие лишь в том, что декоратор получает класс, а не функцию. Singleton — это класс с одним экземпляром. Его можно сохранить как атрибут функции-обертки и вернуть при запросе. def singleton(cls): '''Класс Singleton (один экземпляр)''' def wrapper(*args, **kwargs): if not wrapper.instance: wrapper.instance = cls(*args, **kwargs) return wrapper.instance wrapper.instance = None return wrapper @singleton class SomeClass: pass ","date":"05.04.2022","objectID":"/decorators-in-python/:8:0","series":null,"tags":["python"],"title":"Декораторы в Python: определение, особенности, примеры декораторов","uri":"/decorators-in-python/#декоратор-класса-на-примере-singleton"},{"categories":["python-interview"],"content":"Встроенные декораторы @classmethod @staticmethod @property Подробнее в статье ООП в Python. @contextlib.contextmanager @functools.lru_cache @abc.abstractmethod Подробнее тут.2 ","date":"05.04.2022","objectID":"/decorators-in-python/:9:0","series":null,"tags":["python"],"title":"Декораторы в Python: определение, особенности, примеры декораторов","uri":"/decorators-in-python/#встроенные-декораторы"},{"categories":["python-interview"],"content":"Примеры декораторов (код)","date":"05.04.2022","objectID":"/decorators-in-python/:10:0","series":null,"tags":["python"],"title":"Декораторы в Python: определение, особенности, примеры декораторов","uri":"/decorators-in-python/#примеры-декораторов-код"},{"categories":["python-interview"],"content":"Конвертер import functools def convert(func=None, convert_to=None): \"\"\"Этот код конвертирует единицы измерения из одного типа в другой.\"\"\" if func is None: return functools.partial(convert, convert_to=convert_to) @functools.wraps(func) def wrapper(*args, **kwargs): print(f\"Conversion unit: {convert_to}\") val = func(*args, **kwargs) # Добавим правила для преобразования if convert_to is None: return val elif convert_to == \"km\": return val / 1000 elif convert_to == \"mile\": return val * 0.000621371 elif convert_to == \"cm\": return val * 100 elif convert_to == \"mm\": return val * 1000 else: raise ValueError(\"Conversion unit is not supported.\") # этот тип единиц не поддерживается return wrapper ","date":"05.04.2022","objectID":"/decorators-in-python/:10:1","series":null,"tags":["python"],"title":"Декораторы в Python: определение, особенности, примеры декораторов","uri":"/decorators-in-python/#конвертер"},{"categories":["python-interview"],"content":"Таймер import time def exec_time(type: str = \"sec\", iters: int = 1): def exec_time_decorator(func): @wraps(func) def wrapper(*args, **kwargs): \"\"\"Docstring wrapper\"\"\" start_time = time.time() for _ in range(iters): result = func(*args, **kwargs) end_time = time.time() if type == \"ms\": print(f\"Execution time of {func.__name__}x{iters}is {(end_time - start_time)*1000}ms\") else: print(f\"Execution time of {func.__name__}x{iters}is {end_time - start_time}s\") return result return wrapper return exec_time_decorator ","date":"05.04.2022","objectID":"/decorators-in-python/:10:2","series":null,"tags":["python"],"title":"Декораторы в Python: определение, особенности, примеры декораторов","uri":"/decorators-in-python/#таймер"},{"categories":["python-interview"],"content":"Счетчик вызовов def counter(func): count = 0 @wraps(func) def wrapper(*args, **kwargs): \"\"\"Docstring wrapper\"\"\" nonlocal count count += 1 res = func(*args, **kwargs) print(f\"{func.__name__}была вызвана: {count}x\") return res return wrapper Источники3456 Wikipedia - Шаблон проектирования Декоратор ↩︎ Awesome Python Decorator ↩︎ Декораторы в Python: понять и полюбить ↩︎ Понимаем декораторы в Python’e, шаг за шагом. Шаг 2 ↩︎ Руководство по декораторам Python ↩︎ Разбираемся с декораторами в Python ↩︎ ","date":"05.04.2022","objectID":"/decorators-in-python/:10:3","series":null,"tags":["python"],"title":"Декораторы в Python: определение, особенности, примеры декораторов","uri":"/decorators-in-python/#счетчик-вызовов"},{"categories":["python-interview"],"content":"Сопрограммы (corutines) в Python","date":"12.03.2022","objectID":"/coroutines-in-python/","series":null,"tags":["python"],"title":"Сопрограммы (corutines) в Python","uri":"/coroutines-in-python/"},{"categories":["python-interview"],"content":"Список вопросов к Python собеседованию Сопрограммы – это особый тип функций, которые сознательно передают управление вызывающему объекту, но они не заканчивают свой контекст в процессе, поддерживая его в состоянии ожидания. Сопрограмма сама решает, когда перенаправить flow в другое место (например, в другую сопрограмму). И это позволяет строить красивые разветвленные деревья обработки потоков данных, реализовывать MapReduce, возможно прокидывать текущие байты через сокет на другую ноду. Более того, сопрограммы могут быть фактически реализованы абсолютно на любом языке. Сопрограммы в Python Корутины в Python Хабр - Сопрограммы в Python What is a Coroutine Anyway? (перевод) Использование send(), throw() и close() в генераторах Python О стандарте можно почитать тут - PEP342 ","date":"12.03.2022","objectID":"/coroutines-in-python/:0:0","series":null,"tags":["python"],"title":"Сопрограммы (corutines) в Python","uri":"/coroutines-in-python/#"},{"categories":["python-interview"],"content":"Разбираемся в различиях между понятиями итератора (iterator), итерируемого объекта (iterable) и генератора. Реализация итераторов на языке Python и преимущества их использования.","date":"02.03.2022","objectID":"/iterators-and-generators-python/","series":null,"tags":["python"],"title":"Итераторы, генераторы и итерируемые объекты в Python","uri":"/iterators-and-generators-python/"},{"categories":["python-interview"],"content":"Список вопросов к Python собеседованию Схема для понимания итераторов и генераторов\" Схема для понимания итераторов и генераторов ","date":"02.03.2022","objectID":"/iterators-and-generators-python/:0:0","series":null,"tags":["python"],"title":"Итераторы, генераторы и итерируемые объекты в Python","uri":"/iterators-and-generators-python/#"},{"categories":["python-interview"],"content":"ИтераторИтератор — это: интерфейс, предоставляющий доступ к элементам коллекции (массива или контейнера). Коллекции не должны обязательно существовать в памяти и быть конечными. объект, в котором есть два метода: __iter__ (возвращает сам объект итератора) и __next__ (возвращает следующее значение из итератора) Особенности итератора: при запросе каждого следующего значения, итератор знает, как его вычислить хранит информацию о текущем состоянии итерируемого объекта, над которым он работает почти всегда возвращает себя из метода __iter__, так как выступает итераторами для самого себя (есть исключения) итератор не должен иметь и часто не имеет определённой длины. Поэтому зачастую не имеет имплементации __len__ чтобы подсчитать количество элементов в итераторе, приходится делать это вручную или использовать sum когда итератор завершает работу, интерпретатор Python ожидает возбуждения исключения StopIteration (в случаях работы с бесконечными множествами программист должен позаботиться о выходе из цикла самостоятельно)1 любой итератор является итерируемым объектом2 В Python за получение итератора отвечает функция iter(). Она отработает на любом объекте, у которого есть метод __iter__ или метод __getitem__ (позволяет получать элементы по индексу). iter() можно вызывать с двумя аргументами. Первый аргумент должен быть вызываемым объектом, а второй — неким ограничителем. Итерирование завершается, когда возбуждается исключение StopIteration (IndexError для метода __getitem__) или возвращается значение ограничителя. class SimpleList: def __init__(self, *items): self.items = items def __getitem__(self, i): return self.items[i] Метод __getitem__ вместо __iter__ -- Итераторы помогают создавать более чистый код, потому что позволяют работать с бесконечными последовательностями без необходимости перераспределения ресурсов для каждой возможной последовательности, что также экономит ресурсы.3 О реализации итератора в книге «банды четырех» Минимальный интерфейс класса Iterator состоит из операций First, Next, IsDone и CurrentItem. Этот интерфейс можно упростить, объединив операции Next, IsDone и CurrentItem в одну, которая будет переходить к следующему объекту и возвращать его. Если обход завершен, то эта операция вернет специальное значение (например, 0), обозначающее конец итерации. Именно так и реализовано в Python, но вместо специального значения, о конце итерации говорит исключение StopIteration. ","date":"02.03.2022","objectID":"/iterators-and-generators-python/:1:0","series":null,"tags":["python"],"title":"Итераторы, генераторы и итерируемые объекты в Python","uri":"/iterators-and-generators-python/#итератор"},{"categories":["python-interview"],"content":"Итерируемый объект это контейнер, который может служить источником данных для итератора это любой объект (не обязательно структура данных), способный возвращать итератор4 объект, в котором есть метод __iter__ итерируемые объекты могут представлять как конечный, так и бесконечный источник данных некоторые итерируемые объекты не являются итераторами, но используют другие объекты как итераторы. Итерируемый объект, но не итератор Например, объект list относится к итерируемым, но не является итератором. В нём реализован метод __iter__, но отсутствует метод __next__. Итераторы объектов list относятся к типу listiterator. У объектов list есть определённая длина, а у listiterator нету. Примеры итерируемых объектов: контейнеры (списки, множества, словари, кортежи и строки) открытые файлы открытые сокеты ","date":"02.03.2022","objectID":"/iterators-and-generators-python/:2:0","series":null,"tags":["python"],"title":"Итераторы, генераторы и итерируемые объекты в Python","uri":"/iterators-and-generators-python/#итерируемый-объект"},{"categories":["python-interview"],"content":"ГенераторГенератор (функция-генератор) - это итератор, определение которого выглядит как определение функции. генераторы — функции (специальный класс функций), которые внутри используют выражение yield использование yield превращает обычную функцию в генератор5 yield служит разделителем блоков кода, которые исполняет генератор на каждом обращении к нему, то есть на каждой итерации (цикл вовсе не обязателен) в результате вызова функции-генератора или вычисления генераторного выражения, получаем объект-генератор типа types.GeneratorType генераторы не могут возвращать значения, вместо этого они возвращают итератор, который отдает элементы по одному Python автоматизирует запоминание контекста генератора (текущий поток управления, значение локальных переменных и т.д.) каждый вызов метода __next__ у объекта генератора возвращает следующее значение вызов метода __next__ может быть произведен напрямую при помощи функции next(), или косвенно (например через цикл for) метод __iter__ реализуется автоматически Преимущества генераторов: генераторы можно использовать везде, где требуются итераторы с помощью генераторов удобно реализовывать дискретные динамические системы более эффективно используют память и центральный процессор позволяют писать код с меньшим количеством промежуточных переменных и структур данных обычно для них требуется меньше строк кода их использование облегчает чтение и понимание кода def count_generator(): n = 0 while True: yield n n += 1 ","date":"02.03.2022","objectID":"/iterators-and-generators-python/:3:0","series":null,"tags":["python"],"title":"Итераторы, генераторы и итерируемые объекты в Python","uri":"/iterators-and-generators-python/#генератор"},{"categories":["python-interview"],"content":"Генераторные выраженияГенераторное выражение - это еще один синтаксический сахар в Python, простейший способ создать объект с интерфейсом итератора, при этом не загружая всех элементов в память. результатами генераторных выражений являются объекты с типом generator генераторное выражение использует такой же синтаксис, как list comprehensions, но возвращает итератор, а не список выглядит точно так же, как list comprehensions, но используются круглые скобки оно полезно в том случае, когда надо работать с большим итерируемым объектом или бесконечным итератором genexpr = (x**2 for x in range(10000)) ","date":"02.03.2022","objectID":"/iterators-and-generators-python/:3:1","series":null,"tags":["python"],"title":"Итераторы, генераторы и итерируемые объекты в Python","uri":"/iterators-and-generators-python/#генераторные-выражения"},{"categories":["python-interview"],"content":"Выражение yield fromТрадиционным подходом для обхода ограниченно-вложенных структур являются вложенные циклы. Тот же подход можно использовать когда генераторная функция должна отдавать значения, порождаемые другим генератором. def chain(*iterables): for it in iterables: for i in it: yield i g = chain([1, 2, 3], {'A', 'B', 'C'}, '...') print(list(g)) # [1, 2, 3, 'A', 'B', 'C', '.', '.', '.'] Но вложенные циклы можно убрать, добавив конструкцию yield from: def chain(*iterables): for it in iterables: yield from it g = chain([1, 2, 3], {'A', 'B', 'C'}, '...') print(list(g)) # [1, 2, 3, 'A', 'B', 'C', '.', '.', '.'] По сути, выражение yield from \u003citerable\u003e - это просто сокращенная форма for item in iterable: yield item. Основная польза yield from в создании прямого канала между внутренним генератором и клиентом внешнего генератора. Но это уже больше тема про сопрограммы (coroutines). ","date":"02.03.2022","objectID":"/iterators-and-generators-python/:3:2","series":null,"tags":["python"],"title":"Итераторы, генераторы и итерируемые объекты в Python","uri":"/iterators-and-generators-python/#выражение-yield-from"},{"categories":["python-interview"],"content":"Расширенные методы генератораС версии Python 2.5 у объекта генератора появилось еще несколько методов: send() - позволяет отправить данные в генератор перед вызовом следующего блока кода throw() - можно извне заставить его бросить исключение close() - можно извне заставить генератор остановиться на следующем обращении к нему Эти методы в совокупности с выражением yield from превратили генераторы в сопрограммы (coroutine). ","date":"02.03.2022","objectID":"/iterators-and-generators-python/:4:0","series":null,"tags":["python"],"title":"Итераторы, генераторы и итерируемые объекты в Python","uri":"/iterators-and-generators-python/#расширенные-методы-генератора"},{"categories":["python-interview"],"content":"Модуль itertoolsItertools — это встроенный модуль в Python, который содержит функции для создания итераторов для эффективных циклов. В модуле itertools есть набор итераторов, которые упрощают работу с перестановками, комбинациями, декартовыми произведениями и другими комбинаторными структурами.6 ","date":"02.03.2022","objectID":"/iterators-and-generators-python/:5:0","series":null,"tags":["python"],"title":"Итераторы, генераторы и итерируемые объекты в Python","uri":"/iterators-and-generators-python/#модуль-itertools"},{"categories":["python-interview"],"content":"Рекурсивные генераторыКак и любая другая функция, генераторы могут быть рекурсивными. Пример: генератор перестановок элементов в списке def permutations(items): if len(items) == 0: yield [] else: pi = items[:] for i in range(len(pi)): pi[0], pi[i] = pi[i], pi[0] for p in permutations(pi[1:]): yield [pi[0]] + p ","date":"02.03.2022","objectID":"/iterators-and-generators-python/:6:0","series":null,"tags":["python"],"title":"Итераторы, генераторы и итерируемые объекты в Python","uri":"/iterators-and-generators-python/#рекурсивные-генераторы"},{"categories":["python-interview"],"content":"Разница между yield и return return yield Оператор return возвращает только одно значение. Оператор yield может возвращать серию результатов в виде объекта-генератора. return выходит из функции, а в случае цикла он закрывает цикл. Это последний оператор, который нужно разместить внутри функции. Не уничтожает локальные переменные функции. Выполнение программы приостанавливается, значение отправляется вызывающей стороне, после чего выполнение программы продолжается с последнего оператора yield. Логически, функция должна иметь только один return. Внутри функции может быть более одного оператора yield. Оператор return может выполняться только один раз. Оператор yield может выполняться несколько раз. return помещается внутри обычной функции Python. Оператор yield преобразует обычную функцию в функцию-генератор. ","date":"02.03.2022","objectID":"/iterators-and-generators-python/:7:0","series":null,"tags":["python"],"title":"Итераторы, генераторы и итерируемые объекты в Python","uri":"/iterators-and-generators-python/#разница-между-yield-и-return"},{"categories":["python-interview"],"content":"Ппоточные алгоритмыПодробнее Python: итераторы, генераторы, itertools ↩︎ Python для сетевых инженеров ↩︎ Итераторы и генераторы в Python ↩︎ Iterables vs. Iterators vs. Generators ↩︎ xakep.ru - генераторы и итераторы ↩︎ docs.python.org - itertools ↩︎ ","date":"02.03.2022","objectID":"/iterators-and-generators-python/:8:0","series":null,"tags":["python"],"title":"Итераторы, генераторы и итерируемые объекты в Python","uri":"/iterators-and-generators-python/#ппоточные-алгоритмы"},{"categories":["python-interview"],"content":"ИМХО","date":"18.02.2022","objectID":"/important-peps/","series":null,"tags":["python"],"title":"Важные разделы PEP","uri":"/important-peps/"},{"categories":["python-interview"],"content":"Список вопросов к Python собеседованию PEP 8 – Style Guide for Python Code рус PEP 20 – The Zen of Python PEP 257 – Docstring Conventions PEP 343 – The “with” Statement PEP 404 – Python 2.8 Un-release Schedule PEP 435 – Adding an Enum type to the Python standard library PEP 457 – Notation For Positional-Only Parameters PEP 484 – Type Hints PEP 557 – Data Classes PEP 572 – Assignment Expressions PEP 3107 – Function Annotations PEP 3156 – Asynchronous IO Support Rebooted: the “asyncio” Module Источники123 PEP 0 ↩︎ Python Tips - Context Managers ↩︎ PEP 8 for humans ↩︎ ","date":"18.02.2022","objectID":"/important-peps/:0:0","series":null,"tags":["python"],"title":"Важные разделы PEP","uri":"/important-peps/#"},{"categories":["python-interview"],"content":"Разберем как создать контекстный менеджер из класса или генератора (декоратор @contextmanager), что такое вложенные и асинхронные менеджеры контекста. Код примеров контекстных менеджеров на языке Python.","date":"18.02.2022","objectID":"/context-managers-python/","series":null,"tags":["python"],"title":"Контекстные менеджеры в Python","uri":"/context-managers-python/"},{"categories":["python-interview"],"content":"Список вопросов к Python собеседованию Схема для понимания итераторов и генераторов\" Схема для понимания итераторов и генераторов -- -- Краткое резюме по контекстным менеджерам Контекстные менеджеры нужны там, где есть “настройка” -\u003e блок кода -\u003e “уборка”, при этом “настройку” и “уборку” нужно выполнить в паре. У контекстного менеджера обязательно присутствуют атрибуты __enter__ и __exit__. Их добавление обеспечивает реализацию протокола контекстного менеджера. Не обязательно писать целый класс для нового контекстного менеджера, достаточно обернуть генератор в декоратор contextmanager из модуля contextlib. yield стоит оборачивать в блок try...finally. Контекстный менеджер определен в PEP 343. Контекстные менеджеры предназначены для использования в качестве более сжатого механизма управления ресурсами, чем try...finally Контекстные менеджеры дают нам надежный метод очистки ресурсов (т.к. вызов метода деструктора Python del не всегда гарантируется). ","date":"18.02.2022","objectID":"/context-managers-python/:0:0","series":null,"tags":["python"],"title":"Контекстные менеджеры в Python","uri":"/context-managers-python/#"},{"categories":["python-interview"],"content":"Контекстные менеджерыКонтекстные менеджеры позволяют выделять и освобождать ресурсы именно тогда, когда нам это нужно. Наиболее широко используемым примером контекстных менеджеров является оператор with. Допустим, у нас есть две связанные операции, которые необходимо выполнить в паре + блок кода между ними. Инструкция with создает контекст выполнения, который позволяет запускать группу операторов под управлением контекстного менеджера. По сравнению с традиционными конструкциями try ... finally, инструкция with делает код более понятным, безопасным и многоразовым. Многие классы в стандартной библиотеке поддерживают оператор with. Классическим примером этого является open(), который позволяет работать с файловыми объектами используя with: with open('some_file', 'w') as opened_file: opened_file.write('Hello!') В общем случае синтаксис использования with выглядит следующим образом: with expression as target_var: do_something(target_var) expression, идущее после with должно возвращать объект, реализующий протокол управления контекстом. Этот протокол состоит из двух специальных методов: __enter__ вызывается оператором with для входа в контекст выполнения; __exit__ вызывается, когда выполнение покидает блок кода with. Спецификатор as необязателен. Если мы используем target_var с as, то значение возвращенное методом __enter__ для объекта контекстного менеджера привязывается к этой переменной. Возврат None Некоторые контекстные менеджеры возвращают None из __enter__, потому что у них нет объекта, который можно было бы вернуть вызывяющей стороне. В этих случаях использование target_var не имеет смысла. Последовательность работы: Вызов expression для получения контекстного менеджера. Сохранение методов контекстного менеджера __enter__ и __exit__ для последующего использования. Вызов метода __enter__ и сохранение возвращаемого значения в target_var (если target_var используется). Выполнение блока кода внутри with. Вызов метода __exit__ в контекстном менеджере после завершения блока кода внутри with. Наиболее частые сценарии использования: Open–Close - например, файла, или сокета Lock–Release - работа с данными в многопоточном приложении Start–Stop - например, для запуска таймера и его автоматической остановки. Change–Reset - например, приложение должно подключиться к нескольким источникам данных и у него есть соединение по умолчанию. Create-Delete Enter-Exit Setup-Teardown ","date":"18.02.2022","objectID":"/context-managers-python/:1:0","series":null,"tags":["python"],"title":"Контекстные менеджеры в Python","uri":"/context-managers-python/#контекстные-менеджеры"},{"categories":["python-interview"],"content":"Контекстный менеджер из классаНеобходимый минимум функциональности контекстного менеджера требует методов __enter__ и __exit__. Метод __enter__(self) выполняется до входа в блок. Методу можно возвратить текущий экземпляр класса, что бы к нему можно было обращаться через инструкцию as. Метод __exit__(self, ex_type, ex_val, ex_trace) выполняется после выхода из блока with, и содержит три параметра — ex_type, ex_value и ex_tr. Переменная ex_type содержит в себе класс исключения, которое было возбуждено, ex_value — сообщение исключения. Чтобы превратить класс в контекстный менеджер нужно определить в нем два этих метода: class FileOpener: def __init__(self, f_name, op_type) -\u003e None: print(\"Inside __init__\") self.file = open(f_name, op_type) def __enter__(self): print(\"Inside __enter__\") return self.file def __exit__(self, ex_type, ex_val, ex_trace): print(\"Inside __exit__ %s, %s, %s\", ex_type, ex_val, ex_trace) self.file.close() return True with FileOpener(\"test.txt\", \"w\") as file: file.write(\"Test string\") raise RuntimeError() Шаги, которые выполняет with при возникновении исключения: Тип, значение и обратная трассировка ошибки передается в метод __exit__. Обработка исключения передается методу __exit__ Если __exit__ возвращает True, то исключение было корректно обработано. При возврате любого другого значения with вызывает исключение. ","date":"18.02.2022","objectID":"/context-managers-python/:2:0","series":null,"tags":["python"],"title":"Контекстные менеджеры в Python","uri":"/context-managers-python/#контекстный-менеджер-из-класса"},{"categories":["python-interview"],"content":"Контекстный менеджер из генератораМы также можем реализовать менеджер контекста через декораторы и генераторы. В Python присутствует модуль contextlib специально для этой цели. Вместо написания класса, мы можем реализовать менеджер контекста из функции-генератора. from contextlib import contextmanager # Общий вид контекстного менеджера @contextmanager def some_generator(\u003carguments\u003e): \u003csetup\u003e try: yield \u003cvalue\u003e finally: \u003ccleanup\u003e # Конкретная реализация @contextmanager def open_file(name): f = open(name, 'w') try: yield f finally: f.close() with open_file('some_file') as f: f.write('Hello!') Пошаговый разбор данного подхода: Python встречает ключевое слово yield. Благодаря этому он создает генератор, а не простую функцию. Благодаря декоратору, contextmanager вызывается с функцией open_file в качестве аргумента. Функция contextmanager возвращает генератор, обёрнутый в объект GeneratorContextManager. GeneratorContextManager присваивается функции open_file. Таким образом, когда мы вызовем функцию open_file в следующий раз, то фактически обратимся к объекту GeneratorContextManager. ","date":"18.02.2022","objectID":"/context-managers-python/:3:0","series":null,"tags":["python"],"title":"Контекстные менеджеры в Python","uri":"/context-managers-python/#контекстный-менеджер-из-генератора"},{"categories":["python-interview"],"content":"Контекстный менеджер как декораторМожно использовать контекстные менеджеры в качестве декораторов. Для этого при определении класса необходимо наследоваться от класса contextlib.ContextDecorator. from contextlib import ContextDecorator from time import time class RunTime(ContextDecorator): \"\"\"Timing decorator.\"\"\" def __init__(self, description): self.description = description def __enter__(self): print(self.description) self.start_time = time() def __exit__(self, *args): self.end_time = time() run_time = self.end_time - self.start_time print(f\"The function took {run_time}seconds to run.\") @RunTime(\"This function opens a file\") def custom_file_write(filename, mode, content): with open(filename, mode) as f: f.write(content) print(custom_file_write(\"file.txt\", \"wt\", \"Hello\")) Результат: This function opens a file The function took 0.0005390644073486328 seconds to run. None ","date":"18.02.2022","objectID":"/context-managers-python/:4:0","series":null,"tags":["python"],"title":"Контекстные менеджеры в Python","uri":"/context-managers-python/#контекстный-менеджер-как-декоратор"},{"categories":["python-interview"],"content":"Вложенные контекстные менеджерыИнструкция with поддерживает несколько вложенных контекстных менеджеров. Можно использовать любое количество контекстных менеджеров, разделенных запятыми: with A() as a, B() as b: pass ","date":"18.02.2022","objectID":"/context-managers-python/:5:0","series":null,"tags":["python"],"title":"Контекстные менеджеры в Python","uri":"/context-managers-python/#вложенные-контекстные-менеджеры"},{"categories":["python-interview"],"content":"Асинхронные контекстные менеджерыРаспространенной практикой при написании асинхронных контекстных менеджеров является внедрение четырех специальных методов: __aenter__ __aexit__ __enter__ __exit__ # site_checker_v1.py import aiohttp import asyncio class AsyncSession: def __init__(self, url): self._url = url async def __aenter__(self): self.session = aiohttp.ClientSession() response = await self.session.get(self._url) return response async def __aexit__(self, exc_type, exc_value, exc_tb): await self.session.close() async def check(url): async with AsyncSession(url) as response: print(f\"{url}: status -\u003e {response.status}\") html = await response.text() print(f\"{url}: type -\u003e {html[:17].strip()}\") async def main(): await asyncio.gather( check(\"https://realpython.com\"), check(\"https://pycoders.com\"), ) asyncio.run(main()) ","date":"18.02.2022","objectID":"/context-managers-python/:6:0","series":null,"tags":["python"],"title":"Контекстные менеджеры в Python","uri":"/context-managers-python/#асинхронные-контекстные-менеджеры"},{"categories":["python-interview"],"content":"Примеры менеджеров контекста","date":"18.02.2022","objectID":"/context-managers-python/:7:0","series":null,"tags":["python"],"title":"Контекстные менеджеры в Python","uri":"/context-managers-python/#примеры-менеджеров-контекста"},{"categories":["python-interview"],"content":"Создание сессии в SQLAlchemy from sqlalchemy import create_engine from sqlalchemy.orm import sessionmaker from contextlib import contextmanager # an Engine, which the Session will use for connection resources some_engine = create_engine(\"sqlite://\") # create a configured \"Session\" class Session = sessionmaker(bind=some_engine) @contextmanager def session_scope(): \"\"\"Provide a transactional scope around a series of operations.\"\"\" session = Session() try: yield session session.commit() except: session.rollback() raise finally: session.close() ","date":"18.02.2022","objectID":"/context-managers-python/:7:1","series":null,"tags":["python"],"title":"Контекстные менеджеры в Python","uri":"/context-managers-python/#создание-сессии-в-sqlalchemy"},{"categories":["python-interview"],"content":"Тайминг выполнения кода import time class Timer: def __init__(self, name): self.name = name def __enter__(self): self.start = time.time() def __exit__(self, *args): self.end = time.time() self.interval = self.end - self.start print(\"%stook: %0.3fseconds\" % (self.name, self.interval)) return False Источники12345 Python Tips - Context Managers ↩︎ Python Context Managers ↩︎ Context Managers and Python’s with Statement ↩︎ The Curious Case of Python’s Context Manager ↩︎ Часть доклада Рэймонда Хэттингера ↩︎ ","date":"18.02.2022","objectID":"/context-managers-python/:7:2","series":null,"tags":["python"],"title":"Контекстные менеджеры в Python","uri":"/context-managers-python/#тайминг-выполнения-кода"},{"categories":["python-interview"],"content":"Давайте создавать надежные и хорошо реализованные системы, а не каких-то быстрорастущих монстров. Этому поможет следование указанным здесь принципам проектирования и разработки программного обеспечения.","date":"14.12.2021","objectID":"/coding-principles/","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/"},{"categories":["python-interview"],"content":"YAGNI«You Ain’t Gonna Need It» — «Вам это не понадобится» Процесс и принцип проектирования ПО, при котором в качестве основной цели и/или ценности декларируется отказ от избыточной функциональности, — то есть отказ добавления функциональности, в которой нет непосредственной надобности. ","date":"14.12.2021","objectID":"/coding-principles/:1:0","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#yagni"},{"categories":["python-interview"],"content":"DRYDon’t repeat yourself - не повторяйте себя Это принцип разработки программного обеспечения, нацеленный на снижение повторения информации различного рода, особенно в системах со множеством слоёв абстрагирования. Принцип DRY формулируется как: «Каждая часть знания должна иметь единственное, непротиворечивое и авторитетное представление в рамках системы». Он был сформулирован Энди Хантом и Дэйвом Томасом в их книге The Pragmatic Programmer. ","date":"14.12.2021","objectID":"/coding-principles/:2:0","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#dry"},{"categories":["python-interview"],"content":"KISSKeep It Stupid Simple (Keep it short and simple / Keep it simple, stupid) - Придерживайся простоты Принцип KISS утверждает, что большинство систем работают лучше всего, если они остаются простыми, а не усложняются. Поэтому в области проектирования простота должна быть одной из ключевых целей, и следует избегать ненужной сложности. ","date":"14.12.2021","objectID":"/coding-principles/:3:0","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#kiss"},{"categories":["python-interview"],"content":"SLAPSingle Level of Abstraction Principle - «Принцип единого уровня абстракций» Диктует нам, как мы должны организовывать свой код (в частности, функции), чтобы он оставался поддерживаемым. ","date":"14.12.2021","objectID":"/coding-principles/:4:0","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#slap"},{"categories":["python-interview"],"content":"SOLIDSOLID это аббревиатура пяти основных принципов проектирования в объектно-ориентированном программировании, предложенных Робертом Мартином: Single responsibility — принцип единственной ответственности Open-closed — принцип открытости / закрытости Liskov substitution — принцип подстановки Барбары Лисков Interface segregation — принцип разделения интерфейса Dependency inversion — принцип инверсии зависимостей ","date":"14.12.2021","objectID":"/coding-principles/:5:0","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#solid"},{"categories":["python-interview"],"content":"SRPSingle Responsibility Principle - «Принцип единой ответственности», SRP В чем-то похож на SLAP, но направлен на объектно-ориентированное программирование. Этот принцип гласит, что объекты и классы (а также функции и методы) нужно организовывать так, чтобы каждый из них имел только одну зону ответственности. ","date":"14.12.2021","objectID":"/coding-principles/:5:1","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#srp"},{"categories":["python-interview"],"content":"OCPOpen-Closed Principle - «Принцип открытости-закрытости» Требует, чтобы код был открыт для новых, будущих дополнений, и чтобы при их добавлении не приходилось изменять уже написанный код. Этот принцип в большей степени затрагивает вопросы архитектуры, чем кода как такового. ","date":"14.12.2021","objectID":"/coding-principles/:5:2","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#ocp"},{"categories":["python-interview"],"content":"LSPLiskov Substitution Principle - «Принцип подстановки Барбары Лисков» Назван в честь его автора, Барбары Лисков. Суть его в том, что каждый подтип должен дополнять, а не заменять базовый тип. ","date":"14.12.2021","objectID":"/coding-principles/:5:3","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#lsp"},{"categories":["python-interview"],"content":"ISPInterface Segregation Principle - «Принцип разделения интерфейса» Это еще один принцип, затрагивающий тему организации кода. ","date":"14.12.2021","objectID":"/coding-principles/:5:4","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#isp"},{"categories":["python-interview"],"content":"DIPDependency Inversion Principle - «Принцип инверсии зависимостей» Как и OCP, DIP, в большей степени касается общей архитектуры кода. Фактически, это один из самых важных принципов проектирования архитектуры кода. код должен быть написан так, чтобы детали реализации (например, пользовательский интерфейс или база данных) зависели от основной логики (правил бизнеса), а не наоборот. все эти зависимости не должны быть прямыми. Их нужно абстрагировать при помощи интерфейсов, чтобы основная логика работала со всем, что бы ей ни передали, требуя для этого только какой-нибудь простой «мост». ","date":"14.12.2021","objectID":"/coding-principles/:5:5","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#dip"},{"categories":["python-interview"],"content":"CQSCommand-Query Separation - разделения команд и запросов Все функции некоторого интерфейса должны быть или некоторыми запросами, возвращающими ответ, или командами, изменяющими состояние системы, но не одновременно. Никогда функция не должна возвращать ответ и изменять состояние системы одновременно. ","date":"14.12.2021","objectID":"/coding-principles/:6:0","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#cqs"},{"categories":["python-interview"],"content":"LoDLaw of Demeter - закон Деметры Говорит нам примерно следующее: «не разговаривай с незнакомцами и не создавайте ненужных зависимостей». Закон Деметры — это, скорее, рекомендация, о которой стоит помнить. ","date":"14.12.2021","objectID":"/coding-principles/:7:0","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#lod"},{"categories":["python-interview"],"content":"IoCInversion of Control - Инверсия управления Важный принцип объектно-ориентированного программирования, используемый для уменьшения зацепления (связанности) в компьютерных программах. Он подразумевает что ходом программы управляет внешний, по отношению к ней, фреймворк. Dependency Injection (DI) является частью IoC. ","date":"14.12.2021","objectID":"/coding-principles/:8:0","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#ioc"},{"categories":["python-interview"],"content":"DIDependency Injection - Внедрение зависимости Стиль разработки программного кода, когда в зависимости класса не создаются им напрямую, а внедряются из вне. При этом уменьшается связанность кода, но теряется контроль над созданием и временем жизни объектов, от которых зависит класс. ","date":"14.12.2021","objectID":"/coding-principles/:8:1","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#di"},{"categories":["python-interview"],"content":"DAMPDescriptive And Meaningful Phrases - Описательные и значимые фразы Принцип написания модульных тестов таким образом, чтобы происходящее в них можно было понять без дополнительных комментариев и документации. Достигается использованием описательных имен и допускает небольшие нарушения принципа DRY при необходимости. ","date":"14.12.2021","objectID":"/coding-principles/:9:0","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#damp"},{"categories":["python-interview"],"content":"AAA (3A)Arrange Act Assert - Условие, Действие, Проверка Это шаблон для форматирования Unit тестов. Обозначающий разделения теста на 3 части Arrange - все необходимые подготовки и входные данные Act - собственно, вызов того метода который вы тестируете Assert - проверка, что метод делает то что надо ","date":"14.12.2021","objectID":"/coding-principles/:10:0","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#aaa-3a"},{"categories":["python-interview"],"content":"GRASPGeneral Responsibility Assignment Software Patterns - общие шаблоны распределения ответственностей Это набор шаблонов, используемых в объектно-ориентированном проектировании для решения общих задач по назначению ответственностей классам и объектам. ","date":"14.12.2021","objectID":"/coding-principles/:11:0","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#grasp"},{"categories":["python-interview"],"content":"Information ExpertИнформационный эксперт – класс, сосредотачивающий информацию о конкретной предметной области. Операции над ней также передаются в его ответственность. Например, Aсcount хранит информацию о счете и может предоставить выписку с него. ","date":"14.12.2021","objectID":"/coding-principles/:11:1","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#information-expert"},{"categories":["python-interview"],"content":"Creator (Создатель)Классы, создающие другие классы. Это может быть фабрика, пул и т.д. ","date":"14.12.2021","objectID":"/coding-principles/:11:2","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#creator-создатель"},{"categories":["python-interview"],"content":"Controller (Контроллер)Объект, который несет в себе управляющие функции (не путать с бизнес-логикой приложения). Яркий пример - Контроллер в шаблоне MVC. ","date":"14.12.2021","objectID":"/coding-principles/:11:3","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#controller-контроллер"},{"categories":["python-interview"],"content":"Low Coupling (Низкая связанность)Данный принцип декларирует программирование на основе интерфейсов и абстракций, а не конкретных реализаций. Это способствует упрощению повторного использования кода, его поддержки, модификации, тестированию. ","date":"14.12.2021","objectID":"/coding-principles/:11:4","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#low-coupling-низкая-связанность"},{"categories":["python-interview"],"content":"High Cohesion (Высокое сцепление)Методы внутри классы должны быть тесно связаны между собой. Это еще одна гарантия, того что класс обеспечивается реализацию четко определенной единственной ответственности. Классы с низким сцеплением легко можно разделить на несколько. ","date":"14.12.2021","objectID":"/coding-principles/:11:5","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#high-cohesion-высокое-сцепление"},{"categories":["python-interview"],"content":"Pure Fabrication (Чистая выдумка)Представляет собой классы, которые не отображают реальных объектов из предметной области приложения. Например, репозиторий, используемый для сохранения и загрузки объектов из хранилища. ","date":"14.12.2021","objectID":"/coding-principles/:11:6","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#pure-fabrication-чистая-выдумка"},{"categories":["python-interview"],"content":"Indirection (Посредник)Необходим для устранения сильной связанности нескольких классов. На него ложится ответственность организации взаимодействия между ними. К слову, Контроллер в MVC является также посредником между Моделью и Представлением. ","date":"14.12.2021","objectID":"/coding-principles/:11:7","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#indirection-посредник"},{"categories":["python-interview"],"content":"Protected Variations (Защищенные изменения)Данный принцип предполагает определение объектов, которые наиболее вероятно будут подвержены изменениям, и применение мер, по минимизации влияний этих изменений на остальные части приложения. ","date":"14.12.2021","objectID":"/coding-principles/:11:8","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#protected-variations-защищенные-изменения"},{"categories":["python-interview"],"content":"Polymorphism (Полиморфизм)Возможность объектов с одинаковой спецификацией иметь различную реализацию. ","date":"14.12.2021","objectID":"/coding-principles/:11:9","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#polymorphism-полиморфизм"},{"categories":["python-interview"],"content":"OROccam’s Razor - Бритва Оккама Суть в том, что не нужно создавать лишние методы, классы и переменные, если в них нет нужды. ","date":"14.12.2021","objectID":"/coding-principles/:12:0","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#or"},{"categories":["python-interview"],"content":"BDUFBig Design Up Front - Глобальное проектирование прежде всего Этот подход к разработке программного обеспечения очень важен, и его часто игнорируют. Прежде чем переходить к реализации, убедитесь, что все хорошо продумано. ","date":"14.12.2021","objectID":"/coding-principles/:13:0","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#bduf"},{"categories":["python-interview"],"content":"APOAvoid Premature Optimization - Избегайте преждевременной оптимизации Преждевременная оптимизация может привести к задержкам в коде и, следовательно, увеличит затраты времени на вывод функций на рынок. Многие считают преждевременную оптимизацию корнем всех зол. ","date":"14.12.2021","objectID":"/coding-principles/:14:0","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#apo"},{"categories":["python-interview"],"content":"POLAPrinciple Of Least Astonishment - Принцип наименьшего удивления Не заставляйте удивляться других программистов вашему коду. Нужно программировать просто, понятно и очевидно, чтобы любой другой специалист мог прочитать ваше творение. Имена и названия методов и классов должны нести информативность и быть лаконичными. Вызываемый метод должен соответствовать тому, для чего он вызывается и как он называется. Источники: 10 Coding principles and acronyms demystified! ","date":"14.12.2021","objectID":"/coding-principles/:15:0","series":null,"tags":null,"title":"15 принципов разработки ПО - аббревиатуры и расшифровка","uri":"/coding-principles/#pola"},{"categories":["python-interview"],"content":"Вопросы на собеседование по Python","date":"11.12.2021","objectID":"/python-interview-questions/","series":null,"tags":["python"],"title":"Вопросы с ответами к собеседованию по Python","uri":"/python-interview-questions/"},{"categories":["python-interview"],"content":"Общие вопросы Принципы программирования? Отличия процедурной и объектно-ориентированной парадигмы программирования? Основные принципы ООП? Что такое множественное наследование? Что такое @property? Что такое инженерия и процесс разработки в целом? Основные методологии разработки (жизненный цикл продукта)? Методология Agile. Различия Kanban и Scrum подходов. Методы HTTP-запросов и какая между ними разница? Как выглядят HTTP-request/response? Что такое авторизация и как она работает? Что такое cookies? Что такое веб уязвимость? Какие знаете классические базы данных? Как читать спецификацию в конкретном языке (например, PEP8 в Python)? Как происходит взаимодействие клиента и сервера? Какие есть подходы к проектированию API? Как масштабировать API? Паттерны проектирования и как они используются? Что такое Acceptance Testing и зачем его используют? Что такое модульные и интеграционные тесты, API-тесты? Как писать unit-тесты? Какие есть best practices в написании автотестов? Какие базовые команды системы контроля версий? Как использовать Git? В чем разница между хешированием и шифрованием? Ориентируетесь ли в *nix, можете ли написать скрипты/автоматизацию для себя и коллег? Что такое многопоточность? Что такое архитектура веб сервисов? Как работает современное нагруженное веб приложение (нарисовать и обсудить примерную архитектуру, например, Twitter или Instagram)? Что нужно для сайта/сервиса среднего размера (redis, celery, кэш, логирование, метрики)? Как написать, задеплоить и поддерживать (микро) сервис? Как проводить Code review? Что такое абстрактная фабрика, как ее реализовать и зачем ее применяют? Что такое цикломатическая сложность? Каким образом можно запустить код на Python параллельно? Как работать с stdlib? Какие задачи решали с помощью метаклассов? Что такое дескрипторы? ","date":"11.12.2021","objectID":"/python-interview-questions/:1:0","series":null,"tags":["python"],"title":"Вопросы с ответами к собеседованию по Python","uri":"/python-interview-questions/#общие-вопросы"},{"categories":["python-interview"],"content":"Python Какие есть изменяемые и постоянные типы данных? Какие есть типы данных и какая разница между list и tuple, зачем они? Как использовать встроенные коллекции (list, set, dict)? В чем заключается сложность доступа к элементам dict? Что такое область видимости переменных? Что такое introspection? В чем заключается разница между операторами is и ==? Как создается объект в Python. Разница между __init__ и __new__? В чем разница между потоками и процессами? Какие есть виды импорта? Что такое итератор и генератор. В чем между ними разница? Что такое сопрограммы (corutines) и как они реализованы в Python? Что такое метакласс, переменная цикла? В чем разница между staticmethod и classmethod? Как работают контекстные менеджеры? Как работают декораторы? Можно ли использовать несколько декораторов для одной функции? Можно ли создать декоратор из класса? Как работают dict comprehension, list comprehension и set comprehension? Какие есть основные популярные пакеты (requests, pytest, etc)? Что такое lambda-функции? Что означает *args, **kwargs и как они используются? Как передаются аргументы функций в Python (by value or reference)? Что такое exceptions, \u003ctry-except\u003e? Что такое PEP (Python Enhancement Proposal), какие из них знаете (PEP8, PEP484)? Что знаете из модуля collections, какими еще built-in модулями пользовались? Как Python работает с HTTP-сервером? Что происходит, когда создается виртуальная среда? Async Python: как работает, зачем, что под капотом? Что такое модель памяти Python? Принципы работы и механизм Garbage collection, reference counting? Как работает thread locals? Что такое __slots__? Что такое type annotation? Какие преимущества дает Variable Annotations? Для чего используют нижние подчеркивания в именах объектов? Статические анализаторы: Flake8, Pylint, Radon. ","date":"11.12.2021","objectID":"/python-interview-questions/:2:0","series":null,"tags":["python"],"title":"Вопросы с ответами к собеседованию по Python","uri":"/python-interview-questions/#python"},{"categories":["python-interview"],"content":"Django N+1 проблема и как решить? Что такое SQLAlchemy (Core и ORM частей) и какие есть альтернативы? Что такое шаблонизатор и как в нем выполнять базовые операции (объединять участки шаблона, выводить дату, выводить данные с серверной стороны)? Что такое миксины? Как провалидировать данные в сериализаторе? Методы create, update в серилизаторе. Как передать в запросе лист id так, чтобы создался объект сразу с m2m связими? Что такое lt, gt, gte, lte в ORM? or в Django ORM. Напишите hello-world сервис, используя один из фреймворков. Сравнить асинхронные web-фреймворки. ","date":"11.12.2021","objectID":"/python-interview-questions/:3:0","series":null,"tags":["python"],"title":"Вопросы с ответами к собеседованию по Python","uri":"/python-interview-questions/#django"},{"categories":["python-interview"],"content":"Базы данных Какие есть базовые методы работы с SQL-базой данных в Python? Что такое SQL-транзакция? Как сделать выборку из SQL-базы с простой агрегацией? Как выглядит запрос, который выполняет JOIN между таблицами и к самим себе? Как отправлять запросы в SQL-базу данных без ORM? Индексация в базе данных sql Разница между SQL и NoSQL? Как оптимизировать SQL-запросы? Какие есть уровни изоляции транзакций? Какие есть виды индексов? ","date":"11.12.2021","objectID":"/python-interview-questions/:4:0","series":null,"tags":["python"],"title":"Вопросы с ответами к собеседованию по Python","uri":"/python-interview-questions/#базы-данных"},{"categories":["python-interview"],"content":"DevOps Рассказать про Docker, Docker Compose и Docker Swarm Объяснить основные термины K8s (кластер, pod, node, deployment, service), что такое Kibana? Как зайти на внешний сервер, работать с пакетами, настроить среду и выполнять операции? ","date":"11.12.2021","objectID":"/python-interview-questions/:5:0","series":null,"tags":["python"],"title":"Вопросы с ответами к собеседованию по Python","uri":"/python-interview-questions/#devops"},{"categories":["python-interview"],"content":"Data Science Как работать с пакетами для обработки и визуализации данных (NumPy, Pandas и другие)? ","date":"11.12.2021","objectID":"/python-interview-questions/:6:0","series":null,"tags":["python"],"title":"Вопросы с ответами к собеседованию по Python","uri":"/python-interview-questions/#data-science"},{"categories":["python-interview"],"content":"Алгоритмы Что такое временная сложность алгоритма (time complexity)? Что такое Big-O notation? Какие есть базовые алгоритмы сортировки? Что такое Bubble Sort и как это работает? Что такое линейная сложность сортировки? ","date":"11.12.2021","objectID":"/python-interview-questions/:7:0","series":null,"tags":["python"],"title":"Вопросы с ответами к собеседованию по Python","uri":"/python-interview-questions/#алгоритмы"},{"categories":null,"content":"Описание","date":"08.12.2021","objectID":"/about/","series":null,"tags":null,"title":"Обо мне","uri":"/about/"},{"categories":null,"content":" 🖖 Привет! Меня зовут Алексей, мне 35 лет и я Веб-мастер Backend разработчик. -- Мой путь -- Первую HTML страничку я сделал примерно в 2001 году, и это во многом определило мою дальнейшую жизнь. В 2004 поступил в ННГУ Лобачевского на факультет ВМК (прикладная математика и информатика). В 2009 получил диплом специалиста по специальности \"математик, системный программист\". Будучи студентом, а затем стажером - изучал и применял на практике С++ и Java. -- По своей инициативе ковырялся в PHP, Perl и JS. Наверное, с тех пор я и отдал предпочтение интерпретируемым языкам. -- Более 10 лет я занимался разработкой и продвижением сайтов. За это время успел поработать с CMS Joomla, InstantCMS, Opencart, Wordpress, 1C-Bitrix. Разрабатывал с нуля сайты-визитки, одностраничники, интернет-магазины, корпоративные сайты, статейники и агрегаторы. Работая как частный специалист проходил все этапы разработки: Как менеджер проекта: выявление потребностей клиента, разработка и согласование ТЗ, анализ ниши, согласование этапов разработки; Как frontend-разработчик: прототипирование, верстка, интеграция; Как backend-разработчик: развертывание сайта на хостинге, установка и настройка CMS, доработка функционала; Как SEO-специалист: анализ конкурентов, сбор и кластеризация семантического ядра, рекомендации по созданию структуры и подготовке контента, оптимизация сайта, технический аудит, настройка аналитики; Как контент-менеджер: создание структуры сайта, наполнение сайта; Ценность полученного мной опыта в том, что я могу глубже погружаться в поставленную задачу на основе существующих знаний. Считаю, что разработчик, понимающий весь стек технологий, способен: писать более качественные приложения; более эффективно взаимодействовать с коллегами; обладая обширным арсеналом идей и концепций, лучше справляться со своими основными задачами; лучше понимать, что происходит при использовании клиентом программного обеспечения; лучше понимать бизнес клиента. Что я использую в работе MacOS VS Code (GitLens, Beautify, htmltagwrap, Thunder Client) iTerm (zsh, oh-my-zsh, powerlevel10k, brew, pyenv, vim NeoVIM) Docker SnippetsLab CotEditor Safari PasteBot, Translatium Trello, Things, Notion GoodNotes, Notability Parallels Desktop Affinity Photo, Affinity Designer, Affinity Publisher Postman SimpleMind Pro -- -- Навыки Python Django DRF JSON APIs PostgreSQL Celery Flower Nginx Traefik Redis Prometheus Grafana Docker Docker Compose Git GitHub GitHub Actions Unit testing HTML CSS Таймлайн февраль 2021 — по настоящее время Погружаюсь в бэкенд (Python, Django) октябрь 2015 — февраль 2022 Web-разработчик, SEO-специалист в ПКФ Луидор, Нижний Новгород (автомобильный завод, спецавтомобили) апрель 2012 — октябрь 2015 Full-stack разработчик, SEO специалист на фрилансе сентябрь 2011 — апрель 2012 Заместитель руководителя филиала в Редокс, Москва (оптовая торговля, товары для здоровья) сентябрь 2008 — апрель 2011 Менеджер по продажам в Редокс, Нижний Новгород (розничная торговля, товары для здоровья) ноябрь 2006 — май 2008 Инженер-стажер в Тэлма Софт, Нижний Новгород (разработка ПО) сентябрь 2004 — май 2009 ННГУ им. Лобачевского, ВМК Нижний Новгород сентябрь 1994 — май 2004 Средняя школа №4, Городец -- -- ","date":"08.12.2021","objectID":"/about/:0:0","series":null,"tags":null,"title":"Обо мне","uri":"/about/#"},{"categories":null,"content":"Образование: ННГУ Лобачевского (ВМК). Стек: Python 3.6+, Django 2.2+, DRF, PostgreSQL, Redis, Celery, Docker, git, pytest, HTML, CSS, JS. Более 10 лет опыта в разработке и продвижении сайтов.","date":"08.12.2021","objectID":"/cv/","series":null,"tags":null,"title":"Резюме: Junior python backend developer | Байков Алексей","uri":"/cv/"},{"categories":null,"content":"Резюме на вакансию в компанию -- Скачать (.pdf) Байков Алексей 02.01.1987 (35 лет) Python backend разработчик Уровень: Junior, Junior+ -- Опыт в стеке: 1 года Занятость: полная Формат работы: удаленная, в офисе Зарплатные ожидания: 80.000 - 100.000 руб Контакты +7 (929) 053-73-35 https://t.me/alexbaikov alex@baikov.dev Нижний Новгород, Россия -- Python Django DRF JSON APIs PostgreSQL Celery Flower Nginx Traefik Redis Prometheus Grafana Docker Docker Compose Git GitHub GitHub Actions Unit testing HTML CSS Все навыки... -- Образование ННГУ им. Лобачевского Нижегородский государственный университет им. Н.И. Лобачевского 2004-2009 (5 лет), дневное отделение, очно Факультет вычислительной математики и кибернетики Специальность: Прикладная математика и информатика Специализация: Системы поддержки принятия решений -- Квалификация: математик, системный программист Цели Начать карьеру backend-разработчика в современной продуктовой компании. Профессиональный рост до уровня Middle в течение года и, как следствие, повышение своей рентабельности. Стек: Python 3.6+, Django 2.2+, PostgreSQL, DRF, FastAPI, Docker. -- Опыт работы февраль 2021 — по настоящее время (1 год) Изучение нового стека Все изучаемые технологии применял на практике (проект allflags.ru) Краткий список практических навыков: Администрирование VPS, работа с Heroku, AWS, Yandex.Cloud; Настройка Nginx, Traefik, Prometheus, Grafana; Работа с Docker и Docker Compose, основы CI/CD; Codestyle (flake8, black), тестирование (pytest, coverage), документирование (Sphinx); Контроль версий и процесс ветвления (git, github, git-flow, github-flow); Работа с Django, DRF, PostgreSQL, Redis, Celery, Flower. Python Django Git Docker Celery PostgreSQL DRF Redis CI/CD Traefik Linux Prometheus Grafana -- октябрь 2015 — по настоящее время (6 лет 4 мес) ПКФ Луидор, Нижний Новгород (автомобильный завод, спецавтомобили) Web-разработчик, SEO-специалист Разработал сервис поиска запчастей по VIN (backend: Django и DRF, frontend: Vue.js); Разработка, доработка и продвижение сайтов компании на 1C-Bitrix; Более 3 лет опыта удаленной работы. HTML CSS Vue.js SCSS 1С-Bitrix PHP SEO JavaScript Gulp -- апрель 2012 — октябрь 2015 (3 года 7 мес) Фриланс, собственные проекты Full-stack разработчик, SEO специалист создание и продвижение сайтов (1C-Bitrix, WordPress, OpenCart). сентябрь 2011 — апрель 2012 (1 год 1 мес) Редокс, Москва (оптовая торговля, товары для здоровья) Заместитель руководителя филиала сентябрь 2008 — апрель 2011 (2 года 7 мес) Редокс, Нижний Новгород (розничная торговля, товары для здоровья) Менеджер по продажам ноябрь 2006 — май 2008 (1 год 7 мес) Тэлма Софт, Нижний Новгород (разработка ПО) Инженер-стажер в отделе разработки и тестирования ПО Стажировка во время обучения в университете. Обо мне Я люблю веб-разработку и занимаюсь ей более 10 лет. За это время приобрел как менеджерский опыт, так и опыт во frontend, backend и DevOps. Надеюсь, что новый стек и углубление в бэкенд позволят мне участвовать в разработке более крупных и интересных проектов. Моя цель на текущий год: начать карьеру backend-разработчика в современной компании и дорасти до уровня Middle. Навыки Python Django DRF JSON APIs PostgreSQL Celery Flower Nginx Traefik Redis Prometheus Grafana Docker Docker Compose Git GitHub GitHub Actions Unit testing HTML CSS -- Образование ННГУ им. Лобачевского Нижегородский государственный университет им. Н.И. Лобачевского 2004-2009 (5 лет), дневное отделение, очно Факультет вычислительной математики и кибернетики Специальность: Прикладная математика и информатика Специализация: Системы поддержки принятия решений -- Квалификация: математик, системный программист Навыки Python Django DRF JSON APIs PostgreSQL Celery Flower Nginx Traefik Redis Prometheus Grafana Docker Docker Compose Git GitHub GitHub Actions Unit testing HTML CSS Языки Русский родной Английский Intermediate Курсы Docker 2021, slurm.io-- Docker | 2021, slurm.io Build a Backend REST API with Python \u0026 Django 2021, Udemi-- Build a ","date":"08.12.2021","objectID":"/cv/:0:0","series":null,"tags":null,"title":"Резюме: Junior python backend developer | Байков Алексей","uri":"/cv/#"},{"categories":["python-interview"],"content":"Область видимости или scope определяет контекст переменной, в рамках которого ее можно использовать. В Python есть три типа контекста: глобальный, локальный и нелокальный.","date":"21.10.2021","objectID":"/python-scope-of-variables/","series":null,"tags":["python"],"title":"Область видимости переменных в Python","uri":"/python-scope-of-variables/"},{"categories":["python-interview"],"content":"Список вопросов к Python собеседованию Область видимости (scope) определяет контекст переменной, в рамках которого ее можно использовать. В Python существует три области видимости: локальная глобальная нелокальная Основные моменты: Изнутри функции видны переменные, которые были определены и внутри нее и снаружи. Переменные, определенные внутри функции – локальные, снаружи – глобальные. Снаружи функций не видны никакие переменные, определенные внутри них. Изнутри функции можно изменять значение переменных, которые определены в глобальной области видимости с помощью спецификатора global. Изнутри вложенной функции с помощью спецификатора nonlocal можно изменять значения переменных, которые были определены во внешней функции, но не находятся в глобальной области видимости. Источники: Хабр статья Документация Python ","date":"21.10.2021","objectID":"/python-scope-of-variables/:0:0","series":null,"tags":["python"],"title":"Область видимости переменных в Python","uri":"/python-scope-of-variables/#"},{"categories":["python-interview"],"content":"Все четыре основных аспекта общей структуры ООП поддерживаются системой объектно-ориентированного программирования Python: инкапсуляция, абстракция, наследование и полиморфизм.","date":"17.10.2021","objectID":"/python-oop/","series":["oop"],"tags":["python","oop-tag"],"title":"Объектно-ориентированное программирование (ООП) в Python","uri":"/python-oop/"},{"categories":["python-interview"],"content":"Список вопросов к Python собеседованию ","date":"17.10.2021","objectID":"/python-oop/:0:0","series":["oop"],"tags":["python","oop-tag"],"title":"Объектно-ориентированное программирование (ООП) в Python","uri":"/python-oop/#"},{"categories":["python-interview"],"content":"Отличия процедурного подхода и ООПСуществуют два главных подхода к написанию программ: Процедурное программирование Объектно-ориентированное программирование (ООП) Цель у этих подходов одна - сделать процесс программирования максимально эффективным. Но в ООП, в отличии от процедурного подхода, данные первичны, а код для обработки этих данных - вторичен. В процедурном подходе основой программы является функция. Функции вызывают друг друга и при необходимости передают данные. В программе функции живут отдельно, данные — отдельно. Основной недостаток процедурного подхода - сложность создания и поддержки больших программ. Наличие сотен функций в таких проектах очень часто приводит к ошибкам и спагетти-коду. В основе объектно-ориентированного программирования лежит понятие объекта. Объект совмещает в себе и функции и данные. Основное преимущество ООП перед процедурным программированием - изоляция кода на уровне классов, что позволяет писать более простой и лаконичный код.1 ","date":"17.10.2021","objectID":"/python-oop/:1:0","series":["oop"],"tags":["python","oop-tag"],"title":"Объектно-ориентированное программирование (ООП) в Python","uri":"/python-oop/#отличия-процедурного-подхода-и-ооп"},{"categories":["python-interview"],"content":"Классы и объекты в ООП Объектно-ориентированное программирование (ООП) — методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определённого класса, а классы образуют иерархию наследования.2 Класс описывает множество объектов, имеющих общую структуру и обладающих одинаковым поведением это шаблон кода, по которому создаются объекты. Т. е. сам по себе класс ничего не делает, но с его помощью можно создать объект и уже его использовать в работе Классы в Python – это тоже объекты Допустимо динамическое изменение и добавление атрибутов классов Для скрытия внутренних данных используются синтаксические соглашения Поддерживается наследование Полиморфизм обеспечивается виртуальностью всех методов Доступно метапрограммирование Объект (экземпляр класса) это конкретный представитель класса Жизненным циклом объекта можно управлять Многие операторы могут быть перезагружены Многие методы встроенных объектов можно эмулировать # класс с минимально-возможным функционалом class A: pass # объект класса a = A() ","date":"17.10.2021","objectID":"/python-oop/:2:0","series":["oop"],"tags":["python","oop-tag"],"title":"Объектно-ориентированное программирование (ООП) в Python","uri":"/python-oop/#классы-и-объекты-в-ооп"},{"categories":["python-interview"],"content":"Атрибуты класса (Attributes)Атрибут класса (объекта) - любой элемент (свойство, метод, подкласс), на который можно сослаться через символ точки (MyClass.\u003cатрибут\u003e или my_object.\u003cатрибут\u003e). Атрибуты делятся на встроенные и пользовательские: Встроенные (служебные) атрибуты - методы и свойства унаследованные от общего для всех классов в Python родительского класса object. Многие из этих атрибутов можно переопределить внутри своего класса. Пользовательские атрибуты - поля и методы, которые описываются программистом в теле класса. Добавляются в общий список атрибутов наряду со встроенными.3 Поля класса - это характеристики объекта класса. Методы класса - это функции, с помощью которых можно оперировать данными класса. Любой метод является атрибутом, но не любой атрибут - методом. Атрибуты-поля можно условно разделить на две группы: Статические - поля класса, которые объявляются внутри тела класса и создаются тогда, когда создается класс. Динамические - поля экземпляра. Для создания динамического поля необходимо обратиться к self внутри метода. class Phone: # Статические атрибуты (поля) default_color = 'Grey' default_model = 'C385' def __init__(self, color, model): # Динамические атрибуты (поля) self.color = color self.model = model Служебное слово self - это ссылка на текущий экземпляр класса. self не является зарезервированным. Является аналогом этого this (Java, C++). ","date":"17.10.2021","objectID":"/python-oop/:3:0","series":["oop"],"tags":["python","oop-tag"],"title":"Объектно-ориентированное программирование (ООП) в Python","uri":"/python-oop/#атрибуты-класса-attributes"},{"categories":["python-interview"],"content":"Встроенные (специальные) атрибутыАтрибуты (поля и методы), имена которых обрамляются __, Python трактует как специальные. Специальные атрибуты, как правило, идут первыми при объявлении класса. Использование: операторы перегрузки - если необходимо добавить возможность выполнения стандартных операций над классами дополнить… Основные встроенные методы и поля: __new__(cls, ...) - Конструктор. Создает экземпляр класса. Сам класс передается в качестве аргумента. Редко переопределяется, чаще используется реализация от базового класса object __init__(self, ...) - Инициализатор. Принимает свежесозданный объект класса из конструктора. Является очень удобным способом задать параметры объекта при его создании. __del__(self) - Деструктор. Вызывается при удалении объекта сборщиком мусора __str__(self) - Возвращает строковое представление объекта. __repr__ __hash__(self) - Возвращает хэш-сумму объекта. __doc__ - Тип: str. Документация класса. __dict__ - Тип: dict. Словарь, в котором хранится пространство имен класса ","date":"17.10.2021","objectID":"/python-oop/:3:1","series":["oop"],"tags":["python","oop-tag"],"title":"Объектно-ориентированное программирование (ООП) в Python","uri":"/python-oop/#встроенные-специальные-атрибуты"},{"categories":["python-interview"],"content":"Свойства класса (@property)Организация доступа к членам класса в Python построена на принципе универсального доступа, гласящем, что «все услуги, предлагаемые модулем должны быть доступны через единую нотацию, которая не раскрывает, реализованы ли они посредством хранения либо вычисления». В частности, это предполагает предоставлять доступ к переменным напрямую, например, foo.x = 0, а не foo.set_x(0); в случае необходимости проверки устанавливаемого значения использовать свойства, которые сохраняют единый синтаксис доступа, установка значения foo.x = 0 приводит к вызову foo.set_x(0). Преимуществом данного подхода является возможность использование синтаксиса foo.x += 1, хотя на самом деле внутри происходит вызов foo.set_x(foo.get_x() + 1). Свойства (Property) — это особый вид атрибутов имитирующий поле (но который при чтении вызывает какой-либо метод). У них есть методы получения, установки и удаления, такие как __get__, __set__ и __delete__ Мы можем определить геттеры, сеттеры и деструкторы с помощью функции property() Свойство может определяться при помощи декораторов: @property - определяет метод получения значения, @field.setter - определяет метод установки значения свойства field. Имя свойства field определяется в наименовании обоих методов и декораторе @field.setter Если необходимо реализовать свойство «только для чтения», второй метод может быть опущен вместе с декоратором @field.setter Примером применения свойства является получение информации, которая может потребовать затратного первоначального поиска и простого повторного class Cash: def __init__(self, value): self.value = value @property def formatted(self): return '${:.2f}'.format(self.value) @formatted.setter def formatted(self, new): self.value = float(new[1:]) По сути, когда Python встречает следующий код: spam = SomeObject() print(spam.eggs) он ищет eggs в spam, а затем проверяет eggs на наличие у него методов __get__, __set__ или __delete__ и если они есть, то это свойство. Если это свойство, то вместо того, чтобы просто вернуть объект eggs (как это было бы для любого другого атрибута), он вызовет метод __get__ и возвращает все, что возвращает этот метод.4 ","date":"17.10.2021","objectID":"/python-oop/:3:2","series":["oop"],"tags":["python","oop-tag"],"title":"Объектно-ориентированное программирование (ООП) в Python","uri":"/python-oop/#свойства-класса-property"},{"categories":["python-interview"],"content":"Методы экземпляра (обычные методы)Методы экземпляра - это обычные функции, которые становятся доступны только после создания экземпляра класса. Первым параметром такого метода является слово self. ","date":"17.10.2021","objectID":"/python-oop/:3:3","series":["oop"],"tags":["python","oop-tag"],"title":"Объектно-ориентированное программирование (ООП) в Python","uri":"/python-oop/#методы-экземпляра-обычные-методы"},{"categories":["python-interview"],"content":"Статические методы (Static methods)Статические методы - это обычные функции, которые помещены в класс для удобства и тем самым располагаются в области видимости этого класса. Чаще всего это какой-то вспомогательный код. Обозначаются специальным декоратором @staticmethod. ничего не знают о классе или об объекте, на котором они вызываются не принимают специальных аргументов типа self или cls поэтому не используют сам объект или класс при выполнении могут быть вызваны, как через сам класс, так и через его экземпляр ","date":"17.10.2021","objectID":"/python-oop/:3:4","series":["oop"],"tags":["python","oop-tag"],"title":"Объектно-ориентированное программирование (ООП) в Python","uri":"/python-oop/#статические-методы-static-methods"},{"categories":["python-interview"],"content":"Методы класса (Class methods)Методы класса принимают в качестве первого параметра cls (вместо self в обычных методах). cls - это ссылка на класс, на котором был вызван метод. Обозначаются специальным декоратором @classmethod. могут менять состояние самого класса, что в свою очередь отражается на ВСЕХ экземплярах данного класса не могут менять конкретный объект класса используются, когда не требуется привязка к экземпляру объекта привязаны только к области видимости Методы класса часто используются, когда: Необходимо создать специфичный объект текущего класса Нужно реализовать фабричный паттерн (создаём объекты различных унаследованных классов прямо внутри метода) Реализовать дополнительные методы инициализации ","date":"17.10.2021","objectID":"/python-oop/:3:5","series":["oop"],"tags":["python","oop-tag"],"title":"Объектно-ориентированное программирование (ООП) в Python","uri":"/python-oop/#методы-класса-class-methods"},{"categories":["python-interview"],"content":"Перегрузка методов (Method Overloading)Перегрузка методов (Множественная диспетчеризация, Мультиметоды) - это использование множества методов с одним и тем же именем, которые позволяют выбирать нужную функциональность в зависимости от количества, типов или значений аргументов в пределах одного класса. Python по умолчанию не поддерживает перегрузку методов, поскольку запоминает только самое последнее определение метода. Для их реализации необходимо подключать сторонние Python библиотеки, например, multimethods.py. ","date":"17.10.2021","objectID":"/python-oop/:3:6","series":["oop"],"tags":["python","oop-tag"],"title":"Объектно-ориентированное программирование (ООП) в Python","uri":"/python-oop/#перегрузка-методов-method-overloading"},{"categories":["python-interview"],"content":"Переопределение методов (Method Overriding)Когда метод с тем же именем и аргументами используется как в производном классе, так и в базовом или суперклассе, мы говорим, что метод производного класса переопределяет метод, представленный в базовом классе. ","date":"17.10.2021","objectID":"/python-oop/:3:7","series":["oop"],"tags":["python","oop-tag"],"title":"Объектно-ориентированное программирование (ООП) в Python","uri":"/python-oop/#переопределение-методов-method-overriding"},{"categories":["python-interview"],"content":"Последовательность поиска атрибутовУ одного объекта может быть несколько родительских классов, а также специальные методы вроде __getattribute__, которые перехватывают запросы к атрибутам. Каким же образом интерпретатор разрешает сложные запросы к свойствам и методам? Рассмотрим последовательность поиска на примере запроса obj.field: Вызов obj.__getattribute__('field'), если он определен. При установке или удалении атрибута проверяется соответственно наличие __setattr__ или __delattr__. Поиск в obj.__dict__ (пользовательские атрибуты). Поиск в object.__class__.__slots__. Рекурсивный поиск в поле __dict__ всех родительских классов. Если класс имеет несколько предков, порядок проверки соответствует порядку их перечисления в определении. Если определен метод __getattr__, то происходит вызов obj.__getattr__('field') Выбрасывается исключение несуществующего атрибута – AttributeError. Наконец, когда атрибут нашелся, проверяется наличие метода __get__ (при установке – __set__, при удалении – __delete__). Все эти проверки совершаются только для пользовательских атрибутов.5 ","date":"17.10.2021","objectID":"/python-oop/:3:8","series":["oop"],"tags":["python","oop-tag"],"title":"Объектно-ориентированное программирование (ООП) в Python","uri":"/python-oop/#последовательность-поиска-атрибутов"},{"categories":["python-interview"],"content":"Класс как структура данныхВ ряде случаев бывает полезным иметь структуру, похожую на структуру из языка Си (или запись из Паскаля), позволяющую логически сгруппировать данные. Для этого можно использовать словарь или класс с пустой реализацией. ","date":"17.10.2021","objectID":"/python-oop/:3:9","series":["oop"],"tags":["python","oop-tag"],"title":"Объектно-ориентированное программирование (ООП) в Python","uri":"/python-oop/#класс-как-структура-данных"},{"categories":["python-interview"],"content":"Основные принципы ООПНа текущий момент ООП является самой востребованной и распространенной парадигмой программирования. Концепция ООП строится на основе 4 принципов: абстракция, инкапсуляция, наследование и полиморфизм. ","date":"17.10.2021","objectID":"/python-oop/:4:0","series":["oop"],"tags":["python","oop-tag"],"title":"Объектно-ориентированное программирование (ООП) в Python","uri":"/python-oop/#основные-принципы-ооп"},{"categories":["python-interview"],"content":"Абстракция Абстракция - принцип ООП, согласно которому объект характеризуется свойствами, которые отличают его от всех остальных объектов и при этом четко определяют его концептуальные границы. Абстракция позволяет представить сложную концепцию в более простой форме: Выделить главные и наиболее значимые свойства предмета. Отбросить второстепенные характеристики. Абстракция не поддерживается в Python напрямую. ","date":"17.10.2021","objectID":"/python-oop/:4:1","series":["oop"],"tags":["python","oop-tag"],"title":"Объектно-ориентированное программирование (ООП) в Python","uri":"/python-oop/#абстракция"},{"categories":["python-interview"],"content":"Инкапсуляция Инкапсуляция - принцип ООП, согласно которому сложность реализации программного компонента должна быть спрятана за его интерфейсом. Инкапсуляция не дает взглянуть на внутреннюю реализацию сложной концепции: Отсутствует доступ к внутреннему устройству программного компонента. Взаимодействие компонента с внешним миром осуществляется посредством интерфейса, который включает публичные методы и поля. В ряде языков, например, С++, существует четкое разделение членов класса на закрытые (private), защищенные (protected) и публичные (public). В Python все члены класса являются общедоступными, но существует возможность эмуляции private и protected на уровне договоренностей. Концепция отсутствия закрытых атрибутов в Python описывается фразой одного из разработчиков языка: «Мы все взрослые люди. Если программист хочет выстрелить себе в ногу - нужно предоставить ему возможность это сделать». В Python принята следующая договоренность: Protected (Non-Public) - обозначается при помощи одинарного нижнего подчеркивания _. Данный синтаксис указывает на то, что атрибут: используется для внутренней реализации класса и не предназначен для использования извне; должен быть использован/изменен только если разработчик-пользователь класса абсолютно уверен в этом. При этом атрибут с _ доступен извне, как и обычный public-атрибут класса. Private - обозначается при помощи двойного нижнего подчеркивания __. Данный синтаксис указывает на то, что атрибут: используется для внутренней реализации класса и не предназначен для использования извне; не должен быть использован/изменен разработчиком-пользователем класса. При этом атрибут с __ оказывается недоступным извне, используя технику сокрытия имен (Name Mangling). Несмотря на это, в отличие от ряда языков (например, Java) такие «закрытые» члены класса также можно изменять, но более сложным способом - их можно увидеть, используя функцию dir(). We don’t use the term “private” here, since no attribute is really private in Python (without a generally unnecessary amount of work).6 class SomeClass: def __init__(self, public_var: str, protected_var: str, private_var: str): self.public_var = public_var # public self._protected_var = protected_var # protected self.__private_var = private_var # private def _private(self): # Это внутренний метод объекта print(\"Private method\") obj = SomeClass(\"I'm Public\", \"I'm Protected\", \"I'm Private\") obj.public_var # \u003e\u003eI'm Public obj._protected_var # \u003e\u003eI'm Protected obj.__private_var # AttributeError: 'SomeClass' object has no attribute '__private_var' obj._SomeClass__private_var # \u003e\u003eI'm Private obj._private() # \u003e\u003ePrivate method Геттеры, сеттеры и деструкторыКроме прямого доступа к атрибутам (obj.attrName), могут быть использованы специальные методы доступа: геттеры, сеттеры и деструкторы: class SomeClass: def __init__(self, value): self._value = value def getvalue(self): # получение значения атрибута - геттер return self._value def setvalue(self, value): # установка значения атрибута - сеттер self._value = value def delvalue(self): # удаление атрибута - деструктор del self._value value = property(getvalue, setvalue, delvalue, \"Свойство value\") Такой подход очень удобен, если получение или установка значения атрибута требует сложной логики. Вместо того чтобы вручную создавать геттеры и сеттеры для каждого атрибута, можно перегрузить встроенные методы __getattr__, __setattr__ и __delattr__. Например, так можно перехватить обращение к свойствам и методам, которых в объекте не существует: class SomeClass(): attr1 = 42 def __getattr__(self, attr): return attr.upper() obj = SomeClass() obj.attr1 # 42 obj.attr2 # ATTR2 __getattribute__ перехватывает все обращения (в том числе и к существующим атрибутам). Для чего нужна инкапсуляция? Инкапсуляция упрощает процесс разработки, т. к. позволяет нам не вникать в тонкости реализации того или иного объекта. Повышается надежность программ за счет того, что при внесении изменений в один из компонентов, остальные части программы остаются ","date":"17.10.2021","objectID":"/python-oop/:4:2","series":["oop"],"tags":["python","oop-tag"],"title":"Объектно-ориентированное программирование (ООП) в Python","uri":"/python-oop/#инкапсуляция"},{"categories":["python-interview"],"content":"Инкапсуляция Инкапсуляция - принцип ООП, согласно которому сложность реализации программного компонента должна быть спрятана за его интерфейсом. Инкапсуляция не дает взглянуть на внутреннюю реализацию сложной концепции: Отсутствует доступ к внутреннему устройству программного компонента. Взаимодействие компонента с внешним миром осуществляется посредством интерфейса, который включает публичные методы и поля. В ряде языков, например, С++, существует четкое разделение членов класса на закрытые (private), защищенные (protected) и публичные (public). В Python все члены класса являются общедоступными, но существует возможность эмуляции private и protected на уровне договоренностей. Концепция отсутствия закрытых атрибутов в Python описывается фразой одного из разработчиков языка: «Мы все взрослые люди. Если программист хочет выстрелить себе в ногу - нужно предоставить ему возможность это сделать». В Python принята следующая договоренность: Protected (Non-Public) - обозначается при помощи одинарного нижнего подчеркивания _. Данный синтаксис указывает на то, что атрибут: используется для внутренней реализации класса и не предназначен для использования извне; должен быть использован/изменен только если разработчик-пользователь класса абсолютно уверен в этом. При этом атрибут с _ доступен извне, как и обычный public-атрибут класса. Private - обозначается при помощи двойного нижнего подчеркивания __. Данный синтаксис указывает на то, что атрибут: используется для внутренней реализации класса и не предназначен для использования извне; не должен быть использован/изменен разработчиком-пользователем класса. При этом атрибут с __ оказывается недоступным извне, используя технику сокрытия имен (Name Mangling). Несмотря на это, в отличие от ряда языков (например, Java) такие «закрытые» члены класса также можно изменять, но более сложным способом - их можно увидеть, используя функцию dir(). We don’t use the term “private” here, since no attribute is really private in Python (without a generally unnecessary amount of work).6 class SomeClass: def __init__(self, public_var: str, protected_var: str, private_var: str): self.public_var = public_var # public self._protected_var = protected_var # protected self.__private_var = private_var # private def _private(self): # Это внутренний метод объекта print(\"Private method\") obj = SomeClass(\"I'm Public\", \"I'm Protected\", \"I'm Private\") obj.public_var # I'm Public obj._protected_var # I'm Protected obj.__private_var # AttributeError: 'SomeClass' object has no attribute '__private_var' obj._SomeClass__private_var # I'm Private obj._private() # Private method Геттеры, сеттеры и деструкторыКроме прямого доступа к атрибутам (obj.attrName), могут быть использованы специальные методы доступа: геттеры, сеттеры и деструкторы: class SomeClass: def __init__(self, value): self._value = value def getvalue(self): # получение значения атрибута - геттер return self._value def setvalue(self, value): # установка значения атрибута - сеттер self._value = value def delvalue(self): # удаление атрибута - деструктор del self._value value = property(getvalue, setvalue, delvalue, \"Свойство value\") Такой подход очень удобен, если получение или установка значения атрибута требует сложной логики. Вместо того чтобы вручную создавать геттеры и сеттеры для каждого атрибута, можно перегрузить встроенные методы __getattr__, __setattr__ и __delattr__. Например, так можно перехватить обращение к свойствам и методам, которых в объекте не существует: class SomeClass(): attr1 = 42 def __getattr__(self, attr): return attr.upper() obj = SomeClass() obj.attr1 # 42 obj.attr2 # ATTR2 __getattribute__ перехватывает все обращения (в том числе и к существующим атрибутам). Для чего нужна инкапсуляция? Инкапсуляция упрощает процесс разработки, т. к. позволяет нам не вникать в тонкости реализации того или иного объекта. Повышается надежность программ за счет того, что при внесении изменений в один из компонентов, остальные части программы остаются ","date":"17.10.2021","objectID":"/python-oop/:4:2","series":["oop"],"tags":["python","oop-tag"],"title":"Объектно-ориентированное программирование (ООП) в Python","uri":"/python-oop/#геттеры-сеттеры-и-деструкторы"},{"categories":["python-interview"],"content":"Наследование Наследование - способ создания нового класса на основе уже существующего, при котором класс-потомок заимствует свойства и методы родительского класса, а также добавляет собственные. Класс потомок может переопределять родительские методы. При этом, обычно, дочерний класс дополняет родительский метод, добавив свой код после кода родителя (используя функцию super(), предоставляющую ссылку на родительский класс). Каждый класс также может получить информацию о своих «родителях» через метод __bases__() или isinstance(). Наследование описывается словом «является» (легковой автомобиль является автомобилем). Существуют и другой вид взаимосвязи (модель включения/делегации), когда один класс включает в себя другой класс в качестве одного из полей - ассоциация, композиция и агрегация. Ассоциация описывается словом «имеет» (автомобиль имеет двигатель). class Parent: def __init__(self, var1): self.var1 = var1 class Child(Parent): def __init__(self, var1, var2): super().__init__(self, var1) self.var2 = var2 Метод super() дает возможность наследнику обратиться к родительскому классу. Для чего нужно наследование? Принцип DRY (повторное использование кода); Классы-потомки берут общий функционал у родительского класса. Ускорение разработки нового ПО на основе переиспользования существующих открытых классов. Наследование упрощает процесс написания кода. Python реализует как стандартное одиночное наследование так и множественное. Множественное наследованиеИспользуя множественное наследования можно создавать классы-миксины (примеси), представляющие собой определенную особенность поведения. Множественное наследование часто критикуется 10 и зачастую считается признаком неверного анализа и проектирования, поэтому его использование рекомендуется в случае крайней необходимости и оправданности такого решения.7 ","date":"17.10.2021","objectID":"/python-oop/:4:3","series":["oop"],"tags":["python","oop-tag"],"title":"Объектно-ориентированное программирование (ООП) в Python","uri":"/python-oop/#наследование"},{"categories":["python-interview"],"content":"Наследование Наследование - способ создания нового класса на основе уже существующего, при котором класс-потомок заимствует свойства и методы родительского класса, а также добавляет собственные. Класс потомок может переопределять родительские методы. При этом, обычно, дочерний класс дополняет родительский метод, добавив свой код после кода родителя (используя функцию super(), предоставляющую ссылку на родительский класс). Каждый класс также может получить информацию о своих «родителях» через метод __bases__() или isinstance(). Наследование описывается словом «является» (легковой автомобиль является автомобилем). Существуют и другой вид взаимосвязи (модель включения/делегации), когда один класс включает в себя другой класс в качестве одного из полей - ассоциация, композиция и агрегация. Ассоциация описывается словом «имеет» (автомобиль имеет двигатель). class Parent: def __init__(self, var1): self.var1 = var1 class Child(Parent): def __init__(self, var1, var2): super().__init__(self, var1) self.var2 = var2 Метод super() дает возможность наследнику обратиться к родительскому классу. Для чего нужно наследование? Принцип DRY (повторное использование кода); Классы-потомки берут общий функционал у родительского класса. Ускорение разработки нового ПО на основе переиспользования существующих открытых классов. Наследование упрощает процесс написания кода. Python реализует как стандартное одиночное наследование так и множественное. Множественное наследованиеИспользуя множественное наследования можно создавать классы-миксины (примеси), представляющие собой определенную особенность поведения. Множественное наследование часто критикуется 10 и зачастую считается признаком неверного анализа и проектирования, поэтому его использование рекомендуется в случае крайней необходимости и оправданности такого решения.7 ","date":"17.10.2021","objectID":"/python-oop/:4:3","series":["oop"],"tags":["python","oop-tag"],"title":"Объектно-ориентированное программирование (ООП) в Python","uri":"/python-oop/#множественное-наследование"},{"categories":["python-interview"],"content":"ПолиморфизмТермин «полиморфизм» происходит из греческого языка и означает «нечто, что принимает несколько форм». Полиморфизм - это поддержка нескольких реализаций на основе общего интерфейса. Абстрактный метод (виртуальный метод) - это метод класса, реализация для которого отсутствует. Полиморфизм в компилируемых языках В компилируемых языках программирования полиморфизм достигается за счет создания виртуальных методов, которые в отличие от невиртуальных можно перегрузить в классе-потомке. Все методы в языке изначально виртуальные. Это значит, что дочерние классы могут их переопределять и решать одну и ту же задачу разными путями. Название метода остается прежним, а реализация изменяется и будет выбрана только во время исполнения программы. Такие классы называют полиморфными. Другая формулировка Полиморфизм позволяет одинаково обращаться с объектами, имеющими однотипный интерфейс, независимо от внутренней реализации объекта. class Bird: def move(self): print('Летает') class Penguin(Bird): def move(self): print('Ходит') crow = Bird() crow.move() # Летает emperor_penguin = Penguin() emperor_penguin.move() # Ходит Можно получить и доступ к методам класса-предка либо по прямому обращению, либо с помощью функции super(): class Parent: def __init__(self): print('Parent init') def method(self): print('Parent method') class Child(Parent): def __init__(self): Parent.__init__(self) # Прямое обращение def method(self): super(Child, self).method() # Через метод super() child = Child() # Parent init child.method() # Parent method Одинаковый интерфейс с разной реализацией могут иметь и классы, которые не связаны отношениями Родитель-Потомок. Это возможно благодаря утиной типизации. ","date":"17.10.2021","objectID":"/python-oop/:4:4","series":["oop"],"tags":["python","oop-tag"],"title":"Объектно-ориентированное программирование (ООП) в Python","uri":"/python-oop/#полиморфизм"},{"categories":["python-interview"],"content":"МетаклассыМетаклассы – это классы, инстансы которых тоже являются классами.8 Принципы ООП. Классы, объекты, поля и методы. Уровни доступа. ↩︎ Wikipedia - ООП ↩︎ Пользовательские атрибуты в Python ↩︎ What’s the difference between a Python “property” and “attribute”? ↩︎ ООП на Python: концепции, принципы и примеры реализации ↩︎ PEP 8 - Designing for Inheritance ↩︎ Объектно-ориентированное программирование и классы ↩︎ Метаклассы в Python: что это такое и с чем его едят ↩︎ ","date":"17.10.2021","objectID":"/python-oop/:5:0","series":["oop"],"tags":["python","oop-tag"],"title":"Объектно-ориентированное программирование (ООП) в Python","uri":"/python-oop/#метаклассы"},{"categories":["python-interview"],"content":"В Python анонимная функция — это функция, определенная без имени. Анонимные функции определяются с помощью ключевого слова lambda и называются лямбда-функциями.","date":"14.09.2021","objectID":"/python-lambda/","series":null,"tags":["python","functional-programming"],"title":"lambda функции в Python 3 - определение анонимной фукции, примеры","uri":"/python-lambda/"},{"categories":["python-interview"],"content":"Список вопросов к Python собеседованию ","date":"14.09.2021","objectID":"/python-lambda/:0:0","series":null,"tags":["python","functional-programming"],"title":"lambda функции в Python 3 - определение анонимной фукции, примеры","uri":"/python-lambda/#"},{"categories":["python-interview"],"content":"Что такое анонимная функцияВ буквальном смысле, анонимная функция — это функция без имени. В Python анонимная функция создается с помощью ключевого слова lambda.1 lambda принимает произвольное количество аргументов, за которыми следует одно выражение. Оно становится телом функции, а его значение будет тем, что вернет лямбда-функция. lambda \u003cargs\u003e: \u003cexpression\u003e Взаимозаменяемые термины Следующие термины могут использоваться взаимозаменяемо в зависимости от языка программирования: Анонимные функции Лямбда-функции Лямбда-выражения Лямбда-абстракции Лямбда-форма Функциональные литералы ","date":"14.09.2021","objectID":"/python-lambda/:1:0","series":null,"tags":["python","functional-programming"],"title":"lambda функции в Python 3 - определение анонимной фукции, примеры","uri":"/python-lambda/#что-такое-анонимная-функция"},{"categories":["python-interview"],"content":"Аргументы lambda-функциlambda поддерживают все способы передачи аргументов: Позиционные аргументы; Именованные аргументы; Переменный список неименованных аргументов (*args); Переменный список именованных аргументов (**kwargs). (lambda x, y, z: x + y + z)(1, 2, 3) (lambda x, y, z=3: x + y + z)(1, 2) (lambda x, y, z=3: x + y + z)(1, y=2) (lambda *args: sum(args))(1,2,3) (lambda **kwargs: sum(kwargs.values()))(one=1, two=2, three=3) (lambda x, *, y=0, z=0: x + y + z)(1, y=2, z=3) ","date":"14.09.2021","objectID":"/python-lambda/:2:0","series":null,"tags":["python","functional-programming"],"title":"lambda функции в Python 3 - определение анонимной фукции, примеры","uri":"/python-lambda/#аргументы-lambda-функци"},{"categories":["python-interview"],"content":"Отличия lambda от обычной функцииЛямбда имеет синтаксические отличия от обычной функции: Может содержать только выражение и не может включать операторы в свое тело; Записывается в одну строку; Не поддерживает аннотации типов; Может быть немедленно вызвана (IIFE); Не может содержать утверждения (return, pass, assert или raise вызовут исключение SyntaxError). Декоратор может быть применен к лямбде. Хотя невозможно декорировать лямбду с помощью синтаксиса @decorator, декоратор — это просто функция, поэтому он может вызывать функцию lambda: # Defining a decorator def trace(f): def wrap(*args, **kwargs): print(f\"[TRACE] func: {f.__name__}, args: {args}, kwargs: {kwargs}\") return f(*args, **kwargs) return wrap # Applying decorator to a lambda print((trace(lambda x: x ** 2))(3)) # [TRACE] func: \u003clambda\u003e, args: (3,), kwargs: {} ","date":"14.09.2021","objectID":"/python-lambda/:3:0","series":null,"tags":["python","functional-programming"],"title":"lambda функции в Python 3 - определение анонимной фукции, примеры","uri":"/python-lambda/#отличия-lambda-от-обычной-функции"},{"categories":["python-interview"],"content":"Особенности lambda-функции Часто используются с функциями более высокого порядка, которые принимают одну или несколько функций в качестве аргументов или возвращают одну или несколько функций. Может быть функцией более высокого порядка, принимая функцию (нормальную или лямбда-функцию) в качестве аргумента. Регулярно используется со встроенными функциями map() и filter(), а также functools.reduce(), представленными в модуле functools. Лямбда-функций следует избегать, когда код: не следует руководству по стилю Python (PEP 8); выглядит громоздким и трудно читаемым. Всегда используйте оператор def вместо оператора присваивания, который связывает лямбду непосредственно с идентификатором. (PEP 8)2 ","date":"14.09.2021","objectID":"/python-lambda/:4:0","series":null,"tags":["python","functional-programming"],"title":"lambda функции в Python 3 - определение анонимной фукции, примеры","uri":"/python-lambda/#особенности-lambda-функции"},{"categories":["python-interview"],"content":"Примеры # Сортировка списка a = [(1, 2), (4, 1), (9, 10), (13, -3)] a.sort(key=lambda x: x[1]) # Параллельная сортировка списков data = list(zip(list1, list2)) data.sort() # map list(map(lambda x: x.upper(), ['cat', 'dog', 'cow'])) # ['CAT', 'DOG', 'COW'] # filter list(filter(lambda x: 'o' in x, ['cat', 'dog', 'cow'])) # ['dog', 'cow'] # reduce from functools import reduce reduce(lambda acc, x: f'{acc}| {x}', ['cat', 'dog', 'cow']) # 'cat | dog | cow' How to Use Python Lambda Functions ↩︎ PEP8 ↩︎ ","date":"14.09.2021","objectID":"/python-lambda/:5:0","series":null,"tags":["python","functional-programming"],"title":"lambda функции в Python 3 - определение анонимной фукции, примеры","uri":"/python-lambda/#примеры"},{"categories":["python-interview"],"content":"К основным встроенным (built-in) типам относятся: NoneType (None), Numeric Type (int, float, complex), Boolean (True и False), Sequence Type (str, list, tuple, range), а так же set, frozenset и dict.","date":"06.09.2021","objectID":"/python-built-in-data-types/","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/"},{"categories":["python-interview"],"content":"Говоря о типах данных, стоит упомянуть, что Python - язык с неявной сильной динамической типизацией (подробнее о видах типизации в языках программирования). Встроенные и не встроенные типы В Python типы данных можно разделить на встроенные в интерпретатор (built-in) и не встроенные, которые можно использовать при импортировании соответствующих модулей. Int - больше, чем просто int Стандартная реализация Python написана на C (CPython). Это означает, что каждый объект Python — это просто искусно замаскированная структура C, которая содержит не только его значение, но и другую информацию. Каждое значение в Python имеет тип данных. Поскольку в Python все является объектом, типы данных на самом деле являются классами, а переменные являются экземплярами (объектами) этих классов. На аппаратном уровне переменная — это ссылка на место в памяти. ","date":"06.09.2021","objectID":"/python-built-in-data-types/:0:0","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#"},{"categories":["python-interview"],"content":"Числовые типы (Numeric Types)Существует три базовых числовых типа: int, float, complex. ","date":"06.09.2021","objectID":"/python-built-in-data-types/:1:0","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#числовые-типы-numeric-types"},{"categories":["python-interview"],"content":"Integerint - целые числа. Отрицательные и положительные числа любой длины (ограничением является только количество памяти). # integer a = 1000 type(a) # \u003cclass 'int'\u003e ","date":"06.09.2021","objectID":"/python-built-in-data-types/:1:1","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#integer"},{"categories":["python-interview"],"content":"Floatfloat - числа с плавающей точкой, отрицательные или положительные, содержащие десятичную точку или символ экспоненты e (показатель возведения в степень 10: 35e3, 12E4). Точность до 15 знаков после запятой. float может принимать значения nan и inf/-inf. # float b = 12.5634423 # 35e3, 12E4, -87.7e100 type(b) # \u003cclass 'float'\u003e # Not A Number x = float(\"nan\") print(x) # nan type(x) # \u003cclass 'float'\u003e # Аналогично с бесконечностью y = float(\"inf\") # inf z = float(\"-inf\") # -inf ","date":"06.09.2021","objectID":"/python-built-in-data-types/:1:2","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#float"},{"categories":["python-interview"],"content":"Complexcomplex - комплексные числа (x+yj, где x - действительная часть, y - мнимая часть, а j - мнимая единица). # complex c = 3+5j # 5j, -5j type(c) # \u003cclass 'complex'\u003e print(c.real) # 3.0 print(c.imag) # 5.0 ","date":"06.09.2021","objectID":"/python-built-in-data-types/:1:3","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#complex"},{"categories":["python-interview"],"content":"Longlong - использовался для представления больших целых чисел. Кроме того, boolean является подтипом int. ","date":"06.09.2021","objectID":"/python-built-in-data-types/:1:4","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#long"},{"categories":["python-interview"],"content":"Логический тип (Boolean Type)В булевом типе данных есть только два типа значений: True и False (встроенные константы чувствительные к регистру). type(True) # \u003cclass 'bool'\u003e type(False) # \u003cclass 'bool'\u003e Функция приведения типа bool() позволяет оценить любое значение и вернуть True или False. В Python истинными и ложными значениями считаются не только True и False: Истинное значение: любое ненулевое число любая непустая строка любой непустой объект Ложное значение: 0 None пустая строка пустой объект ","date":"06.09.2021","objectID":"/python-built-in-data-types/:2:0","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#логический-тип-boolean-type"},{"categories":["python-interview"],"content":"Последовательности (Sequence Type)К ним относятся основные: str (строка) list (список) tuple (кортеж) range (диапазон) bytes (байтовая строка) bytearray (байтовый массив) memoryview (специальные объекты для доступа к внутренним данным объекта через protocol buffer). Как и все типы данных, последовательности делятся на изменяемые (mutable) и неизменяемые (immutable). Операции, поддерживаемые большинством последовательностей (изменяемых и неизменяемых): x in s # (x not in s) - проверка принадлежности s + t # конкатенация s * n # s[i] # получение по индексу s[i:j:k] # срезы (старт:стоп:шаг) len(s) # длина s min(s) # минимальный элемент s max(s) # максимальный элемент s s.index(x[, i[, j]]) # индекс первого появления x (at or after index i and before index j) s.count(x) # общее кол-во вхождений x в s hash() - единственная операция, реализованная в неизменяемых типах последовательностей и отсутствующая в изменяемых. Это позволяет использовать неизменяемые последовательности, такие как экземпляры кортежей, в качестве ключей словаря и хранить их в set и frozenset. Операции над изменяемыми последовательностями: s[i] = x s[i:j] = t del s[i:j] s[i:j:k] = t del s[i:j:k] s.append(x) s.clear() s.copy() s.extend(t) # or s += t s *= n s.insert(i, x) s.pop() # or s.pop(i) s.remove(x) s.reverse() ","date":"06.09.2021","objectID":"/python-built-in-data-types/:3:0","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#последовательности-sequence-type"},{"categories":["python-interview"],"content":"Строка (string)Cтрока (str) - это неизменяемая упорядоченная последовательность символов Юникода. В питоне нет символьного типа данных char, символ представляет собой строку одинарной длины. Строку можно создать различными способами: # Одинарные кавычки first_way = 'This is a string' # Двойные кавычки second_way = \"This is a string\" # Тройные кавычки (одинарные или двойные) third_way_single = '''This is a string''' third_way_double = \"\"\"This is a string\"\"\" Для строк доступны общие операции c последовательностями, а так же дополнительные методы встроенного класса str(). ","date":"06.09.2021","objectID":"/python-built-in-data-types/:3:1","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#строка-string"},{"categories":["python-interview"],"content":"Список (list)Список (list) — это изменяемая упорядоченная последовательность, обычно используемая для хранения коллекций однородных элементов. Поскольку списки индексируются, то могут содержать элементы с одинаковым значением. list1 = [10, 20, 30, 77] list2 = ['one', 'dog', 'seven'] list3 = [1, 20, 4.0, 'word'] ","date":"06.09.2021","objectID":"/python-built-in-data-types/:3:2","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#список-list"},{"categories":["python-interview"],"content":"Кортеж (tuple)Кортеж (tuple) — это неизменяемая упорядоченная последовательность, обычно используемая для хранения коллекций разнородных элементов. Также используются в случаях, когда требуется неизменяемая последовательность однородных данных (например, использование в экземпляре set или dict). Кортежи, как правило, быстрее, чем списки в Python. tuple1 = (1, 2, 5, 6) tuple2 = tuple('a', 'b', 'c') tuple3 = () # пустой кортеж tuple4 = 23, 13, 100 tuple5 = (\"London\", \"Tokyo\", \"Korea\", 1986, 1640, 1948) ","date":"06.09.2021","objectID":"/python-built-in-data-types/:3:3","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#кортеж-tuple"},{"categories":["python-interview"],"content":"Диапазон (range)Тип range представляет собой упорядоченную неизменяемую последовательность чисел и обычно используется для выполнения определенного количества раз циклов for. Для диапазонов доступны общие операции с последовательностями, кроме конкатенации и повторения. Проверка диапазонов range на равенство с == и != сравнивает их как последовательности. Атрибуты start, stop и step. ","date":"06.09.2021","objectID":"/python-built-in-data-types/:3:4","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#диапазон-range"},{"categories":["python-interview"],"content":"Байтовые строки (bytes)Тип данных bytes - это упорядоченная неизменяемая последовательность отдельных байтов. Синтаксис для байтовых строк в основном такой же, как и для обычных строк, за исключением того, что добавляется префикс b. ","date":"06.09.2021","objectID":"/python-built-in-data-types/:3:5","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#байтовые-строки-bytes"},{"categories":["python-interview"],"content":"Байтовый массив (bytearray)Bytearray объекты являются упорядоченным неизменяемым аналогом bytes. ","date":"06.09.2021","objectID":"/python-built-in-data-types/:3:6","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#байтовый-массив-bytearray"},{"categories":["python-interview"],"content":"Буфер обмена (memoryview)Объекты memoryview позволяют коду Python получать доступ к внутренним данным объекта, который поддерживает буферный протокол, без копирования. ","date":"06.09.2021","objectID":"/python-built-in-data-types/:3:7","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#буфер-обмена-memoryview"},{"categories":["python-interview"],"content":"Множества (Set Types)Множество - это неупорядоченный набор различных хешируемых объектов. Обычно множества используются для проверки вхождения элемента, удаления дубликатов из последовательности и вычисления математических операций, таких как пересечение, объединение, разность и т. д. Будучи неупорядоченной коллекцией, множества не сохраняют положение элемента или порядок вставки. Соответственно, не поддерживают индексы, срезы или другое поведение, подобное упорядоченной последовательности. Существует два встроенных типа множеств: set и frozenset. ","date":"06.09.2021","objectID":"/python-built-in-data-types/:4:0","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#множества-set-types"},{"categories":["python-interview"],"content":"Множество (set)Тип set является изменяемым множеством, содержимое может быть изменено с помощью таких методов, как add() и remove(), так же поддерживает операции доступные frozenset. Поскольку тип set является изменяемым, он не имеет хеш-значения и не может использоваться ни как ключ словаря, ни как элемент другого множества. # Use the type constructor set2 = set('a', 'b', 'c') # Use a comma-separated list of elements within braces set1 = {1, 2, 5, 6} # Use a set comprehension {c for c in 'abracadabra' if c not in 'abc'} ","date":"06.09.2021","objectID":"/python-built-in-data-types/:4:1","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#множество-set"},{"categories":["python-interview"],"content":"Неизменяемое множество (frozenset)Тип frozenset является неизменяемым и хешируемым множеством, его содержимое не может быть изменено после его создания, поэтому он может использоваться как ключ словаря или как элемент другого множества. # Use the type constructor s = frozenset({'a', 'b', 'c'}) ","date":"06.09.2021","objectID":"/python-built-in-data-types/:4:2","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#неизменяемое-множество-frozenset"},{"categories":["python-interview"],"content":"Словарь (dict)Словарь (dict) — это упорядоченная, изменяемая коллекция пар ключ: значение, в которой не допускается дублирование ключей. Ключи словаря - это произвольные, неизменяемые (хешируемые) значения. Значения элементов словаря могут иметь любой тип данных. Словари стали упорядоченными. Словари и объекты представления словаря dict.keys(), dict.values(), dict.items() теперь обратимы. Словарь может быть создан несколькими способами: # Используя разделенный запятыми список пар ключ: значение в фигурных скобках dict1 = {'Moscow': 1023, 'SPB': 2048} # Используя dict comprehension dict2 = {x: x ** 2 for x in range(10)} # Используя конструктор типа dict3 = dict([('foo', 100), ('bar', 200)]) dict4 = dict(foo=100, bar=200) В других языках программирования тип данных подобный словарю может называться ассоциативный массив, хеш или хеш-таблица. ","date":"06.09.2021","objectID":"/python-built-in-data-types/:5:0","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#словарь-dict"},{"categories":["python-interview"],"content":"Изменяемые и неизменяемые типы данныхВ Python существуют изменяемые и неизменяемые типы. Неизменяемые: int, float, complex, bool, tuple, str, frozenset. Изменяемые: list, set, dict. При создании переменной, вначале создается объект, который имеет уникальный идентификатор, тип и значение, после этого переменная может ссылаться на созданный объект. Неизменяемость типа данных означает, что созданный объект больше не изменяется. Например, если мы объявим переменную k = 15, то будет создан объект со значением 15, типа int и идентификатором, который можно узнать с помощью функции id(). k = 15 id(k) # 1672501744 type(k) # \u003cclass 'int'\u003e Объект с id = 1672501744 будет иметь значение 15 и изменить его уже нельзя. Если тип данных изменяемый, то можно менять значение объекта. Например, создадим список [1, 2], а потом заменим второй элемент на 3. a = [1, 2] id(a) # 47997336 a[1] = 3 print(a) # [1, 3] id(a) # 47997336 Источники: Python documentation - Built-in Types Understand How Much Memory Your Python Objects Use Understanding Data Types in Python ","date":"06.09.2021","objectID":"/python-built-in-data-types/:6:0","series":null,"tags":["python","data-types"],"title":"Встроенные типы данных в Python 3","uri":"/python-built-in-data-types/#изменяемые-и-неизменяемые-типы-данных"},{"categories":["python-interview"],"content":"Интроспекция (introspection) — это способность объекта во время выполнения получить тип, доступные атрибуты и методы, а также другую информацию, необходимую для выполнения дополнительных операций с объектом.","date":"23.08.2021","objectID":"/introspection-in-python/","series":null,"tags":["python"],"title":"Интроспекция в Python","uri":"/introspection-in-python/"},{"categories":["python-interview"],"content":"Список вопросов к Python собеседованию ","date":"23.08.2021","objectID":"/introspection-in-python/:0:0","series":null,"tags":["python"],"title":"Интроспекция в Python","uri":"/introspection-in-python/#"},{"categories":["python-interview"],"content":"Определение понятия интроспекцииИнтроспекция (introspection) в контексте объектно-ориентированных языков программирования — это возможность запросить тип и структуру объекта во время выполнения программы. Среди языков, поддерживающих интроспекцию — C++ (с RTTI), Go, Java, Kotlin, JavaScript, Perl, Ruby, Smalltalk, PHP и Python. В PHP и Python интроспекция интегрирована в сам язык. В Python интроспекция может быть функционально реализована с помощью: встроенных методов dir(), type(), isinstance(), hasattr(), id(); встроенного модуля inspect; идти непосредственно от имени объекта с помощью встроенных аттрибутов __class__ и __dict__. Пользоваться интроспекцией в Python особенно удобно, благодаря парадигме, что “всё является объектом”. Любая сущность, являясь объектом, имеет метаданные (данные об объекте), называемые аттрибутами, и связаные с этой сущностью функциональности, называемые методами. В Python новый класс по-умолчанию является сам по себе объектом метакласса type. Наиболее часто используемые функции интроспекции в Python: ","date":"23.08.2021","objectID":"/introspection-in-python/:1:0","series":null,"tags":["python"],"title":"Интроспекция в Python","uri":"/introspection-in-python/#определение-понятия-интроспекции"},{"categories":["python-interview"],"content":"dir() Предоставляет список атрибутов и методов, доступных для указанного объекта, который может быть объявленной переменной или функцией. Возвращаемое значение это отсортированный в алфавитном порядке список. При вызове функции dir() без аргумента она возвращает имена, доступные в локальной области видимости. a = [1, 2, 3] dir(a) # ['__add__', '__class__', '__contains__', ... , 'sort'] ","date":"23.08.2021","objectID":"/introspection-in-python/:2:0","series":null,"tags":["python"],"title":"Интроспекция в Python","uri":"/introspection-in-python/#dir"},{"categories":["python-interview"],"content":"type()Возвращает тип объекта, который может быть примитивным типом данных, объектом, классом или модулем. Можно напрямую сравнить возвращаемое значение с типом, который мы хотим проверить, используя == или is. type(8.7) # \u003cclass 'float'\u003e type(\"test\") == int # False type((7, 5,)) is tuple # True ","date":"23.08.2021","objectID":"/introspection-in-python/:3:0","series":null,"tags":["python"],"title":"Интроспекция в Python","uri":"/introspection-in-python/#type"},{"categories":["python-interview"],"content":"isinstance()Позволяет определить, является ли определенный объект экземпляром указанного класса. isinstance() может принимать кортеж в качестве второго аргумента, isinstance([1,2], list) # True isinstance([1,2], tuple) # False isinstance(1, (int, float, tuple)) # True type() vs isinstance() При использовании type() проводится сравнение один к одному. По сути, мы сравниваем тип объекта с типом, который мы указали, чтобы проверить, совпадают ли они. isinstance() является более гибкой функцией. Фактически она определяет, является ли объект экземпляром указанного класса (классов) или его подкласса. Для isinstance() экземпляр подкласса также является экземпляром базового класса. Другими словами, она сравнивает объект со списком потенциально релевантных классов, что является своего рода сравнением один к нескольким. ","date":"23.08.2021","objectID":"/introspection-in-python/:4:0","series":null,"tags":["python"],"title":"Интроспекция в Python","uri":"/introspection-in-python/#isinstance"},{"categories":["python-interview"],"content":"hasattr()Функция hasattr() проверяет существование атрибута с именем name в объекте object. Возвращает True, если атрибут существует, иначе False. Реализация функция hasattr() основывается на вызове функции getattr() с последующей проверкой на предмет брошенного ей исключения AttributeError. x = ('one', 'two', 'boom') hasattr(x, 'some_attr') # False hasattr(x, 'count') # True ","date":"23.08.2021","objectID":"/introspection-in-python/:5:0","series":null,"tags":["python"],"title":"Интроспекция в Python","uri":"/introspection-in-python/#hasattr"},{"categories":["python-interview"],"content":"id()Функция id() возвращает уникальный идентификатор для указанного объекта. x = ('one', 'two', 'boom') id(x) # 140575915669688 В CPython идентификатор объекта — это адрес объекта в памяти. Все объекты в Python имеют свой уникальный идентификатор. Идентификатор присваивается объекту при его создании. Идентификатор является адресом памяти объекта и будет отличаться при каждом запуске программы. Объекты могут иметь одинаковый идентификатор, если периоды их существования не пересекаются. Некоторые объекты могут иметь один и тот же идентификатор, например: мелкие целые от -5 до 256, True и False. ","date":"23.08.2021","objectID":"/introspection-in-python/:6:0","series":null,"tags":["python"],"title":"Интроспекция в Python","uri":"/introspection-in-python/#id"},{"categories":["python-interview"],"content":"Модуль inspectМодуль inspect также предоставляет несколько полезных функций для получения информации об объектах. Например, можно проверить элементы объекта: import inspect print(inspect.getmembers(str)) # Output: [('__add__', \u003cslot wrapper '__add__' of ... ... Источники: Wiki Интроспекция в Python ","date":"23.08.2021","objectID":"/introspection-in-python/:7:0","series":null,"tags":["python"],"title":"Интроспекция в Python","uri":"/introspection-in-python/#модуль-inspect"},{"categories":["python-interview"],"content":"Понятие программной инженерии и процесса разработки ПО","date":"19.07.2021","objectID":"/software-engineering-and-development-process/","series":null,"tags":["base"],"title":"Понятие программной инженерии и процесса разработки ПО","uri":"/software-engineering-and-development-process/"},{"categories":["python-interview"],"content":"Список вопросов к Python собеседованию ","date":"19.07.2021","objectID":"/software-engineering-and-development-process/:0:0","series":null,"tags":["base"],"title":"Понятие программной инженерии и процесса разработки ПО","uri":"/software-engineering-and-development-process/#"},{"categories":["python-interview"],"content":"Кризис программного обеспечения В 1968 году на конференции НАТО «Инженерия программного обеспечения» Фридрихом Л. Бауэром был введен термин «кризис программного обеспечения». Проявления кризиса: Стоимость проектов превышает бюджет. В проектах превышаются сроки выполнения. Программное обеспечение было слишком неэффективным. Программное обеспечение имело слишком низкое качество. Программное обеспечение зачастую не отвечало необходимым требованиям. Трудности с поддержкой кода. ПО было непригодным для распространения. ","date":"19.07.2021","objectID":"/software-engineering-and-development-process/:1:0","series":null,"tags":["base"],"title":"Понятие программной инженерии и процесса разработки ПО","uri":"/software-engineering-and-development-process/#кризис-программного-обеспечения"},{"categories":["python-interview"],"content":"Программная инженерияНа той же конференции был введен и термин «программная инженерия». С тех пор это переросло в профессию инженера-программиста (англ. software engineer) и область исследований, посвящённых созданию программного обеспечения, более качественного, доступного, лучше поддерживаемого и быстрее разрабатываемого. Программная инженерия (англ. software engineering) - виды деятельности, выполняемые в процессе промышленного программирования и необходимые для успешного выполнения заказов. В сферу программной инженерии попадают все вопросы и темы, связанные с организацией и улучшением процесса разработки ПО, управлением коллектива разработчиков, разработкой и внедрением программных средств поддержки жизненного цикла разработки ПО. ","date":"19.07.2021","objectID":"/software-engineering-and-development-process/:2:0","series":null,"tags":["base"],"title":"Понятие программной инженерии и процесса разработки ПО","uri":"/software-engineering-and-development-process/#программная-инженерия"},{"categories":["python-interview"],"content":"Процесс разработки ПОПроцесс разработки программного обеспечения (англ. software development process) — процесс, посредством которого потребности пользователей преобразуются в программный продукт. Процесс разработки программного обеспечения является составной частью программной инженерии. Процесс разработки состоит из множества подпроцессов: Анализ требований → Спецификация программного обеспечения Проектирование программного обеспечения Программирование Тестирование программного обеспечения Системная интеграция (System integration) Внедрение программного обеспечения Сопровождение программного обеспечения Модели процесса: Водопадная (каскадная, последовательная) модель (англ. waterfall model) Итерационная модель Спиральная модель «Серебряной пули нет» На сегодняшний день не существует универсального процесса разработки ПО - набора методик, правил и предписаний, подходящих для ПО любого вида, для любых компаний, для команд любой национальности. Источники: Подробная статья ","date":"19.07.2021","objectID":"/software-engineering-and-development-process/:3:0","series":null,"tags":["base"],"title":"Понятие программной инженерии и процесса разработки ПО","uri":"/software-engineering-and-development-process/#процесс-разработки-по"},{"categories":null,"content":"Основные шаги по настройке VPS с Ubuntu 20.04 для деплоя проекта. Установка Docker и Docker Compose, настройка UFW.","date":"07.06.2021","objectID":"/ubuntu-setup-for-python-stack/","series":null,"tags":["linux"],"title":"Настройка Ubuntu 20.04 для развертывания проекта в Docker","uri":"/ubuntu-setup-for-python-stack/"},{"categories":null,"content":"У нас имеется VPS с Ubuntu 20.04, нужно настроить его для развертывания проекта. ","date":"07.06.2021","objectID":"/ubuntu-setup-for-python-stack/:0:0","series":null,"tags":["linux"],"title":"Настройка Ubuntu 20.04 для развертывания проекта в Docker","uri":"/ubuntu-setup-for-python-stack/#"},{"categories":null,"content":"Первые шаги # Обновим apt update \u0026\u0026 sudo apt upgrade -y # Создаем нового юзера adduser www \u0026\u0026 usermod -aG sudo www # password for sudo - off sudo visudo # %sudo ALL=(ALL:ALL) NOPASSWD:ALL Выходим с сервера и копируем ssh-key ssh-copy-id www@ip Заходим под пользователем www и продолжаем настройку. Отключим возможность заходить под root, а так же возможность логиниться по паролю:1 sudo vim /etc/ssh/sshd_config # Ищем и исправляем следующие строки: # AllowUsers www # PermitRootLogin no # PasswordAuthentication no sudo systemctl restart sshd ","date":"07.06.2021","objectID":"/ubuntu-setup-for-python-stack/:1:0","series":null,"tags":["linux"],"title":"Настройка Ubuntu 20.04 для развертывания проекта в Docker","uri":"/ubuntu-setup-for-python-stack/#первые-шаги"},{"categories":null,"content":"Настройка UFWНастроим фаервол UFW:2 sudo ufw allow OpenSSH \u0026\u0026 sudo ufw allow http \u0026\u0026 sudo ufw allow https sudo ufw enable sudo ufw status ","date":"07.06.2021","objectID":"/ubuntu-setup-for-python-stack/:2:0","series":null,"tags":["linux"],"title":"Настройка Ubuntu 20.04 для развертывания проекта в Docker","uri":"/ubuntu-setup-for-python-stack/#настройка-ufw"},{"categories":null,"content":"zsh + Oh-My-zshУстановим zsh и Oh-My-zsh и настроим тему powerlevel10k: sudo apt install zsh -y # reconnect sh -c \"$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\" git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/themes/powerlevel10k vim ~/.zshrc # ZSH_THEME=\"powerlevel10k/powerlevel10k\" # alias cls=\"clear\" source ~/.zshrc ","date":"07.06.2021","objectID":"/ubuntu-setup-for-python-stack/:3:0","series":null,"tags":["linux"],"title":"Настройка Ubuntu 20.04 для развертывания проекта в Docker","uri":"/ubuntu-setup-for-python-stack/#zsh--oh-my-zsh"},{"categories":null,"content":"Установка Docker и Docker ComposeСледующий шаг - установка Docker и Docker Compose3 sudo apt install apt-transport-https ca-certificates curl software-properties-common -y curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - sudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu focal stable\" sudo apt update apt-cache policy docker-ce sudo apt install docker-ce -y sudo systemctl status docker sudo usermod -aG docker ${USER} # Релогин id -nG Установка Docker Compose4 Свежий релиз Docker Compose sudo curl -L \"https://github.com/docker/compose/releases/download/v2.2.3/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose docker-compose --version ","date":"07.06.2021","objectID":"/ubuntu-setup-for-python-stack/:4:0","series":null,"tags":["linux"],"title":"Настройка Ubuntu 20.04 для развертывания проекта в Docker","uri":"/ubuntu-setup-for-python-stack/#установка-docker-и-docker-compose"},{"categories":null,"content":"Полезные утилиты # Free disk space df -h -t ext4 # process top # free memory free -h Настройка ключей SSH в Ubuntu 20.04 ↩︎ UFW Essentials: Common Firewall Rules and Commands ↩︎ Установка и использование Docker в Ubuntu 20.04 ↩︎ Установка и использование Docker Compose в Ubuntu 20.04 ↩︎ ","date":"07.06.2021","objectID":"/ubuntu-setup-for-python-stack/:5:0","series":null,"tags":["linux"],"title":"Настройка Ubuntu 20.04 для развертывания проекта в Docker","uri":"/ubuntu-setup-for-python-stack/#полезные-утилиты"},{"categories":["notes"],"content":"PostgresSQL CLI command cheatsheet","date":"21.05.2021","objectID":"/postgres-cli-commands/","series":null,"tags":["postgres","db"],"title":"PostgresSQL CLI command cheatsheet","uri":"/postgres-cli-commands/"},{"categories":["notes"],"content":" # To start manually: pg_ctl -D /usr/local/var/postgres start # To stop manually: pg_ctl -D /usr/local/var/postgres stop #To start PostgreSQL server now and relaunch at login: brew services start postgresql #And stop PostgreSQL: brew services stop postgresql Connect to PostgreSQL database # connects to a database under a specific user psql -d database -U user -W # connect to a database that resides on another host psql -h host -d database -U user -W # use SSL mode for the connection psql -U user -h host \"dbname=db sslmode=require\" # Dump data with pg_dump pg_dump -h \u003chost\u003e -U \u003cuser\u003e \u003cdb_name\u003e \u003e /path/to/filename.tar # .dump # Restore data -c for recreate pg_restore -c -U \u003cuser\u003e -d \u003cdb_name\u003e -v \"/path/to/filename.tar\" -W # -c to clean the database # -U to force a user # -d to select the database # -v verbose mode, don't know why # -W to force asking for the password to the user (postgres) # В локальную базу с помощью psql psql \u003cdb_name\u003e \u003c /path/to/file/filename.tar # Из контейнера docker exec -t your-db-container pg_dumpall -c -U postgres \u003e dump_`date +%d-%m-%Y\"_\"%H_%M_%S`.sql #To save some space on disk you might want to pipe the dump to gzip: docker exec -t your-db-container pg_dumpall -c -U postgres | gzip \u003e /var/data/postgres/backups/dump_date +%d-%m-%Y\"_\"%H_%M_%S.gz # В контейнер cat /path/to/filename.tar | docker exec -i \u003ccontainer_name\u003e psql -U \u003cuser\u003e # to restore a compressed sql: gunzip \u003c your_dump.sql.gz | docker exec -i your-db-container psql -U your-db-user -d your-db-name # copy dump into container docker cp local/path/to/db.dump CONTAINER_ID:/db.dump # shell into container docker exec -it CONTAINER_ID bash # restore it from within pg_restore -U postgres -d DB_NAME --no-owner -1 /db.dump Создание юзера CREATEROLEpostgresWITHLOGINPASSWORD'postgres'; Права на создание БД ALTERROLEpostgresCREATEDB; Создание БД CREATEDATABASEdb_name; Экспорт таблицы (столбцов) в .csv COPYtable_name(col1,col2,col3)TO'path/file.csv'DELIMITER','CSVHEADER; Экспорт результатов запроса в .csv файл \\copy(SELECT*FROMorganisationwhereidin(20,34))to'/full/path/filename.csv'withcsvheader \\du – список пользователей \\dp (или \\z) – список таблиц, представлений, последовательностей, прав доступа к ним \\di – индексы \\ds – последовательности \\dt – список таблиц \\dt+ — список всех таблиц с описанием \\dt s — список всех таблиц, содержащих s в имени \\dv – представления \\dS – системные таблицы \\d+ – описание таблицы \\o – пересылка результатов запроса в файл \\l – список баз данных \\i – читать входящие данные из файла \\e – открывает текущее содержимое буфера запроса в редакторе (если иное не указано в окружении переменной EDITOR, то будет использоваться по умолчанию vi) \\d “table_name” – описание таблицы \\i запуск команды из внешнего файла, например \\i /my/directory/my.sql \\pset – команда настройки параметров форматирования \\echo – выводит сообщение \\set – устанавливает значение переменной среды. Без параметров выводит список текущих переменных (\\unset – удаляет) ? – справочник psql \\help – справочник SQL \\q (или Ctrl+D) – выход из программы \\timing - Turn on query execution time Полезное: [Backup/Restore a dockerized PostgreSQL database](https://github.com/anuraghazra/github-readme-stats) Установка и настройка PostgreSQL в Docker How to install multiple Postgresql versions on macOS? Running multiple PostgreSQL versions on MacOS ","date":"21.05.2021","objectID":"/postgres-cli-commands/:0:0","series":null,"tags":["postgres","db"],"title":"PostgresSQL CLI command cheatsheet","uri":"/postgres-cli-commands/#"},{"categories":["notes"],"content":"Just badges","date":"18.04.2021","objectID":"/github-badges/","series":null,"tags":["github"],"title":"GitHub badges","uri":"/github-badges/"},{"categories":["notes"],"content":"Подробнее на странице автора1 ","date":"18.04.2021","objectID":"/github-badges/:0:0","series":null,"tags":["github"],"title":"GitHub badges","uri":"/github-badges/#"},{"categories":["notes"],"content":"GitHub stats \u003cimg src=\"https://github-readme-stats.vercel.app/api?username=baikov\u0026count_private=true\u0026hide_title=true\u0026hide=issues,contribs\u0026show_icons=true\u0026theme=calm\u0026text_color=#fff\u0026icon_color=#e31e25\u0026border_color=#e31e25\"\u003e ","date":"18.04.2021","objectID":"/github-badges/:1:0","series":null,"tags":["github"],"title":"GitHub badges","uri":"/github-badges/#github-stats"},{"categories":["notes"],"content":"Repo info \u003ca href=\"https://github.com/baikov/allflags\"\u003e \u003cimg src=\"https://github-readme-stats.vercel.app/api/pin/?username=baikov\u0026repo=traefik-prometheus\u0026theme=calm\u0026border_color=#e31e25\" /\u003e \u003c/a\u003e \u003ca href=\"https://github.com/baikov/allflags\"\u003e \u003cimg src=\"https://github-readme-stats.vercel.app/api/pin/?username=baikov\u0026repo=allflags\u0026border_color=#e31e25\u0026text_color=#ffffff\u0026title_color=#ffffff\" /\u003e \u003c/a\u003e ","date":"18.04.2021","objectID":"/github-badges/:2:0","series":null,"tags":["github"],"title":"GitHub badges","uri":"/github-badges/#repo-info"},{"categories":["notes"],"content":"Github top langs \u003cimg id=\"elem\" src=\"https://github-readme-stats.vercel.app/api/top-langs/?username=baikov\" /\u003e ","date":"18.04.2021","objectID":"/github-badges/:3:0","series":null,"tags":["github"],"title":"GitHub badges","uri":"/github-badges/#github-top-langs"},{"categories":["notes"],"content":"GitHub activity \u003cimg id=\"elem\" src=\"https://ghchart.rshah.org/e31e25/baikov\" /\u003e GitHub Readme Stats ↩︎ ","date":"18.04.2021","objectID":"/github-badges/:4:0","series":null,"tags":["github"],"title":"GitHub badges","uri":"/github-badges/#github-activity"},{"categories":["notes"],"content":"Django Cookiecutter commands","date":"15.03.2021","objectID":"/cookiecutter-commands/","series":null,"tags":["django"],"title":"[Шпаргалка] Django Cookiecutter commands","uri":"/cookiecutter-commands/"},{"categories":["notes"],"content":" pip install \"cookiecutter\u003e=1.7.0\" sudo docker-compose -f production.yml build sudo docker-compose -f production.yml down sudo docker-compose -f production.yml up -d sudo docker-compose -f production.yml run --rm django python manage.py migrate sudo docker-compose -f production.yml logs sudo docker-compose -f production.yml run --rm django python manage.py shell -i ipython docker-compose -f local.yml run --rm django python manage.py shell -i ipython from app.utils.import_countries import create_countries # Create db backup docker-compose -f local.yml exec postgres backup docker-compose -f production.yml exec postgres backup # DB backup list docker-compose -f local.yml exec postgres backups docker-compose -f production.yml exec postgres backups # Copy backup from docker to local (postgres - is container name) docker cp postgres:/backups . # Copy backup to docker docker cp backup_2021_09_10T09_23_12.sql.gz postgres:/backups docker cp ./backups/backup_2021_08_10T13_40_02.sql.gz allflags_postgres_1:/backups # Restoring from the Existing Backup docker-compose -f local.yml exec postgres restore backup_2021_09_10T09_23_12.sql.gz docker-compose -f production.yml exec postgres restore backup_2021_08_10T13_40_02.sql.gz ","date":"15.03.2021","objectID":"/cookiecutter-commands/:0:0","series":null,"tags":["django"],"title":"[Шпаргалка] Django Cookiecutter commands","uri":"/cookiecutter-commands/#"},{"categories":["python-interview"],"content":"Парадигма программирования — это совокупность идей и понятий, определяющих стиль написания компьютерных программ. Это способ концептуализации, определяющий организацию вычислений и структурирование работы, выполняемой компьютером.","date":"11.02.2021","objectID":"/programming-paradigms/","series":null,"tags":["base"],"title":"Парадигмы программирования - список и краткие описания","uri":"/programming-paradigms/"},{"categories":["python-interview"],"content":"Список вопросов к Python собеседованию Источники: Подробная статья ","date":"11.02.2021","objectID":"/programming-paradigms/:0:0","series":null,"tags":["base"],"title":"Парадигмы программирования - список и краткие описания","uri":"/programming-paradigms/#"},{"categories":["python-interview","algorithms"],"content":"Алгоритмы","date":"08.02.2021","objectID":"/algorithms/","series":null,"tags":null,"title":"Алгоритмы","uri":"/algorithms/"},{"categories":["python-interview","algorithms"],"content":"Список вопросов к Python собеседованию ","date":"08.02.2021","objectID":"/algorithms/:0:0","series":null,"tags":null,"title":"Алгоритмы","uri":"/algorithms/#"},{"categories":["python-interview","algorithms"],"content":"Время выполения алгоритма («О-большое»)На самом деле, существует не только «большое О», но и ряд других обозначений: O(ƒ(n)) – (Big-O) – верхняя граница, «не хуже чем»; o(ƒ(n)) – (Little-o) – верхняя граница, «лучше чем»; Ω(ƒ(n)) – (Omega) – нижняя граница, «не лучше чем»; Θ(ƒ(n)) – (Theta) – точная оценка. Наиболее часто встречающиеся оценки: О(1) - константное время (получение одного элемента в массиве) O(log n) - логарифмическое время (бинарный поиск). О(n) - линейное время (простой поиск). О(n*log n) - линейно-логарифмическое время (эффективные алгоритмы сортировки, напр. быстрая сортировка). О(n2) - квадратичное время (медленные алгоритмы сортировки: сортировка выбо­ром). О(n3) - кубическое время (Обычное умножение двух n на n матриц). О(n!) - очень медленные алгоритмы (задача о коммивояжере полным перебором). Сложность алгоритмов\" Сложность алгоритмов Скорость алгоритмов измеряется не в секундах, а в темпе роста количе­ ства операций.1 В некоторых случаях константа может иметь значение Один из примеров такого рода - быстрая сортировка и сортировка слиянием. У бы­строй сортировки константа меньше, чем у сортировки слиянием, поэтому, несмотря на то что оба алгоритма характеризуются временем О(n*log n), быстрая сортировка работает быстрее. А на практике быстрая сортировка работает быстрее, потому что средний случай встречается намного чаще худшего. ","date":"08.02.2021","objectID":"/algorithms/:1:0","series":null,"tags":null,"title":"Алгоритмы","uri":"/algorithms/#время-выполения-алгоритма-о-большое"},{"categories":["python-interview","algorithms"],"content":"Бинарный поискБинарный поиск - на входе получает отсортированный список элементов. Если искомый элемент присутствует в списке - возвращает его позицию. В противном слу­чае возвращает null. Time Complexities Best case complexity: O(1) Average case complexity: O(log n) Worst case complexity: O(log n) The space complexity of the binary search is O(1). def binary_search(arr: List[int], elem: int) -\u003e Union[int, None]: low = 0 high = len(arr) - 1 while low \u003c= high: mid = (low + high) // 2 guess = arr[mid] if guess == elem: return mid elif guess \u003e elem: high = mid - 1 else: low = mid + 1 return None More ","date":"08.02.2021","objectID":"/algorithms/:2:0","series":null,"tags":null,"title":"Алгоритмы","uri":"/algorithms/#бинарный-поиск"},{"categories":["python-interview","algorithms"],"content":"Сортировка выборомНаиболее простая, но медленная сортировка. Сложность О(n2). def search_min(arr: List) -\u003e int: min_index = 0 for i in range(len(arr) - 1): if arr[min_index] \u003e arr[i]: min_index = i return min_index def selection_sort(arr: List) -\u003e List: result = [] copy = arr[:] while len(copy) \u003e 0: min_index = search_min(copy) result.append(copy.pop(min_index)) return result More ","date":"08.02.2021","objectID":"/algorithms/:3:0","series":null,"tags":null,"title":"Алгоритмы","uri":"/algorithms/#сортировка-выбором"},{"categories":["python-interview","algorithms"],"content":"РекурсияРекурсия - это такой способ организации обработки данных, при котором программа вызывает сама себя непосредственно, либо с помощью других программ. Примеры в реальной жизни: эффект Дросте, треугольник Серпинского. Любой алгоритм, реализованный в рекурсивной форме, может быть переписан в итерационном виде и наоборот. Рекурсивная функция состоит из: Условие остановки / Базовый случай Условие продолжения / Шаг рекурсии — способ сведения задачи к более простым. Рекурсивные функции используют стек вызовов, где каждый вызов создает собственную копию переменной. Обратиться к переменной, принадлежащей другому уровню, невозможно. Стек — абстрактный тип данных, представляющий собой список элементов, организованных по принципу LIFO (last in — first out). В Python стеком можно назвать любой список, так как для них доступны операции pop и push. В интерпретаторе Python (CPython) есть защита от переполнения стека. Достигнув лимита глубины интерпретатор выдаст ошибку RecursionError: maximum recursion depth exceeded in comparison Лимит глубины рекурсии можно узнать при помощи функции sys.getrecursionlimit, а изменить этот лимит при помощи sys.setrecursionlimit: import sys print(sys.getrecursionlimit()) # 997 sys.setrecursionlimit(1500) Увеличение лимита рекурсии может привести к переполнению стека, поэтому лучше переписать алгоритм итеративно. Если в гугле ввести слово “рекурсия”, то он наряду с результатми поиска выдаст «возможно, вы имели в виду “рекурсия”» :-) ","date":"08.02.2021","objectID":"/algorithms/:4:0","series":null,"tags":null,"title":"Алгоритмы","uri":"/algorithms/#рекурсия"},{"categories":["python-interview","algorithms"],"content":"Быстрая сортировкаБыстродействие быстрой сортировки сильно зависит от выбора опорного элемента. Быстрая сортировка О-большое\" Быстрая сортировка О-большое Лучший сценарий: O(n*log n) (он же средний) - когда пограничным элементом выбирается средний, или ближайший к середине. Худший сценарий: O(n2) - это происходит в случае, если за пограничный элемент берется первый или последний элемент массива. from typing import List from random import randint # top answer on stackoveflow def quick_sort(arr: List) -\u003e List: less = [] equal = [] greater = [] if len(arr) \u003e 1: pivot = arr[0] # pivot = arr[len(arr) // 2] # pivot = randint(0, len(arr) - 1) for elem in arr: if elem \u003c pivot: less.append(elem) elif elem == pivot: equal.append(elem) else: greater.append(elem) return quick_sort(less) + equal + quick_sort(greater) else: return arr # В одну строку =) def qsort_one_line_mid(arr: List) -\u003e List: return ( arr if len(arr) \u003c 2 else qsort([val for val in arr if val \u003c arr[len(arr) // 2]]) + [arr[len(arr) // 2]] * arr.count(arr[len(arr) // 2]) + qsort([val for val in arr if val \u003e arr[len(arr) // 2]]) ) Существует параллельная версия быстрой сор­ тировки, которая сортирует массив за время О(n). More ","date":"08.02.2021","objectID":"/algorithms/:5:0","series":null,"tags":null,"title":"Алгоритмы","uri":"/algorithms/#быстрая-сортировка"},{"categories":["python-interview","algorithms"],"content":"Хеш-таблицы aka «ассоциативные массивы», «словари», «отображения», «хеш­ карты», «хеши» В научной терминологии говорят, что хеш-функция «отображает строки на числа». Хеш-функция должна соответствовать некоторым требованиям: Быть последовательной Разным строкам должны соответствовать разные числа Коллизии Существует много разных стратегий обработки коллизий. Простейшая из них выглядит так: если несколько ключей отображаются на один элемент, в этом элементе создается связанный список. выбор хеш-функции действительно важен. Хеш-функция, отображаю­ щая все ключи на один элемент массива, никуда не годится. В идеале хеш-функция должна распределять ключи равномерно по всему хешу; если связанные списки становятся слишком длинными, работа с хеш- таблицей сильно замедляется. Но они не станут слишком длинными при использовании хорошей хеш-функции! ","date":"08.02.2021","objectID":"/algorithms/:6:0","series":null,"tags":null,"title":"Алгоритмы","uri":"/algorithms/#хеш-таблицы"},{"categories":["python-interview","algorithms"],"content":"Поиск в ширину (BFS, Breadth-First Search)BFS - это алгоритм для решения задачи поиска кратчайшего пути. BFS помогает ответить на вопросы двух типов: тип 1: существует ли путь от узла А к узлу В? тип 2: как выглядит кратчайший путь от узла А к узлу В (нахо­дит путь с минимальным количеством сегментов)? Поиск в ширину выполняется за время O(V+E) ( V - количество вершин,Е - количество ребер). import collections def bfs(graph, root): visited, queue = set(), collections.deque([root]) visited.add(root) while queue: vertex = queue.popleft() for neighbour in graph[vertex]: if neighbour not in visited: visited.add(neighbour) queue.append(neighbour) BFS - это жадный алгоритм. ","date":"08.02.2021","objectID":"/algorithms/:7:0","series":null,"tags":null,"title":"Алгоритмы","uri":"/algorithms/#поиск-в-ширину-bfs-breadth-first-search"},{"categories":["python-interview","algorithms"],"content":"Алгоритм Дейкстры Алгоритм Дейкстры - алгоритм на графах, изобретённый нидерландским учёным Эдсгером Дейкстрой в 1959 году. Находит кратчайшие пути от одной из вершин графа до всех остальных. Алгоритм работает только для графов без рёбер отрицательного веса.2 Для графов с отрицательными весами - алгоритм Беллмана-Форда. Ал­горитм Дейкстры работает только с направленными ациклическими графами, которые нередко обозначаются сокращением DAG (Directed Acyclic Graph). Алгоритм Дейкстры состоит из четырех шагов: Найти узел с наименьшей стоимостью (то есть узел, до которого можно добраться за минимальное время). Проверить, существует ли более дешевый путь к соседям этого узла, и если существует, обновить их стоимости. Повторять, пока это не будет сделано для всех узлов графа. Вычислить итоговый путь. Алгоритм Дейкстры - это жадный алгоритм. Свести задачу к решаемой BFS можно, но если заменить все рёбра неединичной длины n рёбрами длины 1, то граф очень разрастётся, и это приведёт к огромному числу действий при вычислении оптимального маршрута. Условие неотрицательности весов рёбер крайне важно и от него нельзя просто избавиться. Не получится свести задачу к решаемой алгоритмом Дейкстры, прибавив наибольший по модулю вес ко всем рёбрам. Это может изменить оптимальный маршрут. Попытка избавиться от отрицательных весов\" Попытка избавиться от отрицательных весов В оригинале путь проходит через a -\u003e b -\u003e c -\u003e d, а после добавления семёрки ко всем рёбрам, оптимальный путь проходит через a -\u003e c -\u003e d. Эффективная реализация предполагает использование кучи. Статья с кодом Статья на Хабре ","date":"08.02.2021","objectID":"/algorithms/:8:0","series":null,"tags":null,"title":"Алгоритмы","uri":"/algorithms/#алгоритм-дейкстры"},{"categories":["python-interview","algorithms"],"content":"Жадные алгоритмыЖадный алгоритм прост: на каж­дом шаге он выбирает оптимальный вариант. В техни­ческой терминологии: на каждом шаге выбирается локально-оптимальное решение, а в итоге мы получаем глобально-оптимальное решение. Иногда идеальное - враг хорошего. В некоторых случаях достаточно алгоритма, способного решить задачу достаточно хорошо. И в таких областях жадные алгоритмы работают просто отлично, потому что они просто реализуются, а получен­ное решение обычно близко к оптимуму. Когда вычисление точного реше­ния занимает слишком много времени, применяется приближенный алго­ритм. Эффективность приближенного алгоритма оценивается по быстроте и близости полученного решения к оптимальному. ","date":"08.02.2021","objectID":"/algorithms/:9:0","series":null,"tags":null,"title":"Алгоритмы","uri":"/algorithms/#жадные-алгоритмы"},{"categories":["python-interview","algorithms"],"content":"NP-полные задачиЗадача о коммивояжере и задача покрытия множества Не существует простого способа определить, является ли задача, с которой вы работаете, NР-полной. Несколько характерных признаков: алгоритм быстро работает при малом количестве элементов, но сильно замедляется при увеличении их числа; формулировка «все комбинации х» часто указывает на NР-полноту за­дачи; приходится вычислять все возможные варианты Х, потому что за­дачу невозможно разбить на меньшие подзадачи? Такая задача может оказаться NР-полной; если в задаче встречается некоторая последовательность (например, последовательность городов, как в задаче о коммивояжере) и задача не имеет простого решения, она может оказаться NР-полной; если в задаче встречается некоторое множество и задача не имеет простого решения, она может оказаться NР-полной; можно ли переформулировать задачу в условиях задачи покрытия множества или задачи о коммивояжере? В таком случае задача определенно является NР-полной. У NР-полных задач не существует известных быстрых решений. ","date":"08.02.2021","objectID":"/algorithms/:10:0","series":null,"tags":null,"title":"Алгоритмы","uri":"/algorithms/#np-полные-задачи"},{"categories":["python-interview","algorithms"],"content":"Динамическое программирование Динамическое программирование применяется при оптимизации не­ которой характеристики. Динамическое программирование работает только в ситуациях, в кото­рых задача может быть разбита на автономные подзадачи. В каждом решении из области динамического программирования стро­ится таблица. Значения ячеек таблицы обычно соответствуют оптимизируемой харак­теристике. Каждая ячейка представляет подзадачу, поэтому нужно думать о том, как разбить задачу на подзадачи. Не существует единой формулы для вычисления решений методом ди­намического программирования. Расстояние Левенштейна оцени­вает, насколько похожи две строки , а для его вычисления применяется динамическое программирование. ","date":"08.02.2021","objectID":"/algorithms/:11:0","series":null,"tags":null,"title":"Алгоритмы","uri":"/algorithms/#динамическое-программирование"},{"categories":["python-interview","algorithms"],"content":"Алгоритм ФейнманаАлгоритм Фейнмана, названный по имени известного физика Ричарда Фейнмана, работает так: Записать формулировку задачи. Хорошенько подумать. Записать решение. ","date":"08.02.2021","objectID":"/algorithms/:12:0","series":null,"tags":null,"title":"Алгоритмы","uri":"/algorithms/#алгоритм-фейнмана"},{"categories":["python-interview","algorithms"],"content":"Алгоритм k ближайших соседейАлгоритм k ближайших соседей применяется для классификации и ре­грессии. В нем используется проверка k ближайших соседей. Классификация = распределение по категориям. Регрессия = прогнозирование результата. «Извлечением признаков» называется преобразование элемента в список чисел, которые могут ис­пользоваться для сравнения. Качественный выбор признаков - важная часть успешного алгоритма k ближайших соседей. ","date":"08.02.2021","objectID":"/algorithms/:13:0","series":null,"tags":null,"title":"Алгоритмы","uri":"/algorithms/#алгоритм-k-ближайших-соседей"},{"categories":["python-interview","algorithms"],"content":"Преобразование Фурье","date":"08.02.2021","objectID":"/algorithms/:14:0","series":null,"tags":null,"title":"Алгоритмы","uri":"/algorithms/#преобразование-фурье"},{"categories":["python-interview","algorithms"],"content":"Фильтры Блума и Hyperloglog","date":"08.02.2021","objectID":"/algorithms/:15:0","series":null,"tags":null,"title":"Алгоритмы","uri":"/algorithms/#фильтры-блума-и-hyperloglog"},{"categories":["python-interview","algorithms"],"content":"Параллельные алгоритмы","date":"08.02.2021","objectID":"/algorithms/:16:0","series":null,"tags":null,"title":"Алгоритмы","uri":"/algorithms/#параллельные-алгоритмы"},{"categories":["python-interview","algorithms"],"content":"Распределенные алгоритмы","date":"08.02.2021","objectID":"/algorithms/:17:0","series":null,"tags":null,"title":"Алгоритмы","uri":"/algorithms/#распределенные-алгоритмы"},{"categories":["python-interview","algorithms"],"content":"Алгоритмы SHA","date":"08.02.2021","objectID":"/algorithms/:18:0","series":null,"tags":null,"title":"Алгоритмы","uri":"/algorithms/#алгоритмы-sha"},{"categories":["python-interview","algorithms"],"content":"Алгоритм Диффи-Хеллмана","date":"08.02.2021","objectID":"/algorithms/:19:0","series":null,"tags":null,"title":"Алгоритмы","uri":"/algorithms/#алгоритм-диффи-хеллмана"},{"categories":["python-interview","algorithms"],"content":"Линейное программированиеНаправленный / ненаправленный граф Взвешенный / невзвешенный граф Дерево в-деревья; красно-черные деревья; кучи; скошенные (splay) деревья. О-большое (Wiki) ↩︎ Алгоритм Дейкстры ↩︎ ","date":"08.02.2021","objectID":"/algorithms/:20:0","series":null,"tags":null,"title":"Алгоритмы","uri":"/algorithms/#линейное-программирование"},{"categories":["python-interview"],"content":"Подчеркивание (underscore) в Python используется: в именах объектов, в интерпретаторе, при игнорировании значений, в функционале локализации и для разделения цифр в числах. Двойное подчеркивание (dunder) только в именах объектов.","date":"14.11.2020","objectID":"/underscore-in-python/","series":null,"tags":["python"],"title":"Символ подчеркивания в Python - использование Underscores и Dunders","uri":"/underscore-in-python/"},{"categories":["python-interview"],"content":"Список вопросов к Python собеседованию ","date":"14.11.2020","objectID":"/underscore-in-python/:0:0","series":null,"tags":["python"],"title":"Символ подчеркивания в Python - использование Underscores и Dunders","uri":"/underscore-in-python/#"},{"categories":["python-interview"],"content":"Подчеркивание в именах объектовНаиболее простой и очевидный способ применения подчеркивания - это разделение слов в именах объектов: lower_case_with_underscores UPPER_CASE_WITH_UNDERSCORES Capitalized_Words_With_Underscores (ugly!)1 Одинарные и двойные подчеркивания в именах переменных и методов имеют определенное значение. Часть вариантов использования - это просто договоренность и предназначены как подсказка программисту, а часть используется интерпретатором Python:2 _single_leading_underscore: слабый показатель того, что объект (переменная, функция, метод, класс) предназначен для «внутреннего использования» - protected на словах. (Например, from M import * не импортирует объекты, имена которых начинаются с подчеркивания); single_trailing_underscore_: используется по соглашению, чтобы избежать конфликтов с ключевыми словами Python; __double_leading_underscore: такие имена трансформируются в формат «имя класса + имя метода/атрибута». Это позволяет создавать уникальные методы и атрибуты классов (внутри класса FooBar __boo становится _FooBar__boo). Это также называется “Name Mangling” - интерпретатор меняет имя переменной таким образом, что затрудняет создание коллизий при расширении класса позже.; __double_leading_and_trailing_underscore__: «магические» методы или атрибуты, которые живут в контролируемых пользователем пространствах имен. Например. __init__, __import__ или __file__. PEP 8 рекомендует никогда не придумывать таких имен, а использовать их только в соответствии с документацией.1 ","date":"14.11.2020","objectID":"/underscore-in-python/:1:0","series":null,"tags":["python"],"title":"Символ подчеркивания в Python - использование Underscores и Dunders","uri":"/underscore-in-python/#подчеркивание-в-именах-объектов"},{"categories":["python-interview"],"content":"Символ подчеркивания в интерпретатореВ интерпретаторе символ подчеркивания _ хранит результат последнего неошибочного действия, выведенного на экран, если он не был явно использован в качестве переменной. Это связано с тем, что sys.stdout экранируется с помощью displayhook. Пример из официальной документации: def displayhook(value): if value is None: return # Set '_' to None to avoid recursion builtins._ = None text = repr(value) try: sys.stdout.write(text) except UnicodeEncodeError: bytes = text.encode(sys.stdout.encoding, 'backslashreplace') if hasattr(sys.stdout, 'buffer'): sys.stdout.buffer.write(bytes) else: text = bytes.decode(sys.stdout.encoding, 'strict') sys.stdout.write(text) sys.stdout.write(\"\\n\") builtins._ = value ","date":"14.11.2020","objectID":"/underscore-in-python/:2:0","series":null,"tags":["python"],"title":"Символ подчеркивания в Python - использование Underscores и Dunders","uri":"/underscore-in-python/#символ-подчеркивания-в-интерпретаторе"},{"categories":["python-interview"],"content":"Подчеркивание для игнорирования значенийНижнее подчеркивание _ также используется для игнорирования ненужных нам значений.3 Игнорирование значения при распаковке x, _, y = (3, 7, 8) # x = 3, y = 8 Игнорирование нескольких значений - “Extended Unpacking” x, *_, y = (5, 7, 1, 8, 2) # x = 5, y = 2 Игнорирование индекса в цикле for _ in range(100): do_something() Игнорирование значения в определенной позиции for _, val in some_dict.items(): print(val) ","date":"14.11.2020","objectID":"/underscore-in-python/:3:0","series":null,"tags":["python"],"title":"Символ подчеркивания в Python - использование Underscores и Dunders","uri":"/underscore-in-python/#подчеркивание-для-игнорирования-значений"},{"categories":["python-interview"],"content":"Подчеркивание в i18n и l10nСокращения i18n и l10n i18n - Internationalization: i(18 букв)n l10n - Localization: l(10 букв)n g11n - Globalization: g(11 букв)n l12y - Localizability: l(12 букв)y Пример использования из офф. документации4: import gettext gettext.bindtextdomain('myapplication','/path/to/my/language/directory') gettext.textdomain('myapplication') _ = gettext.gettext # ... print(_('This is a translatable string.')) Это просто соглашение, а не синтаксис функции. Этого соглашения придерживается и модуль gettext из встроенной стандартной библиотеки, и Django. ","date":"14.11.2020","objectID":"/underscore-in-python/:4:0","series":null,"tags":["python"],"title":"Символ подчеркивания в Python - использование Underscores и Dunders","uri":"/underscore-in-python/#подчеркивание-в-i18n-и-l10n"},{"categories":["python-interview"],"content":"Подчеркивание для разделения цифрСимвол нижнего подчеркивания может использоваться для разделения цифр в больших числах. big_int = 2_000_000 # 2000000 hex_num = 0x_3212_ffff # 840105983 bin_num = 0b_1010_0111 # 167 PEP 8 - Descriptive: Naming Styles ↩︎ ↩︎ Dan Bader - The Meaning of Underscores in Python ↩︎ Understanding the underscore ( _ ) of Python ↩︎ Python Docs - gettext - Multilingual internationalization services ↩︎ ","date":"14.11.2020","objectID":"/underscore-in-python/:5:0","series":null,"tags":["python"],"title":"Символ подчеркивания в Python - использование Underscores и Dunders","uri":"/underscore-in-python/#подчеркивание-для-разделения-цифр"},{"categories":["notes"],"content":"Git commands","date":"09.11.2020","objectID":"/git-commands/","series":null,"tags":["git"],"title":"Git commands","uri":"/git-commands/"},{"categories":["notes"],"content":" git init git add . git commit -m 'Description' git commit -a -m 'Description' # коммитит все файлы, не требует выполнять add git rm \u003cfile\u003e # -f если файл уже в коммите git rm --cached \u003cfile\u003e # Удалить файл из индекса, оставив его при этом в рабочем каталоге git mv \u003cfile_from\u003e \u003cfile_to\u003e git status (-s --short) git checkout . git reset HEAD \u003cfile\u003e # Dry Run will tell you what files will be removed upon executing the clean command git clean -n # To remove untracked files using -f flag git clean -f # To remove untracked files inside a subfolder git clean -f folderpath # to delete untracked folders too git clean -fd # To remove ignore files, use the -x flag git clean -fx git clone [url] git filter-branch --force --index-filter \\ \"git rm --cached --ignore-unmatch PATH-TO-YOUR-FILE-WITH-SENSITIVE-DATA\" \\ --prune-empty --tag-name-filter cat -- --all git push origin --force --all git push origin --force --tags # Branches git branch # Список веток git branch \u003cbranch_name\u003e git checkout \u003cbranch_name\u003e git checkout -b \u003cbranch_name\u003e # Предыдущие 2 команды в одну строку # Слияние с master git checkout master git merge \u003cbranch_name\u003e git branch -d \u003cbranch_name\u003e # Удаление ветки git remote -v # внешний репозиторий git remote add origin https://github.com/baikov/baikov.dev.git # Merge/Rebase git remote add upstream https://github.com/whoever/whatever.git git fetch upstream git rebase upstream/master git merge upstream/master # Rename git branch -m \u003coldname\u003e \u003cnewname\u003e # If you want to rename the current branch, you can do: git branch -m \u003cnewname\u003e # If you want to push the local branch and reset the upstream branch: git push origin -u \u003cnewname\u003e # And finally if you want to Delete the remote branch: git push origin --delete \u003coldname\u003e # Stash # только те изменения, которые еще не были индексированы (командой add) git stash save --keep-index # отменяет все индексированные и неиндексированные изменения в рабочей области, сохраняя их в карман (stash) git stash save # Восстановление несохраненных изменений git stash apply # удалить последнюю запись кармана git stash drop # config list git config -l # local and global email git config user.email git config --global user.email # set local email git config user.email \"my@email.com\" Показать изменения между stage и HEAD: git diff --staged Показать изменения между Working Directory и HEAD: git diff HEAD Скопировать нужные коммиты # от A до B git cherry-pick 'A^..B' # от A до B исключив A git cherry-pick 'A..B' Push branch to remote git push origin feature Полезное: SO - Как вернуться (откатиться) к более раннему коммиту? How to cherry-pick multiple commits ","date":"09.11.2020","objectID":"/git-commands/:0:0","series":null,"tags":["git"],"title":"Git commands","uri":"/git-commands/#"},{"categories":["python-interview"],"content":"Разница между операторами сравнения 'is' и '==' в Python в том, что оператор '==' проверяет равенство значений двух объектов, а оператор 'is' проверяет идентичность самих объектов. Его используют, чтобы удостовериться, что переменные указывают на один и тот же объект в памяти.","date":"01.10.2020","objectID":"/difference-between-is-and-equal-in-python/","series":null,"tags":["python"],"title":"В чем разница между операторами \"is\" и \"==\" в Python","uri":"/difference-between-is-and-equal-in-python/"},{"categories":["python-interview"],"content":"Список вопросов к Python собеседованию ","date":"01.10.2020","objectID":"/difference-between-is-and-equal-in-python/:0:0","series":null,"tags":["python"],"title":"В чем разница между операторами \"is\" и \"==\" в Python","uri":"/difference-between-is-and-equal-in-python/#"},{"categories":["python-interview"],"content":"Определение и особенности операторов сравнения оператор == проверяет равенство значений двух объектов; оператор is проверяет идентичность самих объектов. Его используют, чтобы удостовериться, что переменные указывают на один и тот же объект в памяти. Два объекта, имеющие одинаковые значения, не обязательно идентичны. Python (CPython, если быть точнее) в целях производительности кеширует короткие строки и малые целые числа. Подробнее тут - “What the f*ck Python!”.1 Под целые числа из диапазона от -5 до 256 включительно интерпретатор заранее выделяет место в памяти и даёт переменным ссылки на эти объекты, поэтому возможны такие казусы: str1 = 'hello' str2 = 'hello' str1 == str2 # True str1 is str2 # True Оператор is - это в общем-то “синтаксический сахар”: a is b по факту обертка для id(a) == id(b) ","date":"01.10.2020","objectID":"/difference-between-is-and-equal-in-python/:1:0","series":null,"tags":["python"],"title":"В чем разница между операторами \"is\" и \"==\" в Python","uri":"/difference-between-is-and-equal-in-python/#определение-и-особенности-операторов-сравнения"},{"categories":["python-interview"],"content":"Что PEP8 говорит об этом?Сравнение с синглтонами, такими как None, всегда должно производиться с помощью операторов is или is not, и никогда с помощью операторов равенства (== и !=). Кроме того, остерегайтесь записи, if x, если на самом деле имеете в виду, if x is not None - например, при проверке того, было ли переменной или аргументу, который по умолчанию равен None, присвоено какое-либо другое значение. Другое значение может иметь тип (например, контейнер), который в булевом контексте может иметь значение False!2 is работает быстрее, чем ==. В конце концов, is реализовано на C и представляет собой простое сравнение идентификаторов двух объектов. Вызов функции не требуется, и нам, конечно же, не нужно сравнивать значения двух объектов, что также может занять некоторое время.3 ","date":"01.10.2020","objectID":"/difference-between-is-and-equal-in-python/:2:0","series":null,"tags":["python"],"title":"В чем разница между операторами \"is\" и \"==\" в Python","uri":"/difference-between-is-and-equal-in-python/#что-pep8-говорит-об-этом"},{"categories":["python-interview"],"content":"Варианты применения is и ==Примеры использования is включают:4 None значения enum (при использовании Enums из модуля enum) модули объекты класса, полученные из определений классов (зачастую) функциональные объекты, полученные в результате определений функций (зачастую) все остальное, что должно существовать в памяти только один раз (как правило, все синглтоны) конкретный объект, который вы хотите проверить по идентичности Обычные варианты использования == включают: числа, в том числе целые строки списки множества словари кастомные изменяемые объекты в большинстве случаев другие встроенные неизменяемые объекты What the f*ck Python! ↩︎ PEP8 ↩︎ Why you should almost never use “is” in Python ↩︎ stackoverflow ↩︎ ","date":"01.10.2020","objectID":"/difference-between-is-and-equal-in-python/:3:0","series":null,"tags":["python"],"title":"В чем разница между операторами \"is\" и \"==\" в Python","uri":"/difference-between-is-and-equal-in-python/#варианты-применения-is-и-"},{"categories":["python-interview"],"content":"Методология разработки ПО – это система, определяющая порядок выполнения задач, методы оценки и контроля. Модели разработки ПО выбирают, исходя из направления проекта, его бюджета и сроков реализации конечного продукта.","date":"20.09.2020","objectID":"/software-development-methodologies/","series":null,"tags":["base"],"title":"Модели и методологии разработки ПО - жизненный цикл продукта","uri":"/software-development-methodologies/"},{"categories":["python-interview"],"content":"Список вопросов к Python собеседованию ","date":"20.09.2020","objectID":"/software-development-methodologies/:0:0","series":null,"tags":["base"],"title":"Модели и методологии разработки ПО - жизненный цикл продукта","uri":"/software-development-methodologies/#"},{"categories":["python-interview"],"content":"Жизненный цикл ПО Software Development Life Cycle, SDLC - период времени, который начинается с момента принятия решения о необходимости создания программного продукта и заканчивается в момент его полного изъятия из эксплуатации Создание и развитие любого продукта происходит постепенно, проходя ряд обязательных этапов, часть из которых может идти параллельно. Жизненный цикл проекта в IT – непрерывный процесс, который заканчивается, лишь когда его решают закрыть. Этапы жизненного цикла ПО: Анализ (подготовка) Проектирование Создание (программирование) Тестирование Внедрение Сопровождение Существует некая вариативность в прохождении этих этапов во время разработки и внедрения продукта. Для каждого продукта это происходит по-своему, но чтобы процессом как-то управлять были сформулированы модели жизненного цикла ПО – упрощенное и обобщенное представление о том, как развивается продукт. В реальности жизнь продукта редко соответствует какой-либо модели. ","date":"20.09.2020","objectID":"/software-development-methodologies/:1:0","series":null,"tags":["base"],"title":"Модели и методологии разработки ПО - жизненный цикл продукта","uri":"/software-development-methodologies/#жизненный-цикл-по"},{"categories":["python-interview"],"content":"Парадигмы и модели разработки ПОПо большому счету все модели можно разделить на две больших группы: последовательные и итерационные модели. ","date":"20.09.2020","objectID":"/software-development-methodologies/:2:0","series":null,"tags":["base"],"title":"Модели и методологии разработки ПО - жизненный цикл продукта","uri":"/software-development-methodologies/#парадигмы-и-модели-разработки-по"},{"categories":["python-interview"],"content":"Code and FixЯвлялась первой моделью разработки ПО. Этапы модели: выяснение потребностей заказчика; создание; внедрение исправления по итогам отзывов; Повторяем цикл до полного удовлетворения заказчика (или пока у него не кончатся деньги или терпение) ","date":"20.09.2020","objectID":"/software-development-methodologies/:3:0","series":null,"tags":["base"],"title":"Модели и методологии разработки ПО - жизненный цикл продукта","uri":"/software-development-methodologies/#code-and-fix"},{"categories":["python-interview"],"content":"Каскадная модельWaterfall Model или «водопад» В этой модели разработка осуществляется поэтапно: каждая следующая стадия начинается только после того, как заканчивается предыдущая. Каскадная модель разработки ПО (Waterfall) - схема\" Каскадная модель разработки ПО (Waterfall) - схема Преимущества: Линейность модели облегчает ее понимание; Все спецификации и результаты изложены до начала разработки; Строгость этапов позволяет планировать сроки завершения всех работ и соответствующие ресурсы Хорошо работает для небольших проектов; Стоимость проекта определяется на начальном этапе; Недостатки: Сложности при формулировке четких требований и невозможность их изменения; Модель водопада неприменима к проектам, требующим непрерывной доработки; Отсутствие работающего продукта до окончания последней стадии разработки; Тестирование начинается только с середины развития проекта; Много технической документации ","date":"20.09.2020","objectID":"/software-development-methodologies/:4:0","series":null,"tags":["base"],"title":"Модели и методологии разработки ПО - жизненный цикл продукта","uri":"/software-development-methodologies/#каскадная-модель"},{"categories":["python-interview"],"content":"V-образная модельV-образная модель разработки ПО - схема\" V-образная модель разработки ПО - схема V-Model (разработка через тестирование) Суть этой модели состоит в том, что процессы на всех этапах контролируются, чтобы убедиться в возможности перехода на следующий уровень. Уже на стадии написания требований начинается процесс тестирования. Частично устраняет недостатки каскадной модели. Преимущества: Этапы строго определены; Минимизация рисков и устранение потенциальных проблем за счет раннего тестирования; Усовершенствованный тайм-менеджмент. Недостатки: Нет возможности адаптироваться к измененным требованиям заказчика; Длительное время разработки (иногда до нескольких лет) приводит к тому, что продукт может быть уже не нужен заказчику, поскольку его потребности меняются; Нет действий, направленных на анализ рисков. ","date":"20.09.2020","objectID":"/software-development-methodologies/:5:0","series":null,"tags":["base"],"title":"Модели и методологии разработки ПО - жизненный цикл продукта","uri":"/software-development-methodologies/#v-образная-модель"},{"categories":["python-interview"],"content":"Итерационная модельIterative Model - Итерационная (итеративная) модель Предполагает разбиение проекта на части (этапы, итерации) и прохождение этапов жизненного цикла на каждом их них. Каждый этап является законченным сам по себе, совокупность этапов формирует конечный результат. Преимущества: Быстрый выпуск минимального продукта даёт возможность оперативно получать обратную связь от заказчика и пользователей; Фокус на наиболее важных функциях ПО и улучшение их в соответствии с требованиями рынка и пожеланиями клиента. Постоянное тестирование пользователями позволяет быстро обнаруживать и устранять ошибки. Недостатки: Вероятность того, что на определенной итерации придётся переписывать большую часть приложения. Отсутствие фиксированного бюджета и сроков. ","date":"20.09.2020","objectID":"/software-development-methodologies/:6:0","series":null,"tags":["base"],"title":"Модели и методологии разработки ПО - жизненный цикл продукта","uri":"/software-development-methodologies/#итерационная-модель"},{"categories":["python-interview"],"content":"Инкрементная модельИнкрементная модель разработки ПО - схема\" Инкрементная модель разработки ПО - схема Incremental Model Эта модель разработки дает возможность делать продукт по частям — инкрементам. Каждая часть представляет собой готовый фрагмент итогового продукта, который в идеале не переделывается. Улучшение продукта проходит запланировано все время пока жизненный цикл разработки ПО не завершится. Требования к системе определяются в самом начале работы, после чего процесс разработки проводится в виде последовательности версий, каждая из которых является законченным и работоспособным продуктом. Преимущества: Заказчик может дать свой отзыв касательно каждой версии продукта; Есть возможность пересмотреть риски, которые связаны с затратами и соблюдением графика; Ошибка обходится дешевле. Недостатки: Функциональная система должна быть полностью определена в начале жизненного цикла для выделения итераций; При постоянных изменениях структура системы может быть нарушена; Сроки сдачи системы могут быть затянуты из-за ограниченности ресурсов (исполнители, финансы). ","date":"20.09.2020","objectID":"/software-development-methodologies/:7:0","series":null,"tags":["base"],"title":"Модели и методологии разработки ПО - жизненный цикл продукта","uri":"/software-development-methodologies/#инкрементная-модель"},{"categories":["python-interview"],"content":"Спиральная модельСпиральная модель разработки ПО - схема\" Спиральная модель разработки ПО - схема Spiral Model Эту модель начали использовать в 1988 году. В спиральной модели жизненный путь разрабатываемого продукта изображается в виде спирали, которая, начавшись на этапе планирования, раскручивается с прохождением каждого следующего шага. Таким образом, на выходе из очередного витка: получаем готовый протестированный прототип, который дополняет существующую сборку; принимается решение, продолжать ли проект. Спиральная модель предполагает 4 этапа для каждого витка: планирование; анализ рисков; конструирование; оценка результата и при удовлетворительном качестве переход к новому витку. Преимущества: Управлению рисками уделяется особое внимание; Дополнительные функции могут быть добавлены на поздних этапах; Есть возможность гибкого проектирования. Недостатки: Оценка рисков на каждом этапе является довольно затратной; Постоянные отзывы и реакция заказчика может провоцировать все новые и новые итерации, которые могут приводить к временному затягиванию разработки продукта; Более применима для больших проектов. ","date":"20.09.2020","objectID":"/software-development-methodologies/:8:0","series":null,"tags":["base"],"title":"Модели и методологии разработки ПО - жизненный цикл продукта","uri":"/software-development-methodologies/#спиральная-модель"},{"categories":["python-interview"],"content":"Модель хаосаChaos model Её создатель Л.Б.С.Ракун отмечает, что такие модели управления проектами, как спиральная модель и каскадная модель, хотя и хороши в управлении расписаниями и персоналом, не обеспечивают методами устранения ошибок и решениями других технических задач, не помогают ни в управлении конечными сроками, ни в реагировании на запросы клиентов. Модель хаоса — это инструмент пытающийся помочь понять эти ограничения и восполнить пробелы. Стратегия хаоса — это стратегия разработки программного обеспечения, основанная на модели хаоса. Главное правило — это всегда решать наиболее важную задачу первой. ","date":"20.09.2020","objectID":"/software-development-methodologies/:9:0","series":null,"tags":["base"],"title":"Модели и методологии разработки ПО - жизненный цикл продукта","uri":"/software-development-methodologies/#модель-хаоса"},{"categories":["python-interview"],"content":"Гибкая (Agile) модельAgile Model - гибкая модель разработки, по которой сегодня работает большинство ИТ-проектов.Представляет собой совокупность различных подходов к разработке ПО. Основные идеи Agile: люди и взаимодействие важнее процессов и инструментов; работающий продукт важнее исчерпывающей документации; сотрудничество с заказчиком важнее согласования условий контракта; готовность к изменениям важнее следования первоначальному плану. Преимущества: после каждой итерации заказчик может наблюдать результат и понимать, удовлетворяет он его или нет. быстрое принятие решений за счет постоянных коммуникаций; минимизация рисков; облегченная работа с документацией. Недостатки: большое количество митингов и бесед, что может увеличить время разработки продукта; сложно планировать процессы, так как требования постоянно меняются; редко используется для реализации больших проектов. ","date":"20.09.2020","objectID":"/software-development-methodologies/:10:0","series":null,"tags":["base"],"title":"Модели и методологии разработки ПО - жизненный цикл продукта","uri":"/software-development-methodologies/#гибкая-agile-модель"},{"categories":["python-interview"],"content":"Гибкие методологии разработки ПО SCRUM Kanban (看板) RUP (Rational Unified Process) OpenUP DSDM (Dynamic Systems Development Model) RAD (Rapid Application Development) XP (Extreme Programming) FDD (Feature Driven Development) ASD (Adaptive Software Development) DevOps (Development and Operations) DAD (Disciplined Agile Delivery) Lean SD (Lean Software Development) MDD (Model-Driven Development) MSF (Microsoft Solutions Framework) PSP (Personal Software Process) SAFe (Scaled Agile Framework) UP (Unified Process) Источники1234 Agile манифест ↩︎ Модели жизненного цикла, принципы и методологии разработки ПО ↩︎ Модели и методологии разработки ПО ↩︎ Ещё раз про семь основных методологий разработки ↩︎ ","date":"20.09.2020","objectID":"/software-development-methodologies/:11:0","series":null,"tags":["base"],"title":"Модели и методологии разработки ПО - жизненный цикл продукта","uri":"/software-development-methodologies/#гибкие-методологии-разработки-по"},{"categories":["howto"],"content":"Настройки Vim","date":"14.09.2020","objectID":"/vim-settings/","series":null,"tags":["vim"],"title":"Настройки Vim","uri":"/vim-settings/"},{"categories":["howto"],"content":"Vundle Vim Установка git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim Настройка Vundle Размещаем это в начале .vimrc, чтобы использовать Vundle: set nocompatiblefiletype offset rtp+=~/.vim/bundle/Vundle.vimcall vundle#begin()Plugin 'VundleVim/Vundle.vim'Plugin 'tpope/vim-fugitive'Plugin 'ambv/black'Plugin 'nvie/vim-flake8'Plugin 'scrooloose/nerdtree'Plugin 'davidhalter/jedi-vim'Plugin 'mitsuhiko/vim-jinja'Plugin 'git://git.wincent.com/command-t.git'Plugin 'rstacruz/sparkup', {'rtp': 'vim/'}Plugin 'flazz/vim-colorschemes'Plugin 'tpope/vim-surround'call vundle#end() \" requiredfiletype onfiletype plugin onfiletype plugin indent on \" required\" Put your non-Plugin stuff after this line Установка плагинов Заходим в vim и запускаем команду :PluginInstall Для установки плагинов из командной строки: vim +PluginInstall +qall Команды Vundle :PluginList - список настроенных плагинов :PluginInstall - устанавливает плагины (с добавленем ! - обновляет) :PluginUpdate - обновляет плагины :PluginSearch foo - ищет foo (с добавленем ! обновляет локальный кэш) :PluginClean - подтверждает удаление неиспользуемых плагинов (добавить ! для автоматического подтверждения удаления) ","date":"14.09.2020","objectID":"/vim-settings/:1:0","series":null,"tags":["vim"],"title":"Настройки Vim","uri":"/vim-settings/#vundle-vim"},{"categories":["howto"],"content":"Список плагинов tpope/vim-fugitive - :Git commit, :Git rebase -i и другие команды git; tpope/vim-commentary — позволяет закомментировать код: командой gcc — строку, а командой gc — выделенный фрагмент в визуальном режиме; tpope/vim-surround ambv/black nvie/vim-flake8 scrooloose/nerdtree davidhalter/jedi-vim mitsuhiko/vim-jinja git://git.wincent.com/command-t.git rstacruz/sparkup' flazz/vim-colorschemes ","date":"14.09.2020","objectID":"/vim-settings/:2:0","series":null,"tags":["vim"],"title":"Настройки Vim","uri":"/vim-settings/#список-плагинов"},{"categories":["howto"],"content":"Дополнительные настройки set cursorline \" выделять строку, на которой находится курсор \" установить tab равным 4 пробеламset tabstop=4 \" set ts=4\" при использовании команд \u003e\u003e или \u003c\u003c сдвигать строки на 4 пробелаset shiftwidth=4set smarttab\" преобразование tab-ов в пробелыset expandtab\"4 пробела в табеset softtabstop=4\" Автоотступ при переходе на следующую строку при написании кодаset autoindent\" включить подсветку синтаксиса Pythonlet python_highlight_all = 1\" Включаем 256 цветов в терминале, мы ведь работаем из иксов?\" Нужно во многих терминалах, например в gnome-terminalset t_Co=256\" Перед сохранением вырезаем пробелы на концах (только в .py файлах)autocmd BufWritePre *.py normal m`:%s/\\s\\+$//e ``\" В .py файлах включаем умные отступы после ключевых словautocmd BufRead *.py set smartindent cinwords=if,elif,else,for,while,try,except,finally,def,classsyntax on \"Включить подсветку синтаксиса syntax enableset nu \"Включаем нумерацию строкset showmatch \" показывать парную скобку для [] {} и ()\" set cursorline \" выделять строку, на которой находится курсорset mousehide \"Спрятать курсор мыши когда набираем текстset mouse=a \"Включить поддержку мышиset termencoding=utf-8 \"Кодировка терминалаset novisualbell \"Не мигатьset t_vb= \"Не пищать! (Опции 'не портить текст', к сожалению, нету)\" Удобное поведение backspaceset backspace=indent,eol,start whichwrap+=\u003c,\u003e,[,]\" Вырубаем черточки на табахset showtabline=1\" Переносим на другую строчку, разрываем строкиset wrapset linebreak\" Вырубаем .swp и ~ (резервные) файлыset nobackupset noswapfileset encoding=utf-8 \" Кодировка файлов по умолчаниюset fileencodings=utf8,cp1251set clipboard=unnamedset rulerset hiddennnoremap \u003cC-N\u003e :bnext\u003cCR\u003ennoremap \u003cC-P\u003e :bprev\u003cCR\u003ennoremap \u003cF3\u003e :NERDTreeMirror\u003cCR\u003ennoremap \u003cF3\u003e :NERDTreeToggle\u003cCR\u003e\" Выключаем звук в Vimset visualbell t_vb=\"Переключение табов по CMD+number для MacVimif has(\"gui_macvim\")\" Press Ctrl-Tab to switch between open tabs (like browser tabs) to\" the right side. Ctrl-Shift-Tab goes the other way.noremap \u003cC-Tab\u003e :tabnext\u003cCR\u003enoremap \u003cC-S-Tab\u003e :tabprev\u003cCR\u003e\" Switch to specific tab numbers with Command-numbernoremap \u003cD-1\u003e :tabn 1\u003cCR\u003enoremap \u003cD-2\u003e :tabn 2\u003cCR\u003enoremap \u003cD-3\u003e :tabn 3\u003cCR\u003enoremap \u003cD-4\u003e :tabn 4\u003cCR\u003enoremap \u003cD-5\u003e :tabn 5\u003cCR\u003enoremap \u003cD-6\u003e :tabn 6\u003cCR\u003enoremap \u003cD-7\u003e :tabn 7\u003cCR\u003enoremap \u003cD-8\u003e :tabn 8\u003cCR\u003enoremap \u003cD-9\u003e :tabn 9\u003cCR\u003e\" Command-0 goes to the last tabnoremap \u003cD-0\u003e :tablast\u003cCR\u003eendifset guifont=Monaco:h18colorscheme OceanicNextnnoremap \u003cEsc\u003ej :m .+1\u003cCR\u003e==nnoremap \u003cEsc\u003ek :m .-2\u003cCR\u003e==inoremap \u003cEsc\u003ej \u003cEsc\u003e:m .+1\u003cCR\u003e==giinoremap \u003cEsc\u003ek \u003cEsc\u003e:m .-2\u003cCR\u003e==givnoremap \u003cEsc\u003ej :m '\u003e+1\u003cCR\u003egv=gvvnoremap \u003cEsc\u003ek :m '\u003c-2\u003cCR\u003egv=gv Источники12 Learn Vim For the Last Time: A Tutorial and Primer ↩︎  ↩︎ ","date":"14.09.2020","objectID":"/vim-settings/:3:0","series":null,"tags":["vim"],"title":"Настройки Vim","uri":"/vim-settings/#дополнительные-настройки"},{"categories":["redseo"],"content":"PopUp для ContactForm 7 - это просто! Всплывающая форма обратной связи для WordPress на основе плагина Popup Maker. Описание с картинками по шагам.","date":"14.03.2017","objectID":"/popup-contact-form-7-vsplyvayushhee-okno/","series":null,"tags":["wordpress","how-to"],"title":"Contact Form 7 во всплывающем окне - PopUp форма для Wordpress","uri":"/popup-contact-form-7-vsplyvayushhee-okno/"},{"categories":["redseo"],"content":"Contact Form 7 во всплывающем окне - это легко. Нужно всего лишь установить… ","date":"14.03.2017","objectID":"/popup-contact-form-7-vsplyvayushhee-okno/:0:0","series":null,"tags":["wordpress","how-to"],"title":"Contact Form 7 во всплывающем окне - PopUp форма для Wordpress","uri":"/popup-contact-form-7-vsplyvayushhee-okno/#"},{"categories":["redseo"],"content":"Popup Maker Устанавливаем плагин Popup Maker Создаем форму в Contact Form 7 и копируем ее шорткод В Popup Maker нажимаем “Добавить новое всплывающее окно” В поле редактора вставляем шорткод формы Вставка шорткода CF7 в Popup Maker\" Вставка шорткода CF7 в Popup Maker В разделе “Настройки всплывающего окна” нажать “Добавить новый триггер” Класс для ссылки открытия формы\" Класс для ссылки открытия формы Добавить нужный триггер (например, на клик по чему угодно с определенным css-классом - “Нажатие Открыть”) Сохраняем получившееся окно В любом месте вставляем ссылку с классом, указанным у только что созданного всплывающего окна. \u003ca class=\"popmake-137\"\u003eЗаказать звонок\u003c/a\u003e Вы великолепны! ","date":"14.03.2017","objectID":"/popup-contact-form-7-vsplyvayushhee-okno/:1:0","series":null,"tags":["wordpress","how-to"],"title":"Contact Form 7 во всплывающем окне - PopUp форма для Wordpress","uri":"/popup-contact-form-7-vsplyvayushhee-okno/#popup-maker"},{"categories":["redseo"],"content":"Easy FancyBox - устаревший способ UPD 2022! Если способ не рабочий - напишите в комментвриях, протестирую и поправлю. Устанавливаем плагин Easy FancyBox. Заходим в Настройки -\u003e Медиафайлы. Сверху видим блок стандартных настроек медиафайлов, а ниже настройки плагина Easy FancyBox. По умолчанию активен попап при нажатии на изображение. Настройки Easy FancyBox\" Настройки Easy FancyBox Если стоит сторонний плагин лайтбокса, лучше эту галку снять, так как они будут конфликтовать и ваши изображения будут открываться во всплывающем окне дважды. Ставим галку на пункт «Inline content» Настройки Easy FancyBox 2\" Настройки Easy FancyBox 2 Нажимаем на кнопку «Сохранить изменения». Код с всплывающей контактной формой, установленный в коде файла шаблона (например в footer.php): \u003cdiv style=\"display:none\" class=\"fancybox-hidden\"\u003e \u003cdiv id=\"contact_form_pop\"\u003e \u003c?php echo do_shortcode('[ contact-form-7 id=\"420\" title=\"Заказать звонок\" ]');?\u003e\u003c/div\u003e \u003c/div\u003e Если Вы вставляете код вызова формы в Визуальном редакторе для редактирования текста в режиме ТЕКСТ, тогда код будет выглядеть так: \u003cdiv style=\"display:none\" class=\"fancybox-hidden\"\u003e \u003cdiv id=\"contact_form_pop\"\u003e [contact-form-7 404 \"Not Found\"] \u003c/div\u003e \u003c/div\u003e Код кнопки, открывающей попап: \u003ca href=\"#contact_form_pop\" class=\"fancybox-inline\"\u003eЗаказать звонок\u003c/a\u003e Возникла странная проблема с относительными ссылками в хэдере. К ссылке на активацию формы упорно приписывался адрес главной страницы. Победил это добавив пробел перед решеткой. Оформление всплывающего окна Для придания форме нужного вида необходимо обернуть поля в дивы, указать им классы. Это лучше делать непосредственно в редакторе форм CF7. Стили можно прописать в custom.css Для закрытия popup окна с формой обратной связи после успешной отправки в блок “Дополнительные настройки” вашей формы. on_sent_ok: $.fancybox.close(); Закрытие окна и код метрики\" Закрытие окна и код метрики ","date":"14.03.2017","objectID":"/popup-contact-form-7-vsplyvayushhee-okno/:2:0","series":null,"tags":["wordpress","how-to"],"title":"Contact Form 7 во всплывающем окне - PopUp форма для Wordpress","uri":"/popup-contact-form-7-vsplyvayushhee-okno/#easy-fancybox---устаревший-способ"},{"categories":["redseo"],"content":"Установка OpenCart 2.3 на хостинг это самое начало создания интернет-магазина. Установить опенкарт - самое простое, дальше будет сложнее.","date":"27.02.2017","objectID":"/ustanovka-opencart-2-3-na-hosting/","series":null,"tags":["opencart","how-to"],"title":"Установка OpenCart 2.3 на хостинг по шагам с картинками","uri":"/ustanovka-opencart-2-3-na-hosting/"},{"categories":["redseo"],"content":"Установка OpenCart 2.3 будет производиться на примере реального домена и хостинга с панелью ISP Manager. Нет хостинга? -\u003e Как зарегистрировать хостинг Как зарегистрировать домен -- Устанавливать мы будем не чистую версию OpenCart, а качественную российскую сборку OpenCart.pro. Процесс установки официального дистрибутива абсолютно ничем не отличается. Более того, точно так же происходит установка OCstore (тоже отличная русская сборка опенкарта). Почему OpenCart.pro, а не чистый OpenCart? Преимуществ на самом деле куча! Посмотрите на странице сравнения. ","date":"27.02.2017","objectID":"/ustanovka-opencart-2-3-na-hosting/:0:0","series":null,"tags":["opencart","how-to"],"title":"Установка OpenCart 2.3 на хостинг по шагам с картинками","uri":"/ustanovka-opencart-2-3-na-hosting/#"},{"categories":["redseo"],"content":"ШАГ 1 — Распаковка файлов В ISP панели открываем менеджер файлов; Переходим в папку домена; Если есть какие-то файлы — удаляем; Заливаем архив Opencart (нам нужна папка upload); Загрузка архива с CMS на хостингЗаливка опенкарт на сервер \" Загрузка архива с CMS на хостинг Распаковываем. Распаковка opencartРаспаковка opencart \" Распаковка opencart После окончания распаковки сам архив можно удалить. Как было написано выше, нам нужно только содержимое папки upload. Поэтому, переходим в эту папку, выделяем в ней все файлы (клик по первому файлу, зажать shift, клик по последнему), жмем «Вырезать». Файлы в папке uploadФайлы в папке upload \" Файлы в папке upload Возвращаемся в корневую директорию домена и жмем «Вставить». Разархивированную папку можно удалить. Остаются только файлы и папки из upload. Нужные файлы и папкиНужные файлы и папки \" Нужные файлы и папки Файл .htaccess.txt переименовываем в .htaccess Файл config-dist.php переименовываем в config.php Заходим в папку admin, там тоже есть файл config-dist.php — переименовываем в config.php Чтобы переименовать файл нужно выделить его и нажать кнопку «Аттрибуты». В открывшемся окне изменить имя файла. Переименование файловПереименование файлов \" Переименование файлов ","date":"27.02.2017","objectID":"/ustanovka-opencart-2-3-na-hosting/:1:0","series":null,"tags":["opencart","how-to"],"title":"Установка OpenCart 2.3 на хостинг по шагам с картинками","uri":"/ustanovka-opencart-2-3-na-hosting/#шаг-1--распаковка-файлов"},{"categories":["redseo"],"content":"ШАГ 2 — Создание базы данных Переходим в раздел «Базы данных»; Нажимаем кнопку «Создать»; В появившемся окне заполняем Имя базы, Имя пользователя, Пароль, Подтверждение пароля (на хостинге регру в название базы и пользователя дописывается логин хостинга, поэтому не стоит придумывать длинное название); Жмем «Ок» — база готова; Не забудьте сохранить имя базы, имя пользователя и пароль в файлик. Создание БД для opencartСоздание БД для opencart \" Создание БД для opencart ","date":"27.02.2017","objectID":"/ustanovka-opencart-2-3-na-hosting/:2:0","series":null,"tags":["opencart","how-to"],"title":"Установка OpenCart 2.3 на хостинг по шагам с картинками","uri":"/ustanovka-opencart-2-3-na-hosting/#шаг-2--создание-базы-данных"},{"categories":["redseo"],"content":"ШАГ 3 — Установка OpenCartИтак, все подготовительные шаги пройдены. Переходим непосредственно к установке. Заходим на свой сайт и следуем простым шагам. Шаг 1 - Лицензионное соглашение Жмем «Продолжить» Установка opencart 2.3 - шаг 1Установка opencart 2.3 - шаг 1 \" Установка opencart 2.3 - шаг 1 Шаг 2 - Проверка соответствия сервера На втором шаге система проверяет соответствие сервера требованиям системы. С хостингом reg.ru на этом шаге проблем никогда не возникало. Установка opencart 2.3 - шаг 2Установка opencart 2.3 - шаг 2 \" Установка opencart 2.3 - шаг 2 Шаг 3 - Подключение к БД На данном шаге мы вводим данные для подключения к базе данных. Вы ведь сохранили их в файлик? ) Так же придумайте логин, пароль и электронную почту администратора. Установка opencart 2.3 - шаг 3Установка opencart 2.3 - шаг 3 \" Установка opencart 2.3 - шаг 3 Шаг 4 - Завершение установки Всё. Установка прошла успешно. Теперь нам предлагают перейти на главную страницу нашего магазина, или зайти в панель администратора. Установка opencart 2.3 - шаг 4Установка opencart 2.3 - шаг 4 \" Установка opencart 2.3 - шаг 4 И, конечно же, обязательно удалите папку install из директории сайта! Удаляем папку installУдаляем папку install \" Удаляем папку install Готово! Самый легкий этап в создании интернет-магазина пройден. Можно переходить к первоначальной настройке Опенкарта. ","date":"27.02.2017","objectID":"/ustanovka-opencart-2-3-na-hosting/:3:0","series":null,"tags":["opencart","how-to"],"title":"Установка OpenCart 2.3 на хостинг по шагам с картинками","uri":"/ustanovka-opencart-2-3-na-hosting/#шаг-3--установка-opencart"},{"categories":["redseo","notes"],"content":"Куски кода, которые частенько требуются. Поэтому лучше держать их под рукой.","date":"25.03.2016","objectID":"/polezno-znat-pri-rabote-s-bitriks/","series":null,"tags":false,"title":"Полезные сниппеты для 1C-Bitrix","uri":"/polezno-znat-pri-rabote-s-bitriks/"},{"categories":["redseo","notes"],"content":"Получить адрес страницы Битрикс $page = $APPLICATION-\u003eGetCurPage(); echo $page; ","date":"25.03.2016","objectID":"/polezno-znat-pri-rabote-s-bitriks/:1:0","series":null,"tags":false,"title":"Полезные сниппеты для 1C-Bitrix","uri":"/polezno-znat-pri-rabote-s-bitriks/#получить-адрес-страницы-битрикс"},{"categories":["redseo","notes"],"content":"Редирект Битрикс RewriteEngine On RewriteCond %{HTTP_HOST} ^www.elitbar\\.ru$ [NC] RewriteRule ^(.*)$ http://elitbar.ru/$1 [R=301,L] RewriteEngine On RewriteCond %{HTTP_HOST} ^www.example.ru$ [NC] RewriteRule ^(.*)$ http://example.ru/$1 [R=301,L] ","date":"25.03.2016","objectID":"/polezno-znat-pri-rabote-s-bitriks/:2:0","series":null,"tags":false,"title":"Полезные сниппеты для 1C-Bitrix","uri":"/polezno-znat-pri-rabote-s-bitriks/#редирект-битрикс"},{"categories":["redseo","notes"],"content":"Вывод $arResult if($USER-\u003eIsAdmin()) {echo '\u003cpre\u003e'; print_r($arResult); echo '\u003c/pre\u003e';} ","date":"25.03.2016","objectID":"/polezno-znat-pri-rabote-s-bitriks/:3:0","series":null,"tags":false,"title":"Полезные сниппеты для 1C-Bitrix","uri":"/polezno-znat-pri-rabote-s-bitriks/#вывод-arresult"},{"categories":["redseo","notes"],"content":"Проверка адреса страницы $uri = $APPLICATION-\u003eGetCurPage(); if ($uri == «/news/142/») { include(«ваш_код.php»); } ","date":"25.03.2016","objectID":"/polezno-znat-pri-rabote-s-bitriks/:4:0","series":null,"tags":false,"title":"Полезные сниппеты для 1C-Bitrix","uri":"/polezno-znat-pri-rabote-s-bitriks/#проверка-адреса-страницы"},{"categories":["redseo","notes"],"content":"Вывод названия раздела $res = CIBlockSection::GetByID(«#ID_РАЗДЕЛА#»); if($ar_res = $res-\u003eGetNext()) echo $ar_res[‘NAME’]; ","date":"25.03.2016","objectID":"/polezno-znat-pri-rabote-s-bitriks/:5:0","series":null,"tags":false,"title":"Полезные сниппеты для 1C-Bitrix","uri":"/polezno-znat-pri-rabote-s-bitriks/#вывод-названия-раздела"},{"categories":["redseo","notes"],"content":"Вывод пользовательского поля Битрикс $rsResult = CIBlockSection::GetList( array(\"SORT\" =\u003e \"ASC\"), array(\"IBLOCK_ID\" =\u003e $arParams[\"IBLOCK_ID\"], \"ID\" =\u003e$arResult[\"SECTION\"][\"ID\"]), false, $arSelect = array(\"UF_*\") ); // возвращаем список разделов с нужными нам пользовательскими полями. // UF_* — в таком виде выведет все доступные для данного раздела поля. // $arParams[\"IBLOCK_ID\"] — у вас может быть получением ID инфоблока другим способом // $arResult[\"SECTION\"][\"ID\"] — и ID раздела тоже, проверяйте через print_r($arResult); if($arSection = $rsResult -\u003e GetNext()){ $arResult[\"SECTION_USER_FIELDS\"][\"UF_VASHE_NAZVANIE\"] = $arSection[\"UF_VASHE_NAZVANIE\"]; } // создаем переменные с содержимым наших пользовательских полей if($arResult[\"SECTION_USER_FIELDS\"][\"UF_VASHE_NAZVANIE\"]) { echo htmlspecialchars_decode($arResult[\"SECTION_USER_FIELDS\"][\"UF_VASHE_NAZVANIE\"]).\"\u003cbr/\u003e\"; } // выводим содержимое полей, если оно присутствует ","date":"25.03.2016","objectID":"/polezno-znat-pri-rabote-s-bitriks/:6:0","series":null,"tags":false,"title":"Полезные сниппеты для 1C-Bitrix","uri":"/polezno-znat-pri-rabote-s-bitriks/#вывод-пользовательского-поля-битрикс"},{"categories":["redseo","notes"],"content":"Добавляем и убираем слэш в конце урла # Рабочий вариант RewriteCond %{REQUEST_FILENAME} !-f RewriteCond %{REQUEST_URI} !\\..+$ RewriteCond %{REQUEST_URI} !/$ RewriteRule (.*) http://www.site.ru/$1/ [R=301,L] Еще варианты: # убираем слэш в конце RewriteCond %{REQUEST_FILENAME} !-d RewriteCond %{REQUEST_URI} ^(.+)/$ RewriteRule ^(.+)/$ /$1 [R=301,L] # добавляем слэш в конце RewriteBase / RewriteCond %{REQUEST_FILENAME} !-f RewriteCond %{REQUEST_URI} !(.*)/$ RewriteRule ^(.*[^/])$ $1/ [L,R=301] ","date":"25.03.2016","objectID":"/polezno-znat-pri-rabote-s-bitriks/:7:0","series":null,"tags":false,"title":"Полезные сниппеты для 1C-Bitrix","uri":"/polezno-znat-pri-rabote-s-bitriks/#добавляем-и-убираем-слэш-в-конце-урла"},{"categories":["redseo","notes"],"content":"Убираем дубли слэша RewriteCond %{REQUEST_URI} ^(.*)//(.*)$ RewriteRule . %1/%2 [R,L] ","date":"25.03.2016","objectID":"/polezno-znat-pri-rabote-s-bitriks/:8:0","series":null,"tags":false,"title":"Полезные сниппеты для 1C-Bitrix","uri":"/polezno-znat-pri-rabote-s-bitriks/#убираем-дубли-слэша"},{"categories":["redseo","notes"],"content":"Правила в .htaccess для отдельных sitemap.xml и robots.txt региональных поддоменов CMS Bitrix","date":"25.03.2016","objectID":"/otdelnyj-robots-i-sitemap-dlya-poddomenov-bitrix/","series":null,"tags":false,"title":"Отдельный robots.txt и sitemap.xml для поддоменов Bitrix","uri":"/otdelnyj-robots-i-sitemap-dlya-poddomenov-bitrix/"},{"categories":["redseo","notes"],"content":"Для использования региональных поддоменов нам нужно для каждого поддомена указать собственные robots.txt и sitemap.xml ","date":"25.03.2016","objectID":"/otdelnyj-robots-i-sitemap-dlya-poddomenov-bitrix/:0:0","series":null,"tags":false,"title":"Отдельный robots.txt и sitemap.xml для поддоменов Bitrix","uri":"/otdelnyj-robots-i-sitemap-dlya-poddomenov-bitrix/#"},{"categories":["redseo","notes"],"content":"Добавление файлов вручнуюФайлы можно формировать вручную. В файл .htaccess для каждого поддомена добавить следующие правила: RewriteEngine On RewriteCond %{HTTP_HOST} spb.mysite.ru [NC] RewriteRule ^robots\\.txt /robots_spb.txt [NC,L] RewriteCond %{HTTP_HOST} spb.mysite.ru [NC] RewriteRule ^sitemap\\.xml /sitemap_spb.xml [NC,L] ","date":"25.03.2016","objectID":"/otdelnyj-robots-i-sitemap-dlya-poddomenov-bitrix/:1:0","series":null,"tags":false,"title":"Отдельный robots.txt и sitemap.xml для поддоменов Bitrix","uri":"/otdelnyj-robots-i-sitemap-dlya-poddomenov-bitrix/#добавление-файлов-вручную"},{"categories":["redseo","notes"],"content":"Готовые решения от АспроВ большинстве готовых решение от компании «Аспро» интегрирован функционал региональных поддоменов. Сделано все довольно качественно, имеется большое количество настроек и несколько режимов работы. ","date":"25.03.2016","objectID":"/otdelnyj-robots-i-sitemap-dlya-poddomenov-bitrix/:2:0","series":null,"tags":false,"title":"Отдельный robots.txt и sitemap.xml для поддоменов Bitrix","uri":"/otdelnyj-robots-i-sitemap-dlya-poddomenov-bitrix/#готовые-решения-от-аспро"},{"categories":["redseo","notes"],"content":"Сторонний модуль для региональных поддоменовИщем в маркетплэйсе ","date":"25.03.2016","objectID":"/otdelnyj-robots-i-sitemap-dlya-poddomenov-bitrix/:3:0","series":null,"tags":false,"title":"Отдельный robots.txt и sitemap.xml для поддоменов Bitrix","uri":"/otdelnyj-robots-i-sitemap-dlya-poddomenov-bitrix/#сторонний-модуль-для-региональных-поддоменов"},{"categories":["redseo"],"content":"Простой способ собрать все адреса электронных почт из ячеек с текстом в файлах .xls и .xlsx","date":"21.07.2015","objectID":"/ms-excel-vytaskivaem-elektronnye-pochty-iz-teksta/","series":null,"tags":["excel","how-to"],"title":"MS Excel - вытаскиваем электронные почты из текста","uri":"/ms-excel-vytaskivaem-elektronnye-pochty-iz-teksta/"},{"categories":["redseo"],"content":"Создаем новый документ MS Excel. В первом столбце у нас будут входные данные, содержащие Email адреса. Во второй столбец мы вставляем формулу, которая заменяет символ новой строки (переносы) на символ пробела. Этим действием мы приводим всё содержимое ячейки к однострочному виду, даже если изначально текст там располагался в несколько строк. =ЕСЛИ(ЕПУСТО(A1);СЦЕПИТЬ(A1;\"Пустая строка\");ПОДСТАВИТЬ(A1;СИМВОЛ(10);\" \")) Растягиваем эту формулу на весь столбец. Растягиваем формулу\" Растягиваем формулу Идем на вкладку «Разработчик» и открываем редактор скриптов VB Редактор скриптов\" Редактор скриптов Открывается окно редактора скриптов. Для Листа 1 вставляем скрипт. Вставляем скрипт\" Вставляем скрипт Вот сам скрипт. SubExtractMail() ConstSepCharAsString=\" \u003c\u003e[]:;,() \" Dimr1AsLong,r2AsLong,sAsString IfSheets.Count=1ThenSheets.Addafter:=Sheets(1):Sheets(1).Activate Sheets(2).Columns(1).ClearContents r1=Cells(Rows.Count,2).End(xlUp).End(xlUp).Row r2=1 Do s=Cells(r1,2) p=1 Do p=InStr(p,s,\"@\") Ifp\u003e0Then i=p:Do:i=i-1:LoopUntili=1OrInStr(SepChar,Mid(s,i,1))\u003e0 p1=i+IIf(InStr(SepChar,Mid(s,i,1))\u003e0,1,0) i=p:Do:i=i+1:LoopUntili=Len(s)OrInStr(SepChar,Mid(s,i,1))\u003e0 p2=i+IIf(InStr(SepChar,Mid(s,i,1))\u003e0,0,1) Sheets(2).Cells(r2,1)=Mid(s,p1,p2-p1) r2=r2+1 p=p+1 EndIf LoopUntilp=0 r1=r1+1 LoopUntilCells(r1,1)=\"\" EndSub Осталось только запустить данный скрипт Запускаем скрипт\" Запускаем скрипт и на Листе 2 мы получим чистые электронные адреса. Результат обработки email адресов\" Результат обработки email адресов ","date":"21.07.2015","objectID":"/ms-excel-vytaskivaem-elektronnye-pochty-iz-teksta/:0:0","series":null,"tags":["excel","how-to"],"title":"MS Excel - вытаскиваем электронные почты из текста","uri":"/ms-excel-vytaskivaem-elektronnye-pochty-iz-teksta/#"},{"categories":["redseo"],"content":"В этой статье я расскажу как выбрать хостинг для сайта на Bitrix, Wordpress и других CMS, как зарегистрировать хостинг, и как привязать сайт к хостингу.","date":"21.07.2015","objectID":"/kak-zaregistrirovat-hosting/","series":null,"tags":["Hosting","how-to"],"title":"Как выбрать и зарегистрировать хостинг для сайта в Reg.ru","uri":"/kak-zaregistrirovat-hosting/"},{"categories":["redseo"],"content":"Предположим, что домен у вас уже есть. Чтобы двигаться дальше, нам нужно место, где будет располагаться наш сайт - это и есть хостинг. ","date":"21.07.2015","objectID":"/kak-zaregistrirovat-hosting/:0:0","series":null,"tags":["Hosting","how-to"],"title":"Как выбрать и зарегистрировать хостинг для сайта в Reg.ru","uri":"/kak-zaregistrirovat-hosting/#"},{"categories":["redseo"],"content":"Какой хостинг для сайта выбрать?Если Вы настроены серьезно, и хотите в дальнейшем иметь стабильно работающий сайт, то на хостинге экономить не стоит. Сразу отметаем все бесплатные хостинги - это не для нас. Я, как обычно, советую пользоваться услугами REG.ru. Пользуюсь их услугами с 2013 года и за все время серьезных нареканий небыло. По стоимости тоже есть из чего выбрать (1900 ₽ за 12 месяцев - тариф для одного сайта). К тому же, очень удобно, когда все услуги находятся в одном личном кабинете. Бесплатный SSL-сертификат от Let's Encrypt На хостинге рег.ру бесплатный SSL-сертификат выпускается в два клика. Это позволяет сэкономить немалые деньги. Host-A - оптимальный тариф для одного сайта. Регистрируемся, заходим в личный кабинет и начинаем процесс оформления. У Рег.ру много специализированных тарифов под определенные системы управления (CMS). Например, если Вы точно знаете, что хотите создать сайт на CMS Bitrix, то можно и тариф выбрать соответствующий - Хостинг для Bitrix. В любом случае, что бы Вы ни выбрали, дальнейший ход действий однотипен. ","date":"21.07.2015","objectID":"/kak-zaregistrirovat-hosting/:1:0","series":null,"tags":["Hosting","how-to"],"title":"Как выбрать и зарегистрировать хостинг для сайта в Reg.ru","uri":"/kak-zaregistrirovat-hosting/#какой-хостинг-для-сайта-выбрать"},{"categories":["redseo"],"content":"Как зарегистрировать хостинг для сайта? Определяемся с нужным тарифом и нажимаем кнопку “Выбрать” Выбор тарифа хостинга\" Выбор тарифа хостинга Выбираем срок, на который хотим зарегистрировать хостинг (по окончании срока его без проблем можно продлить) и дополнительные опции (рекомендую отказаться от “пакета+” и условно “бесплатного” SSL, т.к. через год вам предложат продлить его платно, а мы без проблем выпустим полностью бесплатный сертификат от Let’s Encrypt) Дополнительные опции на этапе заказа\" Дополнительные опции на этапе заказа Рядом с кнопкой “Оплатить” есть кнопка ввода промокода. Вот промокод на скидку в 5% (мелочь, а приятно): 79A9-22FC-E2BD-1DF7 После оплаты хостинга вам предложат завершить его настройку указав номер телефона и данные владельца (Физ.лица, или организации). Внимание! Важно заполнять поля в соответствии с паспортными данными. Иначе могут возникнуть проблемы при решении каких-либо вопросов. После заполнения всех полей хостинг станет активен в течение нескольких минут. Перейдите во вкладку “Домены” в личном кабинете и привяжем домен к купленому хостингу. ","date":"21.07.2015","objectID":"/kak-zaregistrirovat-hosting/:2:0","series":null,"tags":["Hosting","how-to"],"title":"Как выбрать и зарегистрировать хостинг для сайта в Reg.ru","uri":"/kak-zaregistrirovat-hosting/#как-зарегистрировать-хостинг-для-сайта"},{"categories":["redseo"],"content":"Выпуск бесплатного SSL-сертификатаДля выпуска сертификата от Let’s Encrypt ваш домен должен быть привязан к хостингу. После привязки лучше выждать некоторое время (до 24 часов), чтобы обновились DNS записи. Заходим в панель управления хлстингом (в моем примере это ISP Manager) Переходим в раздел SSL-сертификаты и нажимаем кнопку “Let’s Encrypt” Выпуск сертификата Let’s EncryptВыпуск сертификата Let's Encrypt \" Выпуск сертификата Let’s Encrypt Выбираем домен, для которого будет выпущен сертификат. Если нужен Wildcard сертификат (для поддоменов) - ставим соответствующую галочку. Остальные опции можно оставить по умолчанию. Нажимаем “Ок”. Дополнительные опции на этапе заказа\" Дополнительные опции на этапе заказа Ждем автоматического выпуска и установки сертификата (в списке сертификатов статус сменится с “самоподписной” на “существующий”) Переходим в раздел “Сайты”, кликаем два раза по домену и ставим галочки в разделе SSL Дополнительные опции на этапе заказа\" Дополнительные опции на этапе заказа Сохраняем. Готово! ","date":"21.07.2015","objectID":"/kak-zaregistrirovat-hosting/:3:0","series":null,"tags":["Hosting","how-to"],"title":"Как выбрать и зарегистрировать хостинг для сайта в Reg.ru","uri":"/kak-zaregistrirovat-hosting/#выпуск-бесплатного-ssl-сертификата"}]